{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentName from 'shared/getComponentName';\nimport { Placement, Deletion } from 'shared/ReactSideEffectTags';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE, REACT_PORTAL_TYPE, REACT_BLOCK_TYPE } from 'shared/ReactSymbols';\nimport { FunctionComponent, ClassComponent, HostText, HostPortal, Fragment, Block } from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport { warnAboutStringRefs, enableBlocksAPI } from 'shared/ReactFeatureFlags';\nimport { createWorkInProgress, resetWorkInProgress, createFiberFromElement, createFiberFromFragment, createFiberFromText, createFiberFromPortal } from './ReactFiber';\nimport { emptyRefsObject } from './ReactFiberClassComponent';\nimport { getCurrentFiberStackInDev, getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { isCompatibleFamilyForHotReloading } from './ReactFiberHotReloading';\nimport { StrictMode } from './ReactTypeOfMode';\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\n\nlet warnForMissingKey = child => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = child => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    invariant(typeof child._store === 'object', 'React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    child._store.validated = true;\n    const currentComponentErrorInfo = 'Each child in a list should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + getCurrentFiberStackInDev();\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n    console.error('Each child in a list should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.');\n  };\n}\n\nconst isArray = Array.isArray;\n\nfunction coerceRef(returnFiber, current, element) {\n  let mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n        const componentName = getComponentName(returnFiber.type) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error('Component \"%s\" contains the string ref \"%s\". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref%s', componentName, mixedRef, getStackByFiberInDevAndProd(returnFiber));\n          } else {\n            console.error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref%s', mixedRef, getStackByFiberInDevAndProd(returnFiber));\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner = element._owner;\n      let inst;\n\n      if (owner) {\n        const ownerFiber = owner;\n        invariant(ownerFiber.tag === ClassComponent, 'Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref');\n        inst = ownerFiber.stateNode;\n      }\n\n      invariant(inst, 'Missing owner for string ref %s. This error is likely caused by a ' + 'bug in React. Please file an issue.', mixedRef);\n      const stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      const ref = function (value) {\n        let refs = inst.refs;\n\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(typeof mixedRef === 'string', 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      invariant(element._owner, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://fb.me/react-refs-must-have-owner for more information.', mixedRef);\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    let addendum = '';\n\n    if (__DEV__) {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getCurrentFiberStackInDev();\n    }\n\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  if (__DEV__) {\n    const currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + getCurrentFiberStackInDev();\n\n    if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n    console.error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    } // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n\n\n    const last = returnFiber.lastEffect;\n\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    let childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren = new Map();\n    let existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n\n    const current = newFiber.alternate;\n\n    if (current !== null) {\n      const oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // 如果是初始渲染 会在根组件(App)上设置 effectTag 属性为 Placement 值为 1\n    // 其他子级节点具有默认值为 0 防止在 commit 阶段反复操作真实DOM\n    // 初始渲染时如果当前处理的是根组件 true 其他组件 false\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      // Placement 表示新创建的节点\n      newFiber.effectTag = Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null) {\n      if (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:\n      __DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false)) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      } else if (enableBlocksAPI && current.tag === Block && element.type.$$typeof === REACT_BLOCK_TYPE && element.type.render === current.type.render) {\n        // Same as above but also update the .type field.\n        const existing = useFiber(current, element.props);\n        existing.return = returnFiber;\n        existing.type = element.type;\n\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // 创建 Fiber 对象\n\n\n    const created = createFiberFromElement(element, returnFiber.mode, expirationTime); // 添加 ref 属性\n\n    created.ref = coerceRef(returnFiber, current, element); // 添加父级 Fiber 对象\n\n    created.return = returnFiber; // 返回创建的 Fiber 对象\n\n    return created;\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            created.ref = coerceRef(returnFiber, null, newChild);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const created = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            created.return = returnFiber;\n            return created;\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n\n            return updateElement(returnFiber, matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, matchedFiber, newChild, expirationTime);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys) {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          const key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          console.error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return knownKeys;\n  } // 处理子元素是数组的情况\n\n\n  function reconcileChildrenArray( // 父级 Fiber\n  returnFiber, currentFirstChild, // 子级 vdom 数组\n  newChildren, expirationTime) {\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n    /**\n     * 存储第一个子节点 Fiber 对象\n     * 方法返回的也是第一个子节点 Fiber 对象\n     * 因为其他子节点 Fiber 对象都存储在上一个子 Fiber 节点对象的 sibling 属性中\n     */\n\n\n    let resultingFirstChild = null; // 上一次创建的 Fiber 对象\n\n    let previousNewFiber = null; // 初始渲染没有旧的子级 所以为 null\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null; // 初始渲染 oldFiber 为 null 循环不执行\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    } // 初始渲染不执行\n\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    } // oldFiber 为空 说明是初始渲染\n\n\n    if (oldFiber === null) {\n      // 遍历子 vdom 对象\n      for (; newIdx < newChildren.length; newIdx++) {\n        // 创建子 vdom 对应的 fiber 对象\n        const newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime); // 如果 newFiber 为 null\n\n        if (newFiber === null) {\n          // 进入下次循环\n          continue;\n        } // 初始渲染时只为 newFiber 添加了 index 属性,\n        // 其他事没干. lastPlacedIndex 被原封不动的返回了\n\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); // 为当前节点设置下一个兄弟节点\n\n        if (previousNewFiber === null) {\n          // 存储第一个子 Fiber 发生在第一次循环时\n          resultingFirstChild = newFiber;\n        } else {\n          // 为节点设置下一个兄弟 Fiber\n          previousNewFiber.sibling = newFiber;\n        } // 在循环的过程中更新上一个创建的Fiber 对象\n\n\n        previousNewFiber = newFiber;\n      } // 返回创建好的子 Fiber\n      // 其他 Fiber 都作为 sibling 存在\n\n\n      return resultingFirstChild;\n    } // 下面的代码初始渲染不执行\n    // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    } // 初始渲染不执行\n\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    } // 返回第一个子元素 Fiber 对象\n\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(typeof iteratorFn === 'function', 'An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          console.error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error('Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      const newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, 'An iterable object provided no iterator.');\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    let step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, expirationTime);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  } // 处理子元素是文本或者数值的情况\n\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // 初始渲染不执行\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // 现有的第一个子节点不是文本节点，因此我们需要创建一个并删除现有的.\n    // 初始渲染不执行\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild); // 根据文本创建 Fiber 对象\n\n    const created = createFiberFromText(textContent, returnFiber.mode, expirationTime); // 设置父 Fiber 对象\n\n    created.return = returnFiber; // 返回创建好的 Fiber 对象\n\n    return created;\n  } // 处理子元素是单个对象的情况\n\n\n  function reconcileSingleElement( // 父 Fiber 对象\n  returnFiber, // 备份子 fiber\n  currentFirstChild, // 子 vdom 对象\n  element, expirationTime) {\n    const key = element.key;\n    let child = currentFirstChild; // 初始渲染 currentFirstChild 为 null\n    // false\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        switch (child.tag) {\n          case Fragment:\n            {\n              if (element.type === REACT_FRAGMENT_TYPE) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                const existing = useFiber(child, element.props.children);\n                existing.return = returnFiber;\n\n                if (__DEV__) {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n\n                return existing;\n              }\n\n              break;\n            }\n\n          case Block:\n            if (enableBlocksAPI) {\n              if (element.type.$$typeof === REACT_BLOCK_TYPE && element.type.render === child.type.render) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                const existing = useFiber(child, element.props);\n                existing.type = element.type;\n                existing.return = returnFiber;\n\n                if (__DEV__) {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n\n                return existing;\n              }\n            }\n\n          // We intentionally fallthrough here if enableBlocksAPI is not on.\n          // eslint-disable-next-lined no-fallthrough\n\n          default:\n            {\n              if (child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:\n              __DEV__ ? isCompatibleFamilyForHotReloading(child, element) : false)) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                const existing = useFiber(child, element.props);\n                existing.ref = coerceRef(returnFiber, child, element);\n                existing.return = returnFiber;\n\n                if (__DEV__) {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n\n                return existing;\n              }\n\n              break;\n            }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    } // 查看子 vdom 对象是否表示 fragment\n    // false\n\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // 根据 React Element 创建 Fiber 对象\n      // 返回创建好的 Fiber 对象\n      const created = createFiberFromElement(element, // 用来表示当前组件下的所有子组件要用处于何种渲染模式\n      // 文件位置: ./ReactTypeOfMode.js\n      // 0    同步渲染模式\n      // 100  异步渲染模式\n      returnFiber.mode, expirationTime); // 添加 ref 属性 { current: DOM }\n\n      created.ref = coerceRef(returnFiber, currentFirstChild, element); // 添加父级 Fiber 对象\n\n      created.return = returnFiber; // 返回创建好的子 Fiber\n\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    const key = portal.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  function reconcileChildFibers( // 父 Fiber 对象\n  returnFiber, // 旧的第一个子 Fiber 初始渲染 null\n  currentFirstChild, // 新的子 vdom 对象\n  newChild, // 初始渲染 整型最大值 代表同步任务\n  expirationTime) {\n    // 这是入口方法, 根据 newChild 类型进行对应处理\n    // 判断新的子 vdom 是否为占位组件 比如 <></>\n    // false\n    const isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null; // 如果 newChild 为占位符, 使用 占位符组件的子元素作为 newChild\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // 检测 newChild 是否为对象类型\n\n\n    const isObject = typeof newChild === 'object' && newChild !== null; // newChild 是单个对象的情况\n\n    if (isObject) {\n      // 匹配子元素的类型\n      switch (newChild.$$typeof) {\n        // 子元素为 ReactElement\n        case REACT_ELEMENT_TYPE:\n          // 为 Fiber 对象设置 effectTag 属性\n          // 返回创建好的子 Fiber\n          return placeSingleChild( // 处理单个 React Element 的情况\n          // 内部会调用其他方法创建对应的 Fiber 对象\n          reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    } // 处理 children 为文本和数值的情况 return \"App works\"\n\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, // 如果 newChild 是数值, 转换为字符串\n      '' + newChild, expirationTime));\n    } // children 是数组的情况\n\n\n    if (isArray(newChild)) {\n      // 返回创建好的子 Fiber\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            if (__DEV__) {\n              const instance = returnFiber.stateNode;\n\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n\n        case FunctionComponent:\n          {\n            const Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a ' + 'return statement is missing. Or, to render nothing, ' + 'return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n/**\n * shouldTrackSideEffects 标识, 是否为 Fiber 对象添加 effectTag\n * true 添加 false 不添加\n * 对于初始渲染来说, 只有根组件需要添加, 其他元素不需要添加, 防止过多的 DOM 操作\n */\n// 用于更新\n\n\nexport const reconcileChildFibers = ChildReconciler(true); // 用于初始渲染\n\nexport const mountChildFibers = ChildReconciler(false);\nexport function cloneChildFibers(current, workInProgress) {\n  invariant(current === null || workInProgress.child === current.child, 'Resuming work not yet implemented.');\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nexport function resetChildFibers(workInProgress, renderExpirationTime) {\n  let child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, renderExpirationTime);\n    child = child.sibling;\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactChildFiber.js"],"names":["getComponentName","Placement","Deletion","getIteratorFn","REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","REACT_PORTAL_TYPE","REACT_BLOCK_TYPE","FunctionComponent","ClassComponent","HostText","HostPortal","Fragment","Block","invariant","warnAboutStringRefs","enableBlocksAPI","createWorkInProgress","resetWorkInProgress","createFiberFromElement","createFiberFromFragment","createFiberFromText","createFiberFromPortal","emptyRefsObject","getCurrentFiberStackInDev","getStackByFiberInDevAndProd","isCompatibleFamilyForHotReloading","StrictMode","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefs","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","child","__DEV__","_store","validated","key","currentComponentErrorInfo","console","error","isArray","Array","coerceRef","returnFiber","current","element","mixedRef","ref","mode","_owner","_self","stateNode","componentName","type","owner","inst","ownerFiber","tag","stringRef","_stringRef","value","refs","throwOnInvalidObjectType","newChild","addendum","Object","prototype","toString","call","keys","join","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","last","lastEffect","nextEffect","firstEffect","effectTag","deleteRemainingChildren","currentFirstChild","sibling","mapRemainingChildren","existingChildren","Map","existingChild","set","index","useFiber","fiber","pendingProps","clone","placeChild","newFiber","lastPlacedIndex","newIndex","alternate","oldIndex","placeSingleChild","updateTextNode","textContent","expirationTime","created","return","existing","updateElement","elementType","props","_debugSource","_source","_debugOwner","$$typeof","render","updatePortal","portal","containerInfo","implementation","children","updateFragment","fragment","createChild","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","get","warnOnInvalidKey","knownKeys","Set","add","has","reconcileChildrenArray","newChildren","i","length","resultingFirstChild","previousNewFiber","nextOldFiber","delete","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","Symbol","toStringTag","entries","step","next","done","reconcileSingleTextNode","reconcileSingleElement","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","isObject","instance","_isMockFunction","Component","displayName","name","mountChildFibers","cloneChildFibers","workInProgress","currentChild","resetChildFibers","renderExpirationTime"],"mappings":"AAAA;;;;;;;;AAcA,OAAOA,gBAAP,MAA6B,yBAA7B;AACA,SAAQC,SAAR,EAAmBC,QAAnB,QAAkC,4BAAlC;AACA,SACEC,aADF,EAEEC,kBAFF,EAGEC,mBAHF,EAIEC,iBAJF,EAKEC,gBALF,QAMO,qBANP;AAOA,SACEC,iBADF,EAEEC,cAFF,EAGEC,QAHF,EAIEC,UAJF,EAKEC,QALF,EAMEC,KANF,QAOO,sBAPP;AAQA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,SAAQC,mBAAR,EAA6BC,eAA7B,QAAmD,0BAAnD;AAEA,SACEC,oBADF,EAEEC,mBAFF,EAGEC,sBAHF,EAIEC,uBAJF,EAKEC,mBALF,EAMEC,qBANF,QAOO,cAPP;AAQA,SAAQC,eAAR,QAA8B,4BAA9B;AACA,SACEC,yBADF,EAEEC,2BAFF,QAGO,qBAHP;AAIA,SAAQC,iCAAR,QAAgD,0BAAhD;AACA,SAAQC,UAAR,QAAyB,mBAAzB;AAEA,IAAIC,gBAAJ;AACA,IAAIC,sBAAJ;AACA,IAAIC,sBAAJ;AACA,IAAIC,qBAAJ;AACA,IAAIC,2BAAJ;;AACA,IAAIC,iBAAiB,GAAIC,KAAD,IAAkB,CAAE,CAA5C;;AAEA,IAAIC,OAAJ,EAAa;AACXP,EAAAA,gBAAgB,GAAG,KAAnB;AACAC,EAAAA,sBAAsB,GAAG,KAAzB;AACAC,EAAAA,sBAAsB,GAAG,EAAzB;AAEA;;;;;;AAKAC,EAAAA,qBAAqB,GAAG,EAAxB;AACAC,EAAAA,2BAA2B,GAAG,EAA9B;;AAEAC,EAAAA,iBAAiB,GAAIC,KAAD,IAAkB;AACpC,QAAIA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,QAAvC,EAAiD;AAC/C;AACD;;AACD,QAAI,CAACA,KAAK,CAACE,MAAP,IAAiBF,KAAK,CAACE,MAAN,CAAaC,SAA9B,IAA2CH,KAAK,CAACI,GAAN,IAAa,IAA5D,EAAkE;AAChE;AACD;;AACDxB,IAAAA,SAAS,CACP,OAAOoB,KAAK,CAACE,MAAb,KAAwB,QADjB,EAEP,gEACE,sEAHK,CAAT;AAKAF,IAAAA,KAAK,CAACE,MAAN,CAAaC,SAAb,GAAyB,IAAzB;AAEA,UAAME,yBAAyB,GAC7B,+CACA,uDADA,GAEA,mBAFA,GAGAf,yBAAyB,EAJ3B;;AAKA,QAAIO,qBAAqB,CAACQ,yBAAD,CAAzB,EAAsD;AACpD;AACD;;AACDR,IAAAA,qBAAqB,CAACQ,yBAAD,CAArB,GAAmD,IAAnD;AAEAC,IAAAA,OAAO,CAACC,KAAR,CACE,+CACE,uDADF,GAEE,mBAHJ;AAKD,GA7BD;AA8BD;;AAED,MAAMC,OAAO,GAAGC,KAAK,CAACD,OAAtB;;AAEA,SAASE,SAAT,CACEC,WADF,EAEEC,OAFF,EAGEC,OAHF,EAIE;AACA,MAAIC,QAAQ,GAAGD,OAAO,CAACE,GAAvB;;AACA,MACED,QAAQ,KAAK,IAAb,IACA,OAAOA,QAAP,KAAoB,UADpB,IAEA,OAAOA,QAAP,KAAoB,QAHtB,EAIE;AACA,QAAIb,OAAJ,EAAa;AACX;AACA;AACA,UACE,CAACU,WAAW,CAACK,IAAZ,GAAmBvB,UAAnB,IAAiCZ,mBAAlC,KACA;AACA;AACA;AACA,QACEgC,OAAO,CAACI,MAAR,IACAJ,OAAO,CAACK,KADR,IAEAL,OAAO,CAACI,MAAR,CAAeE,SAAf,KAA6BN,OAAO,CAACK,KAHvC,CALF,EAUE;AACA,cAAME,aAAa,GAAGtD,gBAAgB,CAAC6C,WAAW,CAACU,IAAb,CAAhB,IAAsC,WAA5D;;AACA,YAAI,CAACzB,sBAAsB,CAACwB,aAAD,CAA3B,EAA4C;AAC1C,cAAIvC,mBAAJ,EAAyB;AACvByB,YAAAA,OAAO,CAACC,KAAR,CACE,0EACE,gEADF,GAEE,mCAFF,GAGE,2CAHF,GAIE,8CALJ,EAMEa,aANF,EAOEN,QAPF,EAQEvB,2BAA2B,CAACoB,WAAD,CAR7B;AAUD,WAXD,MAWO;AACLL,YAAAA,OAAO,CAACC,KAAR,CACE,mEACE,oEADF,GAEE,sDAFF,GAGE,2CAHF,GAIE,8CALJ,EAMEO,QANF,EAOEvB,2BAA2B,CAACoB,WAAD,CAP7B;AASD;;AACDf,UAAAA,sBAAsB,CAACwB,aAAD,CAAtB,GAAwC,IAAxC;AACD;AACF;AACF;;AAED,QAAIP,OAAO,CAACI,MAAZ,EAAoB;AAClB,YAAMK,KAAa,GAAIT,OAAO,CAACI,MAA/B;AACA,UAAIM,IAAJ;;AACA,UAAID,KAAJ,EAAW;AACT,cAAME,UAAU,GAAKF,KAArB;AACA1C,QAAAA,SAAS,CACP4C,UAAU,CAACC,GAAX,KAAmBlD,cADZ,EAEP,kDACE,uCADF,GAEE,2CAFF,GAGE,4CALK,CAAT;AAOAgD,QAAAA,IAAI,GAAGC,UAAU,CAACL,SAAlB;AACD;;AACDvC,MAAAA,SAAS,CACP2C,IADO,EAEP,uEACE,qCAHK,EAIPT,QAJO,CAAT;AAMA,YAAMY,SAAS,GAAG,KAAKZ,QAAvB,CApBkB,CAqBlB;;AACA,UACEF,OAAO,KAAK,IAAZ,IACAA,OAAO,CAACG,GAAR,KAAgB,IADhB,IAEA,OAAOH,OAAO,CAACG,GAAf,KAAuB,UAFvB,IAGAH,OAAO,CAACG,GAAR,CAAYY,UAAZ,KAA2BD,SAJ7B,EAKE;AACA,eAAOd,OAAO,CAACG,GAAf;AACD;;AACD,YAAMA,GAAG,GAAG,UAAUa,KAAV,EAAiB;AAC3B,YAAIC,IAAI,GAAGN,IAAI,CAACM,IAAhB;;AACA,YAAIA,IAAI,KAAKxC,eAAb,EAA8B;AAC5B;AACAwC,UAAAA,IAAI,GAAGN,IAAI,CAACM,IAAL,GAAY,EAAnB;AACD;;AACD,YAAID,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAOC,IAAI,CAACH,SAAD,CAAX;AACD,SAFD,MAEO;AACLG,UAAAA,IAAI,CAACH,SAAD,CAAJ,GAAkBE,KAAlB;AACD;AACF,OAXD;;AAYAb,MAAAA,GAAG,CAACY,UAAJ,GAAiBD,SAAjB;AACA,aAAOX,GAAP;AACD,KA5CD,MA4CO;AACLnC,MAAAA,SAAS,CACP,OAAOkC,QAAP,KAAoB,QADb,EAEP,4FAFO,CAAT;AAIAlC,MAAAA,SAAS,CACPiC,OAAO,CAACI,MADD,EAEP,kGACE,2BADF,GAEE,sDAFF,GAGE,qGAHF,GAIE,+CAJF,GAKE,oEAPK,EAQPH,QARO,CAAT;AAUD;AACF;;AACD,SAAOA,QAAP;AACD;;AAED,SAASgB,wBAAT,CAAkCnB,WAAlC,EAAsDoB,QAAtD,EAAwE;AACtE,MAAIpB,WAAW,CAACU,IAAZ,KAAqB,UAAzB,EAAqC;AACnC,QAAIW,QAAQ,GAAG,EAAf;;AACA,QAAI/B,OAAJ,EAAa;AACX+B,MAAAA,QAAQ,GACN,oEACA,UADA,GAEA1C,yBAAyB,EAH3B;AAID;;AACDV,IAAAA,SAAS,CACP,KADO,EAEP,uDAFO,EAGPqD,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,QAA/B,MAA6C,iBAA7C,GACI,uBAAuBE,MAAM,CAACI,IAAP,CAAYN,QAAZ,EAAsBO,IAAtB,CAA2B,IAA3B,CAAvB,GAA0D,GAD9D,GAEIP,QALG,EAMPC,QANO,CAAT;AAQD;AACF;;AAED,SAASO,kBAAT,GAA8B;AAC5B,MAAItC,OAAJ,EAAa;AACX,UAAMI,yBAAyB,GAC7B,kEACA,+DADA,GAEA,iEAFA,GAGAf,yBAAyB,EAJ3B;;AAMA,QAAIQ,2BAA2B,CAACO,yBAAD,CAA/B,EAA4D;AAC1D;AACD;;AACDP,IAAAA,2BAA2B,CAACO,yBAAD,CAA3B,GAAyD,IAAzD;AAEAC,IAAAA,OAAO,CAACC,KAAR,CACE,kEACE,+DADF,GAEE,iEAHJ;AAKD;AACF,C,CAED;AACA;AACA;AACA;;;AACA,SAASiC,eAAT,CAAyBC,sBAAzB,EAAiD;AAC/C,WAASC,WAAT,CAAqB/B,WAArB,EAAyCgC,aAAzC,EAAqE;AACnE,QAAI,CAACF,sBAAL,EAA6B;AAC3B;AACA;AACD,KAJkE,CAKnE;AACA;AACA;AACA;AACA;;;AACA,UAAMG,IAAI,GAAGjC,WAAW,CAACkC,UAAzB;;AACA,QAAID,IAAI,KAAK,IAAb,EAAmB;AACjBA,MAAAA,IAAI,CAACE,UAAL,GAAkBH,aAAlB;AACAhC,MAAAA,WAAW,CAACkC,UAAZ,GAAyBF,aAAzB;AACD,KAHD,MAGO;AACLhC,MAAAA,WAAW,CAACoC,WAAZ,GAA0BpC,WAAW,CAACkC,UAAZ,GAAyBF,aAAnD;AACD;;AACDA,IAAAA,aAAa,CAACG,UAAd,GAA2B,IAA3B;AACAH,IAAAA,aAAa,CAACK,SAAd,GAA0BhF,QAA1B;AACD;;AAED,WAASiF,uBAAT,CACEtC,WADF,EAEEuC,iBAFF,EAGQ;AACN,QAAI,CAACT,sBAAL,EAA6B;AAC3B;AACA,aAAO,IAAP;AACD,KAJK,CAKN;AACA;;;AACA,QAAIE,aAAa,GAAGO,iBAApB;;AACA,WAAOP,aAAa,KAAK,IAAzB,EAA+B;AAC7BD,MAAAA,WAAW,CAAC/B,WAAD,EAAcgC,aAAd,CAAX;AACAA,MAAAA,aAAa,GAAGA,aAAa,CAACQ,OAA9B;AACD;;AACD,WAAO,IAAP;AACD;;AAED,WAASC,oBAAT,CACEzC,WADF,EAEEuC,iBAFF,EAG+B;AAC7B;AACA;AACA;AACA,UAAMG,gBAA6C,GAAG,IAAIC,GAAJ,EAAtD;AAEA,QAAIC,aAAa,GAAGL,iBAApB;;AACA,WAAOK,aAAa,KAAK,IAAzB,EAA+B;AAC7B,UAAIA,aAAa,CAACnD,GAAd,KAAsB,IAA1B,EAAgC;AAC9BiD,QAAAA,gBAAgB,CAACG,GAAjB,CAAqBD,aAAa,CAACnD,GAAnC,EAAwCmD,aAAxC;AACD,OAFD,MAEO;AACLF,QAAAA,gBAAgB,CAACG,GAAjB,CAAqBD,aAAa,CAACE,KAAnC,EAA0CF,aAA1C;AACD;;AACDA,MAAAA,aAAa,GAAGA,aAAa,CAACJ,OAA9B;AACD;;AACD,WAAOE,gBAAP;AACD;;AAED,WAASK,QAAT,CAAkBC,KAAlB,EAAgCC,YAAhC,EAA4D;AAC1D;AACA;AACA,UAAMC,KAAK,GAAG9E,oBAAoB,CAAC4E,KAAD,EAAQC,YAAR,CAAlC;AACAC,IAAAA,KAAK,CAACJ,KAAN,GAAc,CAAd;AACAI,IAAAA,KAAK,CAACV,OAAN,GAAgB,IAAhB;AACA,WAAOU,KAAP;AACD;;AAED,WAASC,UAAT,CACEC,QADF,EAEEC,eAFF,EAGEC,QAHF,EAIU;AACRF,IAAAA,QAAQ,CAACN,KAAT,GAAiBQ,QAAjB;;AACA,QAAI,CAACxB,sBAAL,EAA6B;AAC3B;AACA,aAAOuB,eAAP;AACD;;AACD,UAAMpD,OAAO,GAAGmD,QAAQ,CAACG,SAAzB;;AACA,QAAItD,OAAO,KAAK,IAAhB,EAAsB;AACpB,YAAMuD,QAAQ,GAAGvD,OAAO,CAAC6C,KAAzB;;AACA,UAAIU,QAAQ,GAAGH,eAAf,EAAgC;AAC9B;AACAD,QAAAA,QAAQ,CAACf,SAAT,GAAqBjF,SAArB;AACA,eAAOiG,eAAP;AACD,OAJD,MAIO;AACL;AACA,eAAOG,QAAP;AACD;AACF,KAVD,MAUO;AACL;AACAJ,MAAAA,QAAQ,CAACf,SAAT,GAAqBjF,SAArB;AACA,aAAOiG,eAAP;AACD;AACF;;AAED,WAASI,gBAAT,CAA0BL,QAA1B,EAAkD;AAChD;AACA;AACA;AACA,QAAItB,sBAAsB,IAAIsB,QAAQ,CAACG,SAAT,KAAuB,IAArD,EAA2D;AACzD;AACAH,MAAAA,QAAQ,CAACf,SAAT,GAAqBjF,SAArB;AACD;;AACD,WAAOgG,QAAP;AACD;;AAED,WAASM,cAAT,CACE1D,WADF,EAEEC,OAFF,EAGE0D,WAHF,EAIEC,cAJF,EAKE;AACA,QAAI3D,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACa,GAAR,KAAgBjD,QAAxC,EAAkD;AAChD;AACA,YAAMgG,OAAO,GAAGrF,mBAAmB,CACjCmF,WADiC,EAEjC3D,WAAW,CAACK,IAFqB,EAGjCuD,cAHiC,CAAnC;AAKAC,MAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,aAAO6D,OAAP;AACD,KATD,MASO;AACL;AACA,YAAME,QAAQ,GAAGhB,QAAQ,CAAC9C,OAAD,EAAU0D,WAAV,CAAzB;AACAI,MAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;AACA,aAAO+D,QAAP;AACD;AACF;;AAED,WAASC,aAAT,CACEhE,WADF,EAEEC,OAFF,EAGEC,OAHF,EAIE0D,cAJF,EAKS;AACP,QAAI3D,OAAO,KAAK,IAAhB,EAAsB;AACpB,UACEA,OAAO,CAACgE,WAAR,KAAwB/D,OAAO,CAACQ,IAAhC,MACA;AACCpB,MAAAA,OAAO,GAAGT,iCAAiC,CAACoB,OAAD,EAAUC,OAAV,CAApC,GAAyD,KAFjE,CADF,EAIE;AACA;AACA,cAAM6D,QAAQ,GAAGhB,QAAQ,CAAC9C,OAAD,EAAUC,OAAO,CAACgE,KAAlB,CAAzB;AACAH,QAAAA,QAAQ,CAAC3D,GAAT,GAAeL,SAAS,CAACC,WAAD,EAAcC,OAAd,EAAuBC,OAAvB,CAAxB;AACA6D,QAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;;AACA,YAAIV,OAAJ,EAAa;AACXyE,UAAAA,QAAQ,CAACI,YAAT,GAAwBjE,OAAO,CAACkE,OAAhC;AACAL,UAAAA,QAAQ,CAACM,WAAT,GAAuBnE,OAAO,CAACI,MAA/B;AACD;;AACD,eAAOyD,QAAP;AACD,OAdD,MAcO,IACL5F,eAAe,IACf8B,OAAO,CAACa,GAAR,KAAgB9C,KADhB,IAEAkC,OAAO,CAACQ,IAAR,CAAa4D,QAAb,KAA0B5G,gBAF1B,IAGAwC,OAAO,CAACQ,IAAR,CAAa6D,MAAb,KAAwBtE,OAAO,CAACS,IAAR,CAAa6D,MAJhC,EAKL;AACA;AACA,cAAMR,QAAQ,GAAGhB,QAAQ,CAAC9C,OAAD,EAAUC,OAAO,CAACgE,KAAlB,CAAzB;AACAH,QAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;AACA+D,QAAAA,QAAQ,CAACrD,IAAT,GAAgBR,OAAO,CAACQ,IAAxB;;AACA,YAAIpB,OAAJ,EAAa;AACXyE,UAAAA,QAAQ,CAACI,YAAT,GAAwBjE,OAAO,CAACkE,OAAhC;AACAL,UAAAA,QAAQ,CAACM,WAAT,GAAuBnE,OAAO,CAACI,MAA/B;AACD;;AACD,eAAOyD,QAAP;AACD;AACF,KAhCM,CAiCP;;;AACA,UAAMF,OAAO,GAAGvF,sBAAsB,CACpC4B,OADoC,EAEpCF,WAAW,CAACK,IAFwB,EAGpCuD,cAHoC,CAAtC,CAlCO,CAuCP;;AACAC,IAAAA,OAAO,CAACzD,GAAR,GAAcL,SAAS,CAACC,WAAD,EAAcC,OAAd,EAAuBC,OAAvB,CAAvB,CAxCO,CAyCP;;AACA2D,IAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB,CA1CO,CA2CP;;AACA,WAAO6D,OAAP;AACD;;AAED,WAASW,YAAT,CACExE,WADF,EAEEC,OAFF,EAGEwE,MAHF,EAIEb,cAJF,EAKS;AACP,QACE3D,OAAO,KAAK,IAAZ,IACAA,OAAO,CAACa,GAAR,KAAgBhD,UADhB,IAEAmC,OAAO,CAACO,SAAR,CAAkBkE,aAAlB,KAAoCD,MAAM,CAACC,aAF3C,IAGAzE,OAAO,CAACO,SAAR,CAAkBmE,cAAlB,KAAqCF,MAAM,CAACE,cAJ9C,EAKE;AACA;AACA,YAAMd,OAAO,GAAGpF,qBAAqB,CACnCgG,MADmC,EAEnCzE,WAAW,CAACK,IAFuB,EAGnCuD,cAHmC,CAArC;AAKAC,MAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,aAAO6D,OAAP;AACD,KAdD,MAcO;AACL;AACA,YAAME,QAAQ,GAAGhB,QAAQ,CAAC9C,OAAD,EAAUwE,MAAM,CAACG,QAAP,IAAmB,EAA7B,CAAzB;AACAb,MAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;AACA,aAAO+D,QAAP;AACD;AACF;;AAED,WAASc,cAAT,CACE7E,WADF,EAEEC,OAFF,EAGE6E,QAHF,EAIElB,cAJF,EAKEnE,GALF,EAMS;AACP,QAAIQ,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACa,GAAR,KAAgB/C,QAAxC,EAAkD;AAChD;AACA,YAAM8F,OAAO,GAAGtF,uBAAuB,CACrCuG,QADqC,EAErC9E,WAAW,CAACK,IAFyB,EAGrCuD,cAHqC,EAIrCnE,GAJqC,CAAvC;AAMAoE,MAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,aAAO6D,OAAP;AACD,KAVD,MAUO;AACL;AACA,YAAME,QAAQ,GAAGhB,QAAQ,CAAC9C,OAAD,EAAU6E,QAAV,CAAzB;AACAf,MAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;AACA,aAAO+D,QAAP;AACD;AACF;;AAED,WAASgB,WAAT,CACE/E,WADF,EAEEoB,QAFF,EAGEwC,cAHF,EAIgB;AACd,QAAI,OAAOxC,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAChE;AACA;AACA;AACA,YAAMyC,OAAO,GAAGrF,mBAAmB,CACjC,KAAK4C,QAD4B,EAEjCpB,WAAW,CAACK,IAFqB,EAGjCuD,cAHiC,CAAnC;AAKAC,MAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,aAAO6D,OAAP;AACD;;AAED,QAAI,OAAOzC,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,cAAQA,QAAQ,CAACkD,QAAjB;AACE,aAAK/G,kBAAL;AAAyB;AACvB,kBAAMsG,OAAO,GAAGvF,sBAAsB,CACpC8C,QADoC,EAEpCpB,WAAW,CAACK,IAFwB,EAGpCuD,cAHoC,CAAtC;AAKAC,YAAAA,OAAO,CAACzD,GAAR,GAAcL,SAAS,CAACC,WAAD,EAAc,IAAd,EAAoBoB,QAApB,CAAvB;AACAyC,YAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,mBAAO6D,OAAP;AACD;;AACD,aAAKpG,iBAAL;AAAwB;AACtB,kBAAMoG,OAAO,GAAGpF,qBAAqB,CACnC2C,QADmC,EAEnCpB,WAAW,CAACK,IAFuB,EAGnCuD,cAHmC,CAArC;AAKAC,YAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,mBAAO6D,OAAP;AACD;AAnBH;;AAsBA,UAAIhE,OAAO,CAACuB,QAAD,CAAP,IAAqB9D,aAAa,CAAC8D,QAAD,CAAtC,EAAkD;AAChD,cAAMyC,OAAO,GAAGtF,uBAAuB,CACrC6C,QADqC,EAErCpB,WAAW,CAACK,IAFyB,EAGrCuD,cAHqC,EAIrC,IAJqC,CAAvC;AAMAC,QAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,eAAO6D,OAAP;AACD;;AAED1C,MAAAA,wBAAwB,CAACnB,WAAD,EAAcoB,QAAd,CAAxB;AACD;;AAED,QAAI9B,OAAJ,EAAa;AACX,UAAI,OAAO8B,QAAP,KAAoB,UAAxB,EAAoC;AAClCQ,QAAAA,kBAAkB;AACnB;AACF;;AAED,WAAO,IAAP;AACD;;AAED,WAASoD,UAAT,CACEhF,WADF,EAEEiF,QAFF,EAGE7D,QAHF,EAIEwC,cAJF,EAKgB;AACd;AAEA,UAAMnE,GAAG,GAAGwF,QAAQ,KAAK,IAAb,GAAoBA,QAAQ,CAACxF,GAA7B,GAAmC,IAA/C;;AAEA,QAAI,OAAO2B,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAChE;AACA;AACA;AACA,UAAI3B,GAAG,KAAK,IAAZ,EAAkB;AAChB,eAAO,IAAP;AACD;;AACD,aAAOiE,cAAc,CACnB1D,WADmB,EAEnBiF,QAFmB,EAGnB,KAAK7D,QAHc,EAInBwC,cAJmB,CAArB;AAMD;;AAED,QAAI,OAAOxC,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,cAAQA,QAAQ,CAACkD,QAAjB;AACE,aAAK/G,kBAAL;AAAyB;AACvB,gBAAI6D,QAAQ,CAAC3B,GAAT,KAAiBA,GAArB,EAA0B;AACxB,kBAAI2B,QAAQ,CAACV,IAAT,KAAkBlD,mBAAtB,EAA2C;AACzC,uBAAOqH,cAAc,CACnB7E,WADmB,EAEnBiF,QAFmB,EAGnB7D,QAAQ,CAAC8C,KAAT,CAAeU,QAHI,EAInBhB,cAJmB,EAKnBnE,GALmB,CAArB;AAOD;;AACD,qBAAOuE,aAAa,CAClBhE,WADkB,EAElBiF,QAFkB,EAGlB7D,QAHkB,EAIlBwC,cAJkB,CAApB;AAMD,aAhBD,MAgBO;AACL,qBAAO,IAAP;AACD;AACF;;AACD,aAAKnG,iBAAL;AAAwB;AACtB,gBAAI2D,QAAQ,CAAC3B,GAAT,KAAiBA,GAArB,EAA0B;AACxB,qBAAO+E,YAAY,CACjBxE,WADiB,EAEjBiF,QAFiB,EAGjB7D,QAHiB,EAIjBwC,cAJiB,CAAnB;AAMD,aAPD,MAOO;AACL,qBAAO,IAAP;AACD;AACF;AAjCH;;AAoCA,UAAI/D,OAAO,CAACuB,QAAD,CAAP,IAAqB9D,aAAa,CAAC8D,QAAD,CAAtC,EAAkD;AAChD,YAAI3B,GAAG,KAAK,IAAZ,EAAkB;AAChB,iBAAO,IAAP;AACD;;AAED,eAAOoF,cAAc,CACnB7E,WADmB,EAEnBiF,QAFmB,EAGnB7D,QAHmB,EAInBwC,cAJmB,EAKnB,IALmB,CAArB;AAOD;;AAEDzC,MAAAA,wBAAwB,CAACnB,WAAD,EAAcoB,QAAd,CAAxB;AACD;;AAED,QAAI9B,OAAJ,EAAa;AACX,UAAI,OAAO8B,QAAP,KAAoB,UAAxB,EAAoC;AAClCQ,QAAAA,kBAAkB;AACnB;AACF;;AAED,WAAO,IAAP;AACD;;AAED,WAASsD,aAAT,CACExC,gBADF,EAEE1C,WAFF,EAGEmF,MAHF,EAIE/D,QAJF,EAKEwC,cALF,EAMgB;AACd,QAAI,OAAOxC,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAChE;AACA;AACA,YAAMgE,YAAY,GAAG1C,gBAAgB,CAAC2C,GAAjB,CAAqBF,MAArB,KAAgC,IAArD;AACA,aAAOzB,cAAc,CACnB1D,WADmB,EAEnBoF,YAFmB,EAGnB,KAAKhE,QAHc,EAInBwC,cAJmB,CAArB;AAMD;;AAED,QAAI,OAAOxC,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAAjD,EAAuD;AACrD,cAAQA,QAAQ,CAACkD,QAAjB;AACE,aAAK/G,kBAAL;AAAyB;AACvB,kBAAM6H,YAAY,GAChB1C,gBAAgB,CAAC2C,GAAjB,CACEjE,QAAQ,CAAC3B,GAAT,KAAiB,IAAjB,GAAwB0F,MAAxB,GAAiC/D,QAAQ,CAAC3B,GAD5C,KAEK,IAHP;;AAIA,gBAAI2B,QAAQ,CAACV,IAAT,KAAkBlD,mBAAtB,EAA2C;AACzC,qBAAOqH,cAAc,CACnB7E,WADmB,EAEnBoF,YAFmB,EAGnBhE,QAAQ,CAAC8C,KAAT,CAAeU,QAHI,EAInBhB,cAJmB,EAKnBxC,QAAQ,CAAC3B,GALU,CAArB;AAOD;;AACD,mBAAOuE,aAAa,CAClBhE,WADkB,EAElBoF,YAFkB,EAGlBhE,QAHkB,EAIlBwC,cAJkB,CAApB;AAMD;;AACD,aAAKnG,iBAAL;AAAwB;AACtB,kBAAM2H,YAAY,GAChB1C,gBAAgB,CAAC2C,GAAjB,CACEjE,QAAQ,CAAC3B,GAAT,KAAiB,IAAjB,GAAwB0F,MAAxB,GAAiC/D,QAAQ,CAAC3B,GAD5C,KAEK,IAHP;AAIA,mBAAO+E,YAAY,CACjBxE,WADiB,EAEjBoF,YAFiB,EAGjBhE,QAHiB,EAIjBwC,cAJiB,CAAnB;AAMD;AAjCH;;AAoCA,UAAI/D,OAAO,CAACuB,QAAD,CAAP,IAAqB9D,aAAa,CAAC8D,QAAD,CAAtC,EAAkD;AAChD,cAAMgE,YAAY,GAAG1C,gBAAgB,CAAC2C,GAAjB,CAAqBF,MAArB,KAAgC,IAArD;AACA,eAAON,cAAc,CACnB7E,WADmB,EAEnBoF,YAFmB,EAGnBhE,QAHmB,EAInBwC,cAJmB,EAKnB,IALmB,CAArB;AAOD;;AAEDzC,MAAAA,wBAAwB,CAACnB,WAAD,EAAcoB,QAAd,CAAxB;AACD;;AAED,QAAI9B,OAAJ,EAAa;AACX,UAAI,OAAO8B,QAAP,KAAoB,UAAxB,EAAoC;AAClCQ,QAAAA,kBAAkB;AACnB;AACF;;AAED,WAAO,IAAP;AACD;AAED;;;;;AAGA,WAAS0D,gBAAT,CACEjG,KADF,EAEEkG,SAFF,EAGsB;AACpB,QAAIjG,OAAJ,EAAa;AACX,UAAI,OAAOD,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC/C,eAAOkG,SAAP;AACD;;AACD,cAAQlG,KAAK,CAACiF,QAAd;AACE,aAAK/G,kBAAL;AACA,aAAKE,iBAAL;AACE2B,UAAAA,iBAAiB,CAACC,KAAD,CAAjB;AACA,gBAAMI,GAAG,GAAGJ,KAAK,CAACI,GAAlB;;AACA,cAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B;AACD;;AACD,cAAI8F,SAAS,KAAK,IAAlB,EAAwB;AACtBA,YAAAA,SAAS,GAAG,IAAIC,GAAJ,EAAZ;AACAD,YAAAA,SAAS,CAACE,GAAV,CAAchG,GAAd;AACA;AACD;;AACD,cAAI,CAAC8F,SAAS,CAACG,GAAV,CAAcjG,GAAd,CAAL,EAAyB;AACvB8F,YAAAA,SAAS,CAACE,GAAV,CAAchG,GAAd;AACA;AACD;;AACDE,UAAAA,OAAO,CAACC,KAAR,CACE,uDACE,mEADF,GAEE,2DAFF,GAGE,8DAHF,GAIE,mCALJ,EAMEH,GANF;AAQA;;AACF;AACE;AA3BJ;AA6BD;;AACD,WAAO8F,SAAP;AACD,GA9f8C,CA+f/C;;;AACA,WAASI,sBAAT,EACE;AACA3F,EAAAA,WAFF,EAGEuC,iBAHF,EAIE;AACAqD,EAAAA,WALF,EAMEhC,cANF,EAOgB;AACd,QAAItE,OAAJ,EAAa;AACX;AACA,UAAIiG,SAAS,GAAG,IAAhB;;AACA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAAW,CAACE,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,cAAMxG,KAAK,GAAGuG,WAAW,CAACC,CAAD,CAAzB;AACAN,QAAAA,SAAS,GAAGD,gBAAgB,CAACjG,KAAD,EAAQkG,SAAR,CAA5B;AACD;AACF;AACD;;;;;;;AAKA,QAAIQ,mBAAiC,GAAG,IAAxC,CAdc,CAed;;AACA,QAAIC,gBAA8B,GAAG,IAArC,CAhBc,CAiBd;;AACA,QAAIf,QAAQ,GAAG1C,iBAAf;AAEA,QAAIc,eAAe,GAAG,CAAtB;AACA,QAAI8B,MAAM,GAAG,CAAb;AACA,QAAIc,YAAY,GAAG,IAAnB,CAtBc,CAuBd;;AACA,WAAOhB,QAAQ,KAAK,IAAb,IAAqBE,MAAM,GAAGS,WAAW,CAACE,MAAjD,EAAyDX,MAAM,EAA/D,EAAmE;AACjE,UAAIF,QAAQ,CAACnC,KAAT,GAAiBqC,MAArB,EAA6B;AAC3Bc,QAAAA,YAAY,GAAGhB,QAAf;AACAA,QAAAA,QAAQ,GAAG,IAAX;AACD,OAHD,MAGO;AACLgB,QAAAA,YAAY,GAAGhB,QAAQ,CAACzC,OAAxB;AACD;;AACD,YAAMY,QAAQ,GAAG4B,UAAU,CACzBhF,WADyB,EAEzBiF,QAFyB,EAGzBW,WAAW,CAACT,MAAD,CAHc,EAIzBvB,cAJyB,CAA3B;;AAMA,UAAIR,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA;AACA;AACA,YAAI6B,QAAQ,KAAK,IAAjB,EAAuB;AACrBA,UAAAA,QAAQ,GAAGgB,YAAX;AACD;;AACD;AACD;;AACD,UAAInE,sBAAJ,EAA4B;AAC1B,YAAImD,QAAQ,IAAI7B,QAAQ,CAACG,SAAT,KAAuB,IAAvC,EAA6C;AAC3C;AACA;AACAxB,UAAAA,WAAW,CAAC/B,WAAD,EAAciF,QAAd,CAAX;AACD;AACF;;AACD5B,MAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4B8B,MAA5B,CAA5B;;AACA,UAAIa,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B;AACAD,QAAAA,mBAAmB,GAAG3C,QAAtB;AACD,OAHD,MAGO;AACL;AACA;AACA;AACA;AACA4C,QAAAA,gBAAgB,CAACxD,OAAjB,GAA2BY,QAA3B;AACD;;AACD4C,MAAAA,gBAAgB,GAAG5C,QAAnB;AACA6B,MAAAA,QAAQ,GAAGgB,YAAX;AACD,KAnEa,CAoEd;;;AACA,QAAId,MAAM,KAAKS,WAAW,CAACE,MAA3B,EAAmC;AACjC;AACAxD,MAAAA,uBAAuB,CAACtC,WAAD,EAAciF,QAAd,CAAvB;AACA,aAAOc,mBAAP;AACD,KAzEa,CA2Ed;;;AACA,QAAId,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA,aAAOE,MAAM,GAAGS,WAAW,CAACE,MAA5B,EAAoCX,MAAM,EAA1C,EAA8C;AAC5C;AACA,cAAM/B,QAAQ,GAAG2B,WAAW,CAC1B/E,WAD0B,EAE1B4F,WAAW,CAACT,MAAD,CAFe,EAG1BvB,cAH0B,CAA5B,CAF4C,CAO5C;;AACA,YAAIR,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACD,SAX2C,CAY5C;AACA;;;AACAC,QAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4B8B,MAA5B,CAA5B,CAd4C,CAe5C;;AACA,YAAIa,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B;AACAD,UAAAA,mBAAmB,GAAG3C,QAAtB;AACD,SAHD,MAGO;AACL;AACA4C,UAAAA,gBAAgB,CAACxD,OAAjB,GAA2BY,QAA3B;AACD,SAtB2C,CAuB5C;;;AACA4C,QAAAA,gBAAgB,GAAG5C,QAAnB;AACD,OA3BoB,CA4BrB;AACA;;;AACA,aAAO2C,mBAAP;AACD,KA3Ga,CA4Gd;AACA;;;AACA,UAAMrD,gBAAgB,GAAGD,oBAAoB,CAACzC,WAAD,EAAciF,QAAd,CAA7C,CA9Gc,CAgHd;;AACA,WAAOE,MAAM,GAAGS,WAAW,CAACE,MAA5B,EAAoCX,MAAM,EAA1C,EAA8C;AAC5C,YAAM/B,QAAQ,GAAG8B,aAAa,CAC5BxC,gBAD4B,EAE5B1C,WAF4B,EAG5BmF,MAH4B,EAI5BS,WAAW,CAACT,MAAD,CAJiB,EAK5BvB,cAL4B,CAA9B;;AAOA,UAAIR,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAItB,sBAAJ,EAA4B;AAC1B,cAAIsB,QAAQ,CAACG,SAAT,KAAuB,IAA3B,EAAiC;AAC/B;AACA;AACA;AACA;AACAb,YAAAA,gBAAgB,CAACwD,MAAjB,CACE9C,QAAQ,CAAC3D,GAAT,KAAiB,IAAjB,GAAwB0F,MAAxB,GAAiC/B,QAAQ,CAAC3D,GAD5C;AAGD;AACF;;AACD4D,QAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4B8B,MAA5B,CAA5B;;AACA,YAAIa,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BD,UAAAA,mBAAmB,GAAG3C,QAAtB;AACD,SAFD,MAEO;AACL4C,UAAAA,gBAAgB,CAACxD,OAAjB,GAA2BY,QAA3B;AACD;;AACD4C,QAAAA,gBAAgB,GAAG5C,QAAnB;AACD;AACF,KA7Ia,CA8Id;;;AACA,QAAItB,sBAAJ,EAA4B;AAC1B;AACA;AACAY,MAAAA,gBAAgB,CAACyD,OAAjB,CAA0B9G,KAAD,IAAW0C,WAAW,CAAC/B,WAAD,EAAcX,KAAd,CAA/C;AACD,KAnJa,CAoJd;;;AACA,WAAO0G,mBAAP;AACD;;AAED,WAASK,yBAAT,CACEpG,WADF,EAEEuC,iBAFF,EAGE8D,mBAHF,EAIEzC,cAJF,EAKgB;AACd;AACA;AAEA,UAAM0C,UAAU,GAAGhJ,aAAa,CAAC+I,mBAAD,CAAhC;AACApI,IAAAA,SAAS,CACP,OAAOqI,UAAP,KAAsB,UADf,EAEP,2EACE,8BAHK,CAAT;;AAMA,QAAIhH,OAAJ,EAAa;AACX;AACA;AACA,UACE,OAAOiH,MAAP,KAAkB,UAAlB,IACA;AACAF,MAAAA,mBAAmB,CAACE,MAAM,CAACC,WAAR,CAAnB,KAA4C,WAH9C,EAIE;AACA,YAAI,CAACxH,sBAAL,EAA6B;AAC3BW,UAAAA,OAAO,CAACC,KAAR,CACE,uEACE,iEADF,GAEE,4DAFF,GAGE,wDAHF,GAIE,+DALJ;AAOD;;AACDZ,QAAAA,sBAAsB,GAAG,IAAzB;AACD,OAlBU,CAoBX;;;AACA,UAAKqH,mBAAD,CAA2BI,OAA3B,KAAuCH,UAA3C,EAAuD;AACrD,YAAI,CAACvH,gBAAL,EAAuB;AACrBY,UAAAA,OAAO,CAACC,KAAR,CACE,iEACE,iEADF,GAEE,wBAHJ;AAKD;;AACDb,QAAAA,gBAAgB,GAAG,IAAnB;AACD,OA9BU,CAgCX;AACA;;;AACA,YAAM6G,WAAW,GAAGU,UAAU,CAAC7E,IAAX,CAAgB4E,mBAAhB,CAApB;;AACA,UAAIT,WAAJ,EAAiB;AACf,YAAIL,SAAS,GAAG,IAAhB;AACA,YAAImB,IAAI,GAAGd,WAAW,CAACe,IAAZ,EAAX;;AACA,eAAO,CAACD,IAAI,CAACE,IAAb,EAAmBF,IAAI,GAAGd,WAAW,CAACe,IAAZ,EAA1B,EAA8C;AAC5C,gBAAMtH,KAAK,GAAGqH,IAAI,CAACzF,KAAnB;AACAsE,UAAAA,SAAS,GAAGD,gBAAgB,CAACjG,KAAD,EAAQkG,SAAR,CAA5B;AACD;AACF;AACF;;AAED,UAAMK,WAAW,GAAGU,UAAU,CAAC7E,IAAX,CAAgB4E,mBAAhB,CAApB;AACApI,IAAAA,SAAS,CAAC2H,WAAW,IAAI,IAAhB,EAAsB,0CAAtB,CAAT;AAEA,QAAIG,mBAAiC,GAAG,IAAxC;AACA,QAAIC,gBAA8B,GAAG,IAArC;AAEA,QAAIf,QAAQ,GAAG1C,iBAAf;AACA,QAAIc,eAAe,GAAG,CAAtB;AACA,QAAI8B,MAAM,GAAG,CAAb;AACA,QAAIc,YAAY,GAAG,IAAnB;AAEA,QAAIS,IAAI,GAAGd,WAAW,CAACe,IAAZ,EAAX;;AACA,WAEE1B,QAAQ,KAAK,IAAb,IAAqB,CAACyB,IAAI,CAACE,IAF7B,EAGEzB,MAAM,IAAIuB,IAAI,GAAGd,WAAW,CAACe,IAAZ,EAHnB,EAIE;AACA,UAAI1B,QAAQ,CAACnC,KAAT,GAAiBqC,MAArB,EAA6B;AAC3Bc,QAAAA,YAAY,GAAGhB,QAAf;AACAA,QAAAA,QAAQ,GAAG,IAAX;AACD,OAHD,MAGO;AACLgB,QAAAA,YAAY,GAAGhB,QAAQ,CAACzC,OAAxB;AACD;;AACD,YAAMY,QAAQ,GAAG4B,UAAU,CACzBhF,WADyB,EAEzBiF,QAFyB,EAGzByB,IAAI,CAACzF,KAHoB,EAIzB2C,cAJyB,CAA3B;;AAMA,UAAIR,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA;AACA;AACA,YAAI6B,QAAQ,KAAK,IAAjB,EAAuB;AACrBA,UAAAA,QAAQ,GAAGgB,YAAX;AACD;;AACD;AACD;;AACD,UAAInE,sBAAJ,EAA4B;AAC1B,YAAImD,QAAQ,IAAI7B,QAAQ,CAACG,SAAT,KAAuB,IAAvC,EAA6C;AAC3C;AACA;AACAxB,UAAAA,WAAW,CAAC/B,WAAD,EAAciF,QAAd,CAAX;AACD;AACF;;AACD5B,MAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4B8B,MAA5B,CAA5B;;AACA,UAAIa,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B;AACAD,QAAAA,mBAAmB,GAAG3C,QAAtB;AACD,OAHD,MAGO;AACL;AACA;AACA;AACA;AACA4C,QAAAA,gBAAgB,CAACxD,OAAjB,GAA2BY,QAA3B;AACD;;AACD4C,MAAAA,gBAAgB,GAAG5C,QAAnB;AACA6B,MAAAA,QAAQ,GAAGgB,YAAX;AACD;;AAED,QAAIS,IAAI,CAACE,IAAT,EAAe;AACb;AACAtE,MAAAA,uBAAuB,CAACtC,WAAD,EAAciF,QAAd,CAAvB;AACA,aAAOc,mBAAP;AACD;;AAED,QAAId,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA,aAAO,CAACyB,IAAI,CAACE,IAAb,EAAmBzB,MAAM,IAAIuB,IAAI,GAAGd,WAAW,CAACe,IAAZ,EAApC,EAAwD;AACtD,cAAMvD,QAAQ,GAAG2B,WAAW,CAAC/E,WAAD,EAAc0G,IAAI,CAACzF,KAAnB,EAA0B2C,cAA1B,CAA5B;;AACA,YAAIR,QAAQ,KAAK,IAAjB,EAAuB;AACrB;AACD;;AACDC,QAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4B8B,MAA5B,CAA5B;;AACA,YAAIa,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B;AACAD,UAAAA,mBAAmB,GAAG3C,QAAtB;AACD,SAHD,MAGO;AACL4C,UAAAA,gBAAgB,CAACxD,OAAjB,GAA2BY,QAA3B;AACD;;AACD4C,QAAAA,gBAAgB,GAAG5C,QAAnB;AACD;;AACD,aAAO2C,mBAAP;AACD,KA7Ia,CA+Id;;;AACA,UAAMrD,gBAAgB,GAAGD,oBAAoB,CAACzC,WAAD,EAAciF,QAAd,CAA7C,CAhJc,CAkJd;;AACA,WAAO,CAACyB,IAAI,CAACE,IAAb,EAAmBzB,MAAM,IAAIuB,IAAI,GAAGd,WAAW,CAACe,IAAZ,EAApC,EAAwD;AACtD,YAAMvD,QAAQ,GAAG8B,aAAa,CAC5BxC,gBAD4B,EAE5B1C,WAF4B,EAG5BmF,MAH4B,EAI5BuB,IAAI,CAACzF,KAJuB,EAK5B2C,cAL4B,CAA9B;;AAOA,UAAIR,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAItB,sBAAJ,EAA4B;AAC1B,cAAIsB,QAAQ,CAACG,SAAT,KAAuB,IAA3B,EAAiC;AAC/B;AACA;AACA;AACA;AACAb,YAAAA,gBAAgB,CAACwD,MAAjB,CACE9C,QAAQ,CAAC3D,GAAT,KAAiB,IAAjB,GAAwB0F,MAAxB,GAAiC/B,QAAQ,CAAC3D,GAD5C;AAGD;AACF;;AACD4D,QAAAA,eAAe,GAAGF,UAAU,CAACC,QAAD,EAAWC,eAAX,EAA4B8B,MAA5B,CAA5B;;AACA,YAAIa,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BD,UAAAA,mBAAmB,GAAG3C,QAAtB;AACD,SAFD,MAEO;AACL4C,UAAAA,gBAAgB,CAACxD,OAAjB,GAA2BY,QAA3B;AACD;;AACD4C,QAAAA,gBAAgB,GAAG5C,QAAnB;AACD;AACF;;AAED,QAAItB,sBAAJ,EAA4B;AAC1B;AACA;AACAY,MAAAA,gBAAgB,CAACyD,OAAjB,CAA0B9G,KAAD,IAAW0C,WAAW,CAAC/B,WAAD,EAAcX,KAAd,CAA/C;AACD;;AAED,WAAO0G,mBAAP;AACD,GA51B8C,CA81B/C;;;AACA,WAASc,uBAAT,CACE7G,WADF,EAEEuC,iBAFF,EAGEoB,WAHF,EAIEC,cAJF,EAKS;AACP;AACA,QAAIrB,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,CAACzB,GAAlB,KAA0BjD,QAA5D,EAAsE;AACpE;AACA;AACAyE,MAAAA,uBAAuB,CAACtC,WAAD,EAAcuC,iBAAiB,CAACC,OAAhC,CAAvB;AACA,YAAMuB,QAAQ,GAAGhB,QAAQ,CAACR,iBAAD,EAAoBoB,WAApB,CAAzB;AACAI,MAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;AACA,aAAO+D,QAAP;AACD,KATM,CAUP;AACA;;;AACAzB,IAAAA,uBAAuB,CAACtC,WAAD,EAAcuC,iBAAd,CAAvB,CAZO,CAaP;;AACA,UAAMsB,OAAO,GAAGrF,mBAAmB,CACjCmF,WADiC,EAEjC3D,WAAW,CAACK,IAFqB,EAGjCuD,cAHiC,CAAnC,CAdO,CAmBP;;AACAC,IAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB,CApBO,CAqBP;;AACA,WAAO6D,OAAP;AACD,GA33B8C,CA43B/C;;;AACA,WAASiD,sBAAT,EACE;AACA9G,EAAAA,WAFF,EAGE;AACAuC,EAAAA,iBAJF,EAKE;AACArC,EAAAA,OANF,EAOE0D,cAPF,EAQS;AACP,UAAMnE,GAAG,GAAGS,OAAO,CAACT,GAApB;AACA,QAAIJ,KAAK,GAAGkD,iBAAZ,CAFO,CAGP;AACA;;AACA,WAAOlD,KAAK,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA,UAAIA,KAAK,CAACI,GAAN,KAAcA,GAAlB,EAAuB;AACrB,gBAAQJ,KAAK,CAACyB,GAAd;AACE,eAAK/C,QAAL;AAAe;AACb,kBAAImC,OAAO,CAACQ,IAAR,KAAiBlD,mBAArB,EAA0C;AACxC8E,gBAAAA,uBAAuB,CAACtC,WAAD,EAAcX,KAAK,CAACmD,OAApB,CAAvB;AACA,sBAAMuB,QAAQ,GAAGhB,QAAQ,CAAC1D,KAAD,EAAQa,OAAO,CAACgE,KAAR,CAAcU,QAAtB,CAAzB;AACAb,gBAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;;AACA,oBAAIV,OAAJ,EAAa;AACXyE,kBAAAA,QAAQ,CAACI,YAAT,GAAwBjE,OAAO,CAACkE,OAAhC;AACAL,kBAAAA,QAAQ,CAACM,WAAT,GAAuBnE,OAAO,CAACI,MAA/B;AACD;;AACD,uBAAOyD,QAAP;AACD;;AACD;AACD;;AACD,eAAK/F,KAAL;AACE,gBAAIG,eAAJ,EAAqB;AACnB,kBACE+B,OAAO,CAACQ,IAAR,CAAa4D,QAAb,KAA0B5G,gBAA1B,IACAwC,OAAO,CAACQ,IAAR,CAAa6D,MAAb,KAAwBlF,KAAK,CAACqB,IAAN,CAAW6D,MAFrC,EAGE;AACAjC,gBAAAA,uBAAuB,CAACtC,WAAD,EAAcX,KAAK,CAACmD,OAApB,CAAvB;AACA,sBAAMuB,QAAQ,GAAGhB,QAAQ,CAAC1D,KAAD,EAAQa,OAAO,CAACgE,KAAhB,CAAzB;AACAH,gBAAAA,QAAQ,CAACrD,IAAT,GAAgBR,OAAO,CAACQ,IAAxB;AACAqD,gBAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;;AACA,oBAAIV,OAAJ,EAAa;AACXyE,kBAAAA,QAAQ,CAACI,YAAT,GAAwBjE,OAAO,CAACkE,OAAhC;AACAL,kBAAAA,QAAQ,CAACM,WAAT,GAAuBnE,OAAO,CAACI,MAA/B;AACD;;AACD,uBAAOyD,QAAP;AACD;AACF;;AACH;AACA;;AACA;AAAS;AACP,kBACE1E,KAAK,CAAC4E,WAAN,KAAsB/D,OAAO,CAACQ,IAA9B,MACA;AACCpB,cAAAA,OAAO,GACJT,iCAAiC,CAACQ,KAAD,EAAQa,OAAR,CAD7B,GAEJ,KAJJ,CADF,EAME;AACAoC,gBAAAA,uBAAuB,CAACtC,WAAD,EAAcX,KAAK,CAACmD,OAApB,CAAvB;AACA,sBAAMuB,QAAQ,GAAGhB,QAAQ,CAAC1D,KAAD,EAAQa,OAAO,CAACgE,KAAhB,CAAzB;AACAH,gBAAAA,QAAQ,CAAC3D,GAAT,GAAeL,SAAS,CAACC,WAAD,EAAcX,KAAd,EAAqBa,OAArB,CAAxB;AACA6D,gBAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;;AACA,oBAAIV,OAAJ,EAAa;AACXyE,kBAAAA,QAAQ,CAACI,YAAT,GAAwBjE,OAAO,CAACkE,OAAhC;AACAL,kBAAAA,QAAQ,CAACM,WAAT,GAAuBnE,OAAO,CAACI,MAA/B;AACD;;AACD,uBAAOyD,QAAP;AACD;;AACD;AACD;AApDH,SADqB,CAuDrB;;;AACAzB,QAAAA,uBAAuB,CAACtC,WAAD,EAAcX,KAAd,CAAvB;AACA;AACD,OA1DD,MA0DO;AACL0C,QAAAA,WAAW,CAAC/B,WAAD,EAAcX,KAAd,CAAX;AACD;;AACDA,MAAAA,KAAK,GAAGA,KAAK,CAACmD,OAAd;AACD,KAtEM,CAuEP;AACA;;;AACA,QAAItC,OAAO,CAACQ,IAAR,KAAiBlD,mBAArB,EAA0C;AACxC,YAAMqG,OAAO,GAAGtF,uBAAuB,CACrC2B,OAAO,CAACgE,KAAR,CAAcU,QADuB,EAErC5E,WAAW,CAACK,IAFyB,EAGrCuD,cAHqC,EAIrC1D,OAAO,CAACT,GAJ6B,CAAvC;AAMAoE,MAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,aAAO6D,OAAP;AACD,KATD,MASO;AACL;AACA;AACA,YAAMA,OAAO,GAAGvF,sBAAsB,CACpC4B,OADoC,EAEpC;AACA;AACA;AACA;AACAF,MAAAA,WAAW,CAACK,IANwB,EAOpCuD,cAPoC,CAAtC,CAHK,CAYL;;AACAC,MAAAA,OAAO,CAACzD,GAAR,GAAcL,SAAS,CAACC,WAAD,EAAcuC,iBAAd,EAAiCrC,OAAjC,CAAvB,CAbK,CAcL;;AACA2D,MAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB,CAfK,CAgBL;;AACA,aAAO6D,OAAP;AACD;AACF;;AAED,WAASkD,qBAAT,CACE/G,WADF,EAEEuC,iBAFF,EAGEkC,MAHF,EAIEb,cAJF,EAKS;AACP,UAAMnE,GAAG,GAAGgF,MAAM,CAAChF,GAAnB;AACA,QAAIJ,KAAK,GAAGkD,iBAAZ;;AACA,WAAOlD,KAAK,KAAK,IAAjB,EAAuB;AACrB;AACA;AACA,UAAIA,KAAK,CAACI,GAAN,KAAcA,GAAlB,EAAuB;AACrB,YACEJ,KAAK,CAACyB,GAAN,KAAchD,UAAd,IACAuB,KAAK,CAACmB,SAAN,CAAgBkE,aAAhB,KAAkCD,MAAM,CAACC,aADzC,IAEArF,KAAK,CAACmB,SAAN,CAAgBmE,cAAhB,KAAmCF,MAAM,CAACE,cAH5C,EAIE;AACArC,UAAAA,uBAAuB,CAACtC,WAAD,EAAcX,KAAK,CAACmD,OAApB,CAAvB;AACA,gBAAMuB,QAAQ,GAAGhB,QAAQ,CAAC1D,KAAD,EAAQoF,MAAM,CAACG,QAAP,IAAmB,EAA3B,CAAzB;AACAb,UAAAA,QAAQ,CAACD,MAAT,GAAkB9D,WAAlB;AACA,iBAAO+D,QAAP;AACD,SATD,MASO;AACLzB,UAAAA,uBAAuB,CAACtC,WAAD,EAAcX,KAAd,CAAvB;AACA;AACD;AACF,OAdD,MAcO;AACL0C,QAAAA,WAAW,CAAC/B,WAAD,EAAcX,KAAd,CAAX;AACD;;AACDA,MAAAA,KAAK,GAAGA,KAAK,CAACmD,OAAd;AACD;;AAED,UAAMqB,OAAO,GAAGpF,qBAAqB,CACnCgG,MADmC,EAEnCzE,WAAW,CAACK,IAFuB,EAGnCuD,cAHmC,CAArC;AAKAC,IAAAA,OAAO,CAACC,MAAR,GAAiB9D,WAAjB;AACA,WAAO6D,OAAP;AACD,GAlhC8C,CAohC/C;AACA;AACA;;;AACA,WAASmD,oBAAT,EACE;AACAhH,EAAAA,WAFF,EAGE;AACAuC,EAAAA,iBAJF,EAKE;AACAnB,EAAAA,QANF,EAOE;AACAwC,EAAAA,cARF,EASgB;AACd;AAEA;AACA;AACA,UAAMqD,yBAAyB,GAC7B,OAAO7F,QAAP,KAAoB,QAApB,IACAA,QAAQ,KAAK,IADb,IAEAA,QAAQ,CAACV,IAAT,KAAkBlD,mBAFlB,IAGA4D,QAAQ,CAAC3B,GAAT,KAAiB,IAJnB,CALc,CAWd;;AACA,QAAIwH,yBAAJ,EAA+B;AAC7B7F,MAAAA,QAAQ,GAAGA,QAAQ,CAAC8C,KAAT,CAAeU,QAA1B;AACD,KAda,CAgBd;;;AACA,UAAMsC,QAAQ,GAAG,OAAO9F,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAA9D,CAjBc,CAmBd;;AACA,QAAI8F,QAAJ,EAAc;AACZ;AACA,cAAQ9F,QAAQ,CAACkD,QAAjB;AACE;AACA,aAAK/G,kBAAL;AACE;AACA;AACA,iBAAOkG,gBAAgB,EACrB;AACA;AACAqD,UAAAA,sBAAsB,CACpB9G,WADoB,EAEpBuC,iBAFoB,EAGpBnB,QAHoB,EAIpBwC,cAJoB,CAHD,CAAvB;;AAUF,aAAKnG,iBAAL;AACE,iBAAOgG,gBAAgB,CACrBsD,qBAAqB,CACnB/G,WADmB,EAEnBuC,iBAFmB,EAGnBnB,QAHmB,EAInBwC,cAJmB,CADA,CAAvB;AAhBJ;AAyBD,KA/Ca,CAgDd;;;AACA,QAAI,OAAOxC,QAAP,KAAoB,QAApB,IAAgC,OAAOA,QAAP,KAAoB,QAAxD,EAAkE;AAChE,aAAOqC,gBAAgB,CACrBoD,uBAAuB,CACrB7G,WADqB,EAErBuC,iBAFqB,EAGrB;AACA,WAAKnB,QAJgB,EAKrBwC,cALqB,CADF,CAAvB;AASD,KA3Da,CA6Dd;;;AACA,QAAI/D,OAAO,CAACuB,QAAD,CAAX,EAAuB;AACrB;AACA,aAAOuE,sBAAsB,CAC3B3F,WAD2B,EAE3BuC,iBAF2B,EAG3BnB,QAH2B,EAI3BwC,cAJ2B,CAA7B;AAMD;;AAED,QAAItG,aAAa,CAAC8D,QAAD,CAAjB,EAA6B;AAC3B,aAAOgF,yBAAyB,CAC9BpG,WAD8B,EAE9BuC,iBAF8B,EAG9BnB,QAH8B,EAI9BwC,cAJ8B,CAAhC;AAMD;;AAED,QAAIsD,QAAJ,EAAc;AACZ/F,MAAAA,wBAAwB,CAACnB,WAAD,EAAcoB,QAAd,CAAxB;AACD;;AAED,QAAI9B,OAAJ,EAAa;AACX,UAAI,OAAO8B,QAAP,KAAoB,UAAxB,EAAoC;AAClCQ,QAAAA,kBAAkB;AACnB;AACF;;AACD,QAAI,OAAOR,QAAP,KAAoB,WAApB,IAAmC,CAAC6F,yBAAxC,EAAmE;AACjE;AACA;AACA;AACA,cAAQjH,WAAW,CAACc,GAApB;AACE,aAAKlD,cAAL;AAAqB;AACnB,gBAAI0B,OAAJ,EAAa;AACX,oBAAM6H,QAAQ,GAAGnH,WAAW,CAACQ,SAA7B;;AACA,kBAAI2G,QAAQ,CAAC5C,MAAT,CAAgB6C,eAApB,EAAqC;AACnC;AACA;AACD;AACF;AACF;AACD;AACA;AACA;;AACA,aAAKzJ,iBAAL;AAAwB;AACtB,kBAAM0J,SAAS,GAAGrH,WAAW,CAACU,IAA9B;AACAzC,YAAAA,SAAS,CACP,KADO,EAEP,qEACE,sDADF,GAEE,cAJK,EAKPoJ,SAAS,CAACC,WAAV,IAAyBD,SAAS,CAACE,IAAnC,IAA2C,WALpC,CAAT;AAOD;AAtBH;AAwBD,KAtHa,CAwHd;;;AACA,WAAOjF,uBAAuB,CAACtC,WAAD,EAAcuC,iBAAd,CAA9B;AACD;;AAED,SAAOyE,oBAAP;AACD;AAED;;;;;AAKA;;;AACA,OAAO,MAAMA,oBAAoB,GAAGnF,eAAe,CAAC,IAAD,CAA5C,C,CACP;;AACA,OAAO,MAAM2F,gBAAgB,GAAG3F,eAAe,CAAC,KAAD,CAAxC;AAEP,OAAO,SAAS4F,gBAAT,CACLxH,OADK,EAELyH,cAFK,EAGC;AACNzJ,EAAAA,SAAS,CACPgC,OAAO,KAAK,IAAZ,IAAoByH,cAAc,CAACrI,KAAf,KAAyBY,OAAO,CAACZ,KAD9C,EAEP,oCAFO,CAAT;;AAKA,MAAIqI,cAAc,CAACrI,KAAf,KAAyB,IAA7B,EAAmC;AACjC;AACD;;AAED,MAAIsI,YAAY,GAAGD,cAAc,CAACrI,KAAlC;AACA,MAAI+B,QAAQ,GAAGhD,oBAAoB,CAACuJ,YAAD,EAAeA,YAAY,CAAC1E,YAA5B,CAAnC;AACAyE,EAAAA,cAAc,CAACrI,KAAf,GAAuB+B,QAAvB;AAEAA,EAAAA,QAAQ,CAAC0C,MAAT,GAAkB4D,cAAlB;;AACA,SAAOC,YAAY,CAACnF,OAAb,KAAyB,IAAhC,EAAsC;AACpCmF,IAAAA,YAAY,GAAGA,YAAY,CAACnF,OAA5B;AACApB,IAAAA,QAAQ,GAAGA,QAAQ,CAACoB,OAAT,GAAmBpE,oBAAoB,CAChDuJ,YADgD,EAEhDA,YAAY,CAAC1E,YAFmC,CAAlD;AAIA7B,IAAAA,QAAQ,CAAC0C,MAAT,GAAkB4D,cAAlB;AACD;;AACDtG,EAAAA,QAAQ,CAACoB,OAAT,GAAmB,IAAnB;AACD,C,CAED;;AACA,OAAO,SAASoF,gBAAT,CACLF,cADK,EAELG,oBAFK,EAGC;AACN,MAAIxI,KAAK,GAAGqI,cAAc,CAACrI,KAA3B;;AACA,SAAOA,KAAK,KAAK,IAAjB,EAAuB;AACrBhB,IAAAA,mBAAmB,CAACgB,KAAD,EAAQwI,oBAAR,CAAnB;AACAxI,IAAAA,KAAK,GAAGA,KAAK,CAACmD,OAAd;AACD;AACF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement} from 'shared/ReactElementType';\nimport type {ReactPortal} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\n\nimport getComponentName from 'shared/getComponentName';\nimport {Placement, Deletion} from 'shared/ReactSideEffectTags';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_BLOCK_TYPE,\n} from 'shared/ReactSymbols';\nimport {\n  FunctionComponent,\n  ClassComponent,\n  HostText,\n  HostPortal,\n  Fragment,\n  Block,\n} from 'shared/ReactWorkTags';\nimport invariant from 'shared/invariant';\nimport {warnAboutStringRefs, enableBlocksAPI} from 'shared/ReactFeatureFlags';\n\nimport {\n  createWorkInProgress,\n  resetWorkInProgress,\n  createFiberFromElement,\n  createFiberFromFragment,\n  createFiberFromText,\n  createFiberFromPortal,\n} from './ReactFiber';\nimport {emptyRefsObject} from './ReactFiberClassComponent';\nimport {\n  getCurrentFiberStackInDev,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {isCompatibleFamilyForHotReloading} from './ReactFiberHotReloading';\nimport {StrictMode} from './ReactTypeOfMode';\n\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\nlet warnForMissingKey = (child: mixed) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child: mixed) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === 'object',\n      'React Component in warnForMissingKey should have a _store. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n    child._store.validated = true;\n\n    const currentComponentErrorInfo =\n      'Each child in a list should have a unique ' +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      'more information.' +\n      getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    console.error(\n      'Each child in a list should have a unique ' +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        'more information.',\n    );\n  };\n}\n\nconst isArray = Array.isArray;\n\nfunction coerceRef(\n  returnFiber: Fiber,\n  current: Fiber | null,\n  element: ReactElement,\n) {\n  let mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== 'function' &&\n    typeof mixedRef !== 'object'\n  ) {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if (\n        (returnFiber.mode & StrictMode || warnAboutStringRefs) &&\n        // We warn in ReactElement.js if owner and self are equal for string refs\n        // because these cannot be automatically converted to an arrow function\n        // using a codemod. Therefore, we don't have to warn about string refs again.\n        !(\n          element._owner &&\n          element._self &&\n          element._owner.stateNode !== element._self\n        )\n      ) {\n        const componentName = getComponentName(returnFiber.type) || 'Component';\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error(\n              'Component \"%s\" contains the string ref \"%s\". Support for string refs ' +\n                'will be removed in a future major release. We recommend using ' +\n                'useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://fb.me/react-strict-mode-string-ref%s',\n              componentName,\n              mixedRef,\n              getStackByFiberInDevAndProd(returnFiber),\n            );\n          } else {\n            console.error(\n              'A string ref, \"%s\", has been found within a strict mode tree. ' +\n                'String refs are a source of potential bugs and should be avoided. ' +\n                'We recommend using useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://fb.me/react-strict-mode-string-ref%s',\n              mixedRef,\n              getStackByFiberInDevAndProd(returnFiber),\n            );\n          }\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner: ?Fiber = (element._owner: any);\n      let inst;\n      if (owner) {\n        const ownerFiber = ((owner: any): Fiber);\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          'Function components cannot have string refs. ' +\n            'We recommend using useRef() instead. ' +\n            'Learn more about using refs safely here: ' +\n            'https://fb.me/react-strict-mode-string-ref',\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        'Missing owner for string ref %s. This error is likely caused by a ' +\n          'bug in React. Please file an issue.',\n        mixedRef,\n      );\n      const stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        typeof current.ref === 'function' &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      const ref = function (value) {\n        let refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === 'string',\n        'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',\n      );\n      invariant(\n        element._owner,\n        'Element ref was specified as a string (%s) but no owner was set. This could happen for one of' +\n          ' the following reasons:\\n' +\n          '1. You may be adding a ref to a function component\\n' +\n          \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n          '3. You have multiple copies of React loaded\\n' +\n          'See https://fb.me/react-refs-must-have-owner for more information.',\n        mixedRef,\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber: Fiber, newChild: Object) {\n  if (returnFiber.type !== 'textarea') {\n    let addendum = '';\n    if (__DEV__) {\n      addendum =\n        ' If you meant to render a collection of children, use an array ' +\n        'instead.' +\n        getCurrentFiberStackInDev();\n    }\n    invariant(\n      false,\n      'Objects are not valid as a React child (found: %s).%s',\n      Object.prototype.toString.call(newChild) === '[object Object]'\n        ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\n        : newChild,\n      addendum,\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  if (__DEV__) {\n    const currentComponentErrorInfo =\n      'Functions are not valid as a React child. This may happen if ' +\n      'you return a Component instead of <Component /> from render. ' +\n      'Or maybe you meant to call this function rather than return it.' +\n      getCurrentFiberStackInDev();\n\n    if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n    console.error(\n      'Functions are not valid as a React child. This may happen if ' +\n        'you return a Component instead of <Component /> from render. ' +\n        'Or maybe you meant to call this function rather than return it.',\n    );\n  }\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    const last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n  ): null {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    let childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber,\n  ): Map<string | number, Fiber> {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren: Map<string | number, Fiber> = new Map();\n\n    let existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(\n    newFiber: Fiber,\n    lastPlacedIndex: number,\n    newIndex: number,\n  ): number {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    const current = newFiber.alternate;\n    if (current !== null) {\n      const oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber: Fiber): Fiber {\n    // 如果是初始渲染 会在根组件(App)上设置 effectTag 属性为 Placement 值为 1\n    // 其他子级节点具有默认值为 0 防止在 commit 阶段反复操作真实DOM\n    // 初始渲染时如果当前处理的是根组件 true 其他组件 false\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      // Placement 表示新创建的节点\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    textContent: string,\n    expirationTime: ExpirationTime,\n  ) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(\n        textContent,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    element: ReactElement,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    if (current !== null) {\n      if (\n        current.elementType === element.type ||\n        // Keep this check inline so it only runs on the false path:\n        (__DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false)\n      ) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n        return existing;\n      } else if (\n        enableBlocksAPI &&\n        current.tag === Block &&\n        element.type.$$typeof === REACT_BLOCK_TYPE &&\n        element.type.render === current.type.render\n      ) {\n        // Same as above but also update the .type field.\n        const existing = useFiber(current, element.props);\n        existing.return = returnFiber;\n        existing.type = element.type;\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n        return existing;\n      }\n    }\n    // 创建 Fiber 对象\n    const created = createFiberFromElement(\n      element,\n      returnFiber.mode,\n      expirationTime,\n    );\n    // 添加 ref 属性\n    created.ref = coerceRef(returnFiber, current, element);\n    // 添加父级 Fiber 对象\n    created.return = returnFiber;\n    // 返回创建的 Fiber 对象\n    return created;\n  }\n\n  function updatePortal(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    portal: ReactPortal,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      const created = createFiberFromPortal(\n        portal,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    fragment: Iterable<*>,\n    expirationTime: ExpirationTime,\n    key: null | string,\n  ): Fiber {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        expirationTime,\n        key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(\n    returnFiber: Fiber,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText(\n        '' + newChild,\n        returnFiber.mode,\n        expirationTime,\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            expirationTime,\n          );\n          created.ref = coerceRef(returnFiber, null, newChild);\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_PORTAL_TYPE: {\n          const created = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            expirationTime,\n          );\n          created.return = returnFiber;\n          return created;\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          expirationTime,\n          null,\n        );\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // Update the fiber if the keys match, otherwise return null.\n\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        '' + newChild,\n        expirationTime,\n      );\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key,\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime,\n            );\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime,\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren: Map<string | number, Fiber>,\n    returnFiber: Fiber,\n    newIdx: number,\n    newChild: any,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        '' + newChild,\n        expirationTime,\n      );\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key,\n            );\n          }\n          return updateElement(\n            returnFiber,\n            matchedFiber,\n            newChild,\n            expirationTime,\n          );\n        }\n        case REACT_PORTAL_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            matchedFiber,\n            newChild,\n            expirationTime,\n          );\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n          null,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(\n    child: mixed,\n    knownKeys: Set<string> | null,\n  ): Set<string> | null {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          const key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          console.error(\n            'Encountered two children with the same key, `%s`. ' +\n              'Keys should be unique so that components maintain their identity ' +\n              'across updates. Non-unique keys may cause children to be ' +\n              'duplicated and/or omitted — the behavior is unsupported and ' +\n              'could change in a future version.',\n            key,\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n  // 处理子元素是数组的情况\n  function reconcileChildrenArray(\n    // 父级 Fiber\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    // 子级 vdom 数组\n    newChildren: Array<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n    /**\n     * 存储第一个子节点 Fiber 对象\n     * 方法返回的也是第一个子节点 Fiber 对象\n     * 因为其他子节点 Fiber 对象都存储在上一个子 Fiber 节点对象的 sibling 属性中\n     */\n    let resultingFirstChild: Fiber | null = null;\n    // 上一次创建的 Fiber 对象\n    let previousNewFiber: Fiber | null = null;\n    // 初始渲染没有旧的子级 所以为 null\n    let oldFiber = currentFirstChild;\n\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    // 初始渲染 oldFiber 为 null 循环不执行\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    // 初始渲染不执行\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    // oldFiber 为空 说明是初始渲染\n    if (oldFiber === null) {\n      // 遍历子 vdom 对象\n      for (; newIdx < newChildren.length; newIdx++) {\n        // 创建子 vdom 对应的 fiber 对象\n        const newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime,\n        );\n        // 如果 newFiber 为 null\n        if (newFiber === null) {\n          // 进入下次循环\n          continue;\n        }\n        // 初始渲染时只为 newFiber 添加了 index 属性,\n        // 其他事没干. lastPlacedIndex 被原封不动的返回了\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        // 为当前节点设置下一个兄弟节点\n        if (previousNewFiber === null) {\n          // 存储第一个子 Fiber 发生在第一次循环时\n          resultingFirstChild = newFiber;\n        } else {\n          // 为节点设置下一个兄弟 Fiber\n          previousNewFiber.sibling = newFiber;\n        }\n        // 在循环的过程中更新上一个创建的Fiber 对象\n        previousNewFiber = newFiber;\n      }\n      // 返回创建好的子 Fiber\n      // 其他 Fiber 都作为 sibling 存在\n      return resultingFirstChild;\n    }\n    // 下面的代码初始渲染不执行\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n    // 初始渲染不执行\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach((child) => deleteChild(returnFiber, child));\n    }\n    // 返回第一个子元素 Fiber 对象\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildrenIterable: Iterable<*>,\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === 'function',\n      'An object is not an iterable. This error is likely caused by a bug in ' +\n        'React. Please file an issue.',\n    );\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === 'function' &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === 'Generator'\n      ) {\n        if (!didWarnAboutGenerators) {\n          console.error(\n            'Using Generators as children is unsupported and will likely yield ' +\n              'unexpected results because enumerating a generator mutates it. ' +\n              'You may convert it to an array with `Array.from()` or the ' +\n              '`[...spread]` operator before rendering. Keep in mind ' +\n              'you might need to polyfill these features for older browsers.',\n          );\n        }\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if ((newChildrenIterable: any).entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error(\n            'Using Maps as children is unsupported and will likely yield ' +\n              'unexpected results. Convert it to a sequence/iterable of keyed ' +\n              'ReactElements instead.',\n          );\n        }\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      const newChildren = iteratorFn.call(newChildrenIterable);\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, 'An iterable object provided no iterator.');\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    let step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, expirationTime);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach((child) => deleteChild(returnFiber, child));\n    }\n\n    return resultingFirstChild;\n  }\n\n  // 处理子元素是文本或者数值的情况\n  function reconcileSingleTextNode(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    textContent: string,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    // 初始渲染不执行\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // 现有的第一个子节点不是文本节点，因此我们需要创建一个并删除现有的.\n    // 初始渲染不执行\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    // 根据文本创建 Fiber 对象\n    const created = createFiberFromText(\n      textContent,\n      returnFiber.mode,\n      expirationTime,\n    );\n    // 设置父 Fiber 对象\n    created.return = returnFiber;\n    // 返回创建好的 Fiber 对象\n    return created;\n  }\n  // 处理子元素是单个对象的情况\n  function reconcileSingleElement(\n    // 父 Fiber 对象\n    returnFiber: Fiber,\n    // 备份子 fiber\n    currentFirstChild: Fiber | null,\n    // 子 vdom 对象\n    element: ReactElement,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    const key = element.key;\n    let child = currentFirstChild;\n    // 初始渲染 currentFirstChild 为 null\n    // false\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        switch (child.tag) {\n          case Fragment: {\n            if (element.type === REACT_FRAGMENT_TYPE) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              const existing = useFiber(child, element.props.children);\n              existing.return = returnFiber;\n              if (__DEV__) {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            }\n            break;\n          }\n          case Block:\n            if (enableBlocksAPI) {\n              if (\n                element.type.$$typeof === REACT_BLOCK_TYPE &&\n                element.type.render === child.type.render\n              ) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                const existing = useFiber(child, element.props);\n                existing.type = element.type;\n                existing.return = returnFiber;\n                if (__DEV__) {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n                return existing;\n              }\n            }\n          // We intentionally fallthrough here if enableBlocksAPI is not on.\n          // eslint-disable-next-lined no-fallthrough\n          default: {\n            if (\n              child.elementType === element.type ||\n              // Keep this check inline so it only runs on the false path:\n              (__DEV__\n                ? isCompatibleFamilyForHotReloading(child, element)\n                : false)\n            ) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              const existing = useFiber(child, element.props);\n              existing.ref = coerceRef(returnFiber, child, element);\n              existing.return = returnFiber;\n              if (__DEV__) {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            }\n            break;\n          }\n        }\n        // Didn't match.\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n    // 查看子 vdom 对象是否表示 fragment\n    // false\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        expirationTime,\n        element.key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // 根据 React Element 创建 Fiber 对象\n      // 返回创建好的 Fiber 对象\n      const created = createFiberFromElement(\n        element,\n        // 用来表示当前组件下的所有子组件要用处于何种渲染模式\n        // 文件位置: ./ReactTypeOfMode.js\n        // 0    同步渲染模式\n        // 100  异步渲染模式\n        returnFiber.mode,\n        expirationTime,\n      );\n      // 添加 ref 属性 { current: DOM }\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      // 添加父级 Fiber 对象\n      created.return = returnFiber;\n      // 返回创建好的子 Fiber\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    portal: ReactPortal,\n    expirationTime: ExpirationTime,\n  ): Fiber {\n    const key = portal.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(\n      portal,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    // 父 Fiber 对象\n    returnFiber: Fiber,\n    // 旧的第一个子 Fiber 初始渲染 null\n    currentFirstChild: Fiber | null,\n    // 新的子 vdom 对象\n    newChild: any,\n    // 初始渲染 整型最大值 代表同步任务\n    expirationTime: ExpirationTime,\n  ): Fiber | null {\n    // 这是入口方法, 根据 newChild 类型进行对应处理\n\n    // 判断新的子 vdom 是否为占位组件 比如 <></>\n    // false\n    const isUnkeyedTopLevelFragment =\n      typeof newChild === 'object' &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n\n    // 如果 newChild 为占位符, 使用 占位符组件的子元素作为 newChild\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // 检测 newChild 是否为对象类型\n    const isObject = typeof newChild === 'object' && newChild !== null;\n\n    // newChild 是单个对象的情况\n    if (isObject) {\n      // 匹配子元素的类型\n      switch (newChild.$$typeof) {\n        // 子元素为 ReactElement\n        case REACT_ELEMENT_TYPE:\n          // 为 Fiber 对象设置 effectTag 属性\n          // 返回创建好的子 Fiber\n          return placeSingleChild(\n            // 处理单个 React Element 的情况\n            // 内部会调用其他方法创建对应的 Fiber 对象\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime,\n            ),\n          );\n      }\n    }\n    // 处理 children 为文本和数值的情况 return \"App works\"\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          // 如果 newChild 是数值, 转换为字符串\n          '' + newChild,\n          expirationTime,\n        ),\n      );\n    }\n\n    // children 是数组的情况\n    if (isArray(newChild)) {\n      // 返回创建好的子 Fiber\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime,\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          if (__DEV__) {\n            const instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionComponent: {\n          const Component = returnFiber.type;\n          invariant(\n            false,\n            '%s(...): Nothing was returned from render. This usually means a ' +\n              'return statement is missing. Or, to render nothing, ' +\n              'return null.',\n            Component.displayName || Component.name || 'Component',\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\n/**\n * shouldTrackSideEffects 标识, 是否为 Fiber 对象添加 effectTag\n * true 添加 false 不添加\n * 对于初始渲染来说, 只有根组件需要添加, 其他元素不需要添加, 防止过多的 DOM 操作\n */\n// 用于更新\nexport const reconcileChildFibers = ChildReconciler(true);\n// 用于初始渲染\nexport const mountChildFibers = ChildReconciler(false);\n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    'Resuming work not yet implemented.',\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// Reset a workInProgress child set to prepare it for a second pass.\nexport function resetChildFibers(\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): void {\n  let child = workInProgress.child;\n  while (child !== null) {\n    resetWorkInProgress(child, renderExpirationTime);\n    child = child.sibling;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}