{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport invariant from 'shared/invariant';\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport getComponentName from 'shared/getComponentName';\nimport { ClassComponent, HostComponent, HostRoot, HostPortal, HostText, FundamentalComponent, SuspenseComponent } from 'shared/ReactWorkTags';\nimport { NoEffect, Placement, Hydrating } from 'shared/ReactSideEffectTags';\nimport { enableFundamentalAPI } from 'shared/ReactFeatureFlags';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nexport function getNearestMountedFiber(fiber) {\n  let node = fiber;\n  let nearestMounted = fiber;\n\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    let nextNode = node;\n\n    do {\n      node = nextNode;\n\n      if ((node.effectTag & (Placement | Hydrating)) !== NoEffect) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  } // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n\n\n  return null;\n}\nexport function getSuspenseInstanceFromFiber(fiber) {\n  if (fiber.tag === SuspenseComponent) {\n    let suspenseState = fiber.memoizedState;\n\n    if (suspenseState === null) {\n      const current = fiber.alternate;\n\n      if (current !== null) {\n        suspenseState = current.memoizedState;\n      }\n    }\n\n    if (suspenseState !== null) {\n      return suspenseState.dehydrated;\n    }\n  }\n\n  return null;\n}\nexport function getContainerFromFiber(fiber) {\n  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\n}\nexport function isFiberMounted(fiber) {\n  return getNearestMountedFiber(fiber) === fiber;\n}\nexport function isMounted(component) {\n  if (__DEV__) {\n    const owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.tag === ClassComponent) {\n      const ownerFiber = owner;\n      const instance = ownerFiber.stateNode;\n\n      if (!instance._warnedAboutRefsInRender) {\n        console.error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component');\n      }\n\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  const fiber = getInstance(component);\n\n  if (!fiber) {\n    return false;\n  }\n\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(getNearestMountedFiber(fiber) === fiber, 'Unable to find node on an unmounted component.');\n}\n\nexport function findCurrentFiberUsingSlowPath(fiber) {\n  let alternate = fiber.alternate;\n\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    const nearestMounted = getNearestMountedFiber(fiber);\n    invariant(nearestMounted !== null, 'Unable to find node on an unmounted component.');\n\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n\n    return fiber;\n  } // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n\n\n  let a = fiber;\n  let b = alternate;\n\n  while (true) {\n    let parentA = a.return;\n\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n\n    let parentB = parentA.alternate;\n\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      const nextParent = parentA.return;\n\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      } // If there's no parent, we're at the root.\n\n\n      break;\n    } // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n\n\n    if (parentA.child === parentB.child) {\n      let child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n\n        child = child.sibling;\n      } // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n\n\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n\n        child = child.sibling;\n      }\n\n      if (!didFindChild) {\n        // Search parent B's child set\n        child = parentB.child;\n\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n\n          child = child.sibling;\n        }\n\n        invariant(didFindChild, 'Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n      }\n    }\n\n    invariant(a.alternate === b, \"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n  } // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n\n\n  invariant(a.tag === HostRoot, 'Unable to find node on an unmounted component.');\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  } // Otherwise B has to be current branch.\n\n\n  return alternate;\n}\nexport function findCurrentHostFiber(parent) {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n\n  if (!currentParent) {\n    return null;\n  } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n  let node = currentParent;\n\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === currentParent) {\n      return null;\n    }\n\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n\n\n  return null;\n}\nexport function findCurrentHostFiberWithNoPortals(parent) {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n\n  if (!currentParent) {\n    return null;\n  } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n  let node = currentParent;\n\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI && node.tag === FundamentalComponent) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === currentParent) {\n      return null;\n    }\n\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n\n\n  return null;\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberTreeReflection.js"],"names":["invariant","get","getInstance","ReactSharedInternals","getComponentName","ClassComponent","HostComponent","HostRoot","HostPortal","HostText","FundamentalComponent","SuspenseComponent","NoEffect","Placement","Hydrating","enableFundamentalAPI","ReactCurrentOwner","getNearestMountedFiber","fiber","node","nearestMounted","alternate","nextNode","effectTag","return","tag","getSuspenseInstanceFromFiber","suspenseState","memoizedState","current","dehydrated","getContainerFromFiber","stateNode","containerInfo","isFiberMounted","isMounted","component","__DEV__","owner","ownerFiber","instance","_warnedAboutRefsInRender","console","error","type","assertIsMounted","findCurrentFiberUsingSlowPath","a","b","parentA","parentB","nextParent","child","sibling","didFindChild","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {Container, SuspenseInstance} from './ReactFiberHostConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\n\nimport invariant from 'shared/invariant';\n\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport getComponentName from 'shared/getComponentName';\nimport {\n  ClassComponent,\n  HostComponent,\n  HostRoot,\n  HostPortal,\n  HostText,\n  FundamentalComponent,\n  SuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport {NoEffect, Placement, Hydrating} from 'shared/ReactSideEffectTags';\nimport {enableFundamentalAPI} from 'shared/ReactFeatureFlags';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nexport function getNearestMountedFiber(fiber: Fiber): null | Fiber {\n  let node = fiber;\n  let nearestMounted = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    let nextNode = node;\n    do {\n      node = nextNode;\n      if ((node.effectTag & (Placement | Hydrating)) !== NoEffect) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return null;\n}\n\nexport function getSuspenseInstanceFromFiber(\n  fiber: Fiber,\n): null | SuspenseInstance {\n  if (fiber.tag === SuspenseComponent) {\n    let suspenseState: SuspenseState | null = fiber.memoizedState;\n    if (suspenseState === null) {\n      const current = fiber.alternate;\n      if (current !== null) {\n        suspenseState = current.memoizedState;\n      }\n    }\n    if (suspenseState !== null) {\n      return suspenseState.dehydrated;\n    }\n  }\n  return null;\n}\n\nexport function getContainerFromFiber(fiber: Fiber): null | Container {\n  return fiber.tag === HostRoot\n    ? (fiber.stateNode.containerInfo: Container)\n    : null;\n}\n\nexport function isFiberMounted(fiber: Fiber): boolean {\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nexport function isMounted(component: React$Component<any, any>): boolean {\n  if (__DEV__) {\n    const owner = (ReactCurrentOwner.current: any);\n    if (owner !== null && owner.tag === ClassComponent) {\n      const ownerFiber: Fiber = owner;\n      const instance = ownerFiber.stateNode;\n      if (!instance._warnedAboutRefsInRender) {\n        console.error(\n          '%s is accessing isMounted inside its render() function. ' +\n            'render() should be a pure function of props and state. It should ' +\n            'never access something that requires stale data from the previous ' +\n            'render, such as refs. Move this logic to componentDidMount and ' +\n            'componentDidUpdate instead.',\n          getComponentName(ownerFiber.type) || 'A component',\n        );\n      }\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  const fiber: ?Fiber = getInstance(component);\n  if (!fiber) {\n    return false;\n  }\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    getNearestMountedFiber(fiber) === fiber,\n    'Unable to find node on an unmounted component.',\n  );\n}\n\nexport function findCurrentFiberUsingSlowPath(fiber: Fiber): Fiber | null {\n  let alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    const nearestMounted = getNearestMountedFiber(fiber);\n    invariant(\n      nearestMounted !== null,\n      'Unable to find node on an unmounted component.',\n    );\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  let a: Fiber = fiber;\n  let b: Fiber = alternate;\n  while (true) {\n    let parentA = a.return;\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n    let parentB = parentA.alternate;\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      const nextParent = parentA.return;\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      }\n      // If there's no parent, we're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      let didFindChild = false;\n      let child = parentA.child;\n      while (child) {\n        if (child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child = child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        child = parentB.child;\n        while (child) {\n          if (child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child = child.sibling;\n        }\n        invariant(\n          didFindChild,\n          'Child was not found in either parent set. This indicates a bug ' +\n            'in React related to the return pointer. Please file an issue.',\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    'Unable to find node on an unmounted component.',\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nexport function findCurrentHostFiber(parent: Fiber): Fiber | null {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  let node: Fiber = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nexport function findCurrentHostFiberWithNoPortals(parent: Fiber): Fiber | null {\n  const currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  let node: Fiber = currentParent;\n  while (true) {\n    if (\n      node.tag === HostComponent ||\n      node.tag === HostText ||\n      (enableFundamentalAPI && node.tag === FundamentalComponent)\n    ) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}