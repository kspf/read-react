{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getInstanceFromNode, isContainerMarkedAsRoot, unmarkContainerAsRoot } from './ReactDOMComponentTree';\nimport { createLegacyRoot, isValidContainer } from './ReactDOMRoot';\nimport { ROOT_ATTRIBUTE_NAME } from '../shared/DOMProperty';\nimport { DOCUMENT_NODE, ELEMENT_NODE, COMMENT_NODE } from '../shared/HTMLNodeType';\nimport { findHostInstanceWithNoPortals, updateContainer, unbatchedUpdates, getPublicRootInstance, findHostInstance, findHostInstanceWithWarning } from 'react-reconciler/inline.dom';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { has as hasInstance } from 'shared/ReactInstanceMap';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet topLevelUpdateWarnings;\nlet warnedAboutHydrateAPI = false;\n\nif (__DEV__) {\n  topLevelUpdateWarnings = container => {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      const hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n\n      if (hostInstance) {\n        if (hostInstance.parentNode !== container) {\n          console.error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n        }\n      }\n    }\n\n    const isRootRenderedBySomeReact = !!container._reactRootContainer;\n    const rootEl = getReactRootElementInContainer(container);\n    const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n      console.error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n    }\n\n    if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {\n      console.error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n    }\n  };\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  const rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n/**\n * 判断是否为服务器端渲染 如果不是服务器端渲染\n * 清空 container 容器中的节点\n */\n\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  // container => <div id=\"root\"></div>\n  // 检测是否为服务器端渲染\n  const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // 如果不是服务器端渲染\n\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling; // 开启循环 删除 container 容器中的节点\n\n    while (rootSibling = container.lastChild) {\n      // 在开发环境中\n      if (__DEV__) {\n        /**\n         * 判断子节点是否为元素节点, 并且元素节点不能有 data-reactroot 属性, 否则报错\n         * 通常在服务器端渲染时会遇到这个问题\n         *\n         * <div id=\"app\">\n         *  <%- markup %>\n         * </div>\n         * ↑ 报错\n         *\n         * <div id=\"app\"><%- markup %></div>\n         * ↑ 不报错 删除了所有空白区域\n         */\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && // 判断是否是服务端渲染的标志\n        rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          console.error('render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      } // 删除 container 容器中的节点\n\n\n      container.removeChild(rootSibling);\n      /**\n       * 为什么要清除 container 中的元素 ?\n       * 有时需要在 container 中放置一些占位图或者 loading 图以提高首屏加载用户体验,\n       * 就无可避免的要向 container 中加入 html 标记.\n       * 在将 ReactElement 渲染到 container 之前, 必然要先清空 container\n       * 因为占位图和 ReactElement 不能同时显示\n       *\n       * 在加入占位代码时, 最好只有一个父级元素, 可以减少内部代码的循环次数以提高性能\n       * <div>\n       *  <p>placement<p>\n       *  <p>placement<p>\n       *  <p>placement<p>\n       * </div>\n       */\n    }\n  } // 在开发环境下\n\n\n  if (__DEV__) {\n    // 如果是服务器端渲染 控制台提示错误\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true; // 在客户端二次渲染时不要使用 render 方法, 要使用 hydrate 方法替代\n\n      console.warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n\n  return createLegacyRoot(container, shouldHydrate ? {\n    hydrate: true\n  } : undefined);\n}\n\nfunction warnOnInvalidCallback(callback, callerName) {\n  if (__DEV__) {\n    if (callback !== null && typeof callback !== 'function') {\n      console.error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  }\n}\n/**\n * 将子树渲染到容器中 (初始化 Fiber 数据结构: 创建 fiberRoot 及 rootFiber)\n * parentComponent: 父组件, 初始渲染传入了 null\n * children: render 方法中的第一个参数, 要渲染的 ReactElement\n * container: 渲染容器\n * forceHydrate: true 为服务端渲染, false 为客户端渲染\n * callback: 组件渲染完成后需要执行的回调函数\n **/\n\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  if (__DEV__) {\n    topLevelUpdateWarnings(container);\n    warnOnInvalidCallback(callback === undefined ? null : callback, 'render');\n  }\n  /**\n   * 检测 container 是否已经是初始化过的渲染容器\n   * react 在初始渲染时会为最外层容器添加 _reactRootContainer 属性\n   * react 会根据此属性进行不同的渲染方式\n   * root 不存在 表示初始渲染\n   * root 存在 表示更新\n   */\n  // 获取 container 容器对象下是否有 _reactRootContainer 属性\n\n\n  let root = container._reactRootContainer; // 即将存储根 Fiber 对象\n\n  let fiberRoot;\n\n  if (!root) {\n    // 初始渲染\n    // 初始化根 Fiber 数据结构\n    // 为 container 容器添加 _reactRootContainer 属性\n    // 在 _reactRootContainer 对象中有一个属性叫做 _internalRoot\n    // _internalRoot 属性值即为 FiberRoot 表示根节点 Fiber 数据结构\n    // legacyCreateRootFromDOMContainer\n    // createLegacyRoot\n    // new ReactDOMBlockingRoot -> this._internalRoot\n    // createRootImpl\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate); // 获取 Fiber Root 对象\n\n    fiberRoot = root._internalRoot;\n    /**\n     * 改变 callback 函数中的 this 指向\n     * 使其指向 render 方法第一个参数的真实 DOM 对象\n     */\n    // 如果 callback 参数是函数类型\n\n    if (typeof callback === 'function') {\n      // 使用 originalCallback 存储 callback 函数\n      const originalCallback = callback; // 为 callback 参数重新赋值\n\n      callback = function () {\n        // 获取 render 方法第一个参数的真实 DOM 对象\n        // 实际上就是 id=\"root\" 的 div 的子元素\n        // rootFiber.child.stateNode\n        // rootFiber 就是 id=\"root\" 的 div\n        const instance = getPublicRootInstance(fiberRoot); // 调用原始 callback 函数并改变函数内部 this 指向\n\n        originalCallback.call(instance);\n      };\n    } // 初始化渲染不执行批量更新\n    // 因为批量更新是异步的是可以被打断的, 但是初始化渲染应该尽快完成不能被打断\n    // 所以不执行批量更新\n\n\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    // 非初始化渲染 即更新\n    fiberRoot = root._internalRoot;\n\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n\n      callback = function () {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    } // Update\n\n\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  } // 返回 render 方法第一个参数的真实 DOM 对象作为 render 方法的返回值\n  // 就是说渲染谁 返回谁的真实 DOM 对象\n\n\n  return getPublicRootInstance(fiberRoot);\n}\n\nexport function findDOMNode(componentOrElement) {\n  if (__DEV__) {\n    let owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.stateNode !== null) {\n      const warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n\n      if (!warnedAboutRefsInRender) {\n        console.error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');\n      }\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n\n  if (componentOrElement == null) {\n    return null;\n  }\n\n  if (componentOrElement.nodeType === ELEMENT_NODE) {\n    return componentOrElement;\n  }\n\n  if (__DEV__) {\n    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\n  }\n\n  return findHostInstance(componentOrElement);\n}\nexport function hydrate(element, container, callback) {\n  invariant(isValidContainer(container), 'Target container is not a DOM element.');\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      console.error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');\n    }\n  } // TODO: throw or warn if we couldn't hydrate?\n\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n}\n/**\n * 渲染入口\n * element 要进行渲染的 ReactElement\n * container 渲染容器\n * callback 渲染完成后执行的回调函数\n */\n\nexport function render(element, container, callback) {\n  // 检测 container 是否是符合要求的渲染容器\n  // 即检测 container 是否是真实的DOM对象\n  // 如果不符合要求就报错\n  invariant(isValidContainer(container), 'Target container is not a DOM element.'); // 在开发环境下\n\n  if (__DEV__) {\n    // 检测 container 是否已经传递给 ReactDOM.createRoot() 方法\n    // 如果已经传递, 则 container 不能再传递给 render 方法\n    // 防止 render 方法和 createRoot 方法重复调用\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined; // 如果 container 已经传递给过 createRoot 方法\n\n    if (isModernRoot) {\n      // 在控制台报错\n      console.error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');\n    }\n  }\n\n  return legacyRenderSubtreeIntoContainer( // 父组件 初始渲染没有父组件 传递 null 占位\n  null, element, container, // 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染\n  false, callback);\n}\nexport function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n  invariant(isValidContainer(containerNode), 'Target container is not a DOM element.');\n  invariant(parentComponent != null && hasInstance(parentComponent), 'parentComponent must be a valid React Component');\n  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n}\nexport function unmountComponentAtNode(container) {\n  invariant(isValidContainer(container), 'unmountComponentAtNode(...): Target container is not a DOM element.');\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      console.error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');\n    }\n  }\n\n  if (container._reactRootContainer) {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n\n      if (renderedByDifferentReact) {\n        console.error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n      }\n    } // Unmount should not be batched.\n\n\n    unbatchedUpdates(() => {\n      legacyRenderSubtreeIntoContainer(null, null, container, false, () => {\n        // $FlowFixMe This should probably use `delete container._reactRootContainer`\n        container._reactRootContainer = null;\n        unmarkContainerAsRoot(container);\n      });\n    }); // If you call unmountComponentAtNode twice in quick succession, you'll\n    // get `true` twice. That's probably fine?\n\n    return true;\n  } else {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl)); // Check if the container itself is a React root node.\n\n      const isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n      if (hasNonRootReactChild) {\n        console.error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n      }\n    }\n\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-dom/src/client/ReactDOMLegacy.js"],"names":["getInstanceFromNode","isContainerMarkedAsRoot","unmarkContainerAsRoot","createLegacyRoot","isValidContainer","ROOT_ATTRIBUTE_NAME","DOCUMENT_NODE","ELEMENT_NODE","COMMENT_NODE","findHostInstanceWithNoPortals","updateContainer","unbatchedUpdates","getPublicRootInstance","findHostInstance","findHostInstanceWithWarning","getComponentName","invariant","ReactSharedInternals","has","hasInstance","ReactCurrentOwner","topLevelUpdateWarnings","warnedAboutHydrateAPI","__DEV__","container","_reactRootContainer","nodeType","hostInstance","_internalRoot","current","parentNode","console","error","isRootRenderedBySomeReact","rootEl","getReactRootElementInContainer","hasNonRootReactChild","tagName","toUpperCase","documentElement","firstChild","shouldHydrateDueToLegacyHeuristic","rootElement","hasAttribute","legacyCreateRootFromDOMContainer","forceHydrate","shouldHydrate","warned","rootSibling","lastChild","removeChild","warn","hydrate","undefined","warnOnInvalidCallback","callback","callerName","legacyRenderSubtreeIntoContainer","parentComponent","children","root","fiberRoot","originalCallback","instance","call","findDOMNode","componentOrElement","owner","stateNode","warnedAboutRefsInRender","_warnedAboutRefsInRender","type","element","isModernRoot","render","unstable_renderSubtreeIntoContainer","containerNode","unmountComponentAtNode","renderedByDifferentReact","isContainerReactRoot"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Container} from './ReactDOMHostConfig';\nimport type {RootType} from './ReactDOMRoot';\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport {\n  getInstanceFromNode,\n  isContainerMarkedAsRoot,\n  unmarkContainerAsRoot,\n} from './ReactDOMComponentTree';\nimport {createLegacyRoot, isValidContainer} from './ReactDOMRoot';\nimport {ROOT_ATTRIBUTE_NAME} from '../shared/DOMProperty';\nimport {\n  DOCUMENT_NODE,\n  ELEMENT_NODE,\n  COMMENT_NODE,\n} from '../shared/HTMLNodeType';\n\nimport {\n  findHostInstanceWithNoPortals,\n  updateContainer,\n  unbatchedUpdates,\n  getPublicRootInstance,\n  findHostInstance,\n  findHostInstanceWithWarning,\n} from 'react-reconciler/inline.dom';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {has as hasInstance} from 'shared/ReactInstanceMap';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nlet topLevelUpdateWarnings;\nlet warnedAboutHydrateAPI = false;\n\nif (__DEV__) {\n  topLevelUpdateWarnings = (container: Container) => {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      const hostInstance = findHostInstanceWithNoPortals(\n        container._reactRootContainer._internalRoot.current,\n      );\n      if (hostInstance) {\n        if (hostInstance.parentNode !== container) {\n          console.error(\n            'render(...): It looks like the React-rendered content of this ' +\n              'container was removed without using React. This is not ' +\n              'supported and will cause errors. Instead, call ' +\n              'ReactDOM.unmountComponentAtNode to empty a container.',\n          );\n        }\n      }\n    }\n\n    const isRootRenderedBySomeReact = !!container._reactRootContainer;\n    const rootEl = getReactRootElementInContainer(container);\n    const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n      console.error(\n        'render(...): Replacing React-rendered children with a new root ' +\n          'component. If you intended to update the children of this node, ' +\n          'you should instead have the existing children update their state ' +\n          'and render the new components instead of calling ReactDOM.render.',\n      );\n    }\n\n    if (\n      container.nodeType === ELEMENT_NODE &&\n      ((container: any): Element).tagName &&\n      ((container: any): Element).tagName.toUpperCase() === 'BODY'\n    ) {\n      console.error(\n        'render(): Rendering components directly into document.body is ' +\n          'discouraged, since its children are often manipulated by third-party ' +\n          'scripts and browser extensions. This may lead to subtle ' +\n          'reconciliation issues. Try rendering into a container element created ' +\n          'for your app.',\n      );\n    }\n  };\n}\n\nfunction getReactRootElementInContainer(container: any) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  const rootElement = getReactRootElementInContainer(container);\n  return !!(\n    rootElement &&\n    rootElement.nodeType === ELEMENT_NODE &&\n    rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)\n  );\n}\n\n/**\n * 判断是否为服务器端渲染 如果不是服务器端渲染\n * 清空 container 容器中的节点\n */\nfunction legacyCreateRootFromDOMContainer(\n  container: Container,\n  forceHydrate: boolean,\n): RootType {\n  // container => <div id=\"root\"></div>\n  // 检测是否为服务器端渲染\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // 如果不是服务器端渲染\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    // 开启循环 删除 container 容器中的节点\n    while ((rootSibling = container.lastChild)) {\n      // 在开发环境中\n      if (__DEV__) {\n        /**\n         * 判断子节点是否为元素节点, 并且元素节点不能有 data-reactroot 属性, 否则报错\n         * 通常在服务器端渲染时会遇到这个问题\n         *\n         * <div id=\"app\">\n         *  <%- markup %>\n         * </div>\n         * ↑ 报错\n         *\n         * <div id=\"app\"><%- markup %></div>\n         * ↑ 不报错 删除了所有空白区域\n         */\n        if (\n          !warned &&\n          rootSibling.nodeType === ELEMENT_NODE &&\n          // 判断是否是服务端渲染的标志\n          (rootSibling: any).hasAttribute(ROOT_ATTRIBUTE_NAME)\n        ) {\n          warned = true;\n          console.error(\n            'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.',\n          );\n        }\n      }\n      // 删除 container 容器中的节点\n      container.removeChild(rootSibling);\n      /**\n       * 为什么要清除 container 中的元素 ?\n       * 有时需要在 container 中放置一些占位图或者 loading 图以提高首屏加载用户体验,\n       * 就无可避免的要向 container 中加入 html 标记.\n       * 在将 ReactElement 渲染到 container 之前, 必然要先清空 container\n       * 因为占位图和 ReactElement 不能同时显示\n       *\n       * 在加入占位代码时, 最好只有一个父级元素, 可以减少内部代码的循环次数以提高性能\n       * <div>\n       *  <p>placement<p>\n       *  <p>placement<p>\n       *  <p>placement<p>\n       * </div>\n       */\n    }\n  }\n  // 在开发环境下\n  if (__DEV__) {\n    // 如果是服务器端渲染 控制台提示错误\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      // 在客户端二次渲染时不要使用 render 方法, 要使用 hydrate 方法替代\n      console.warn(\n        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +\n          'will stop working in React v17. Replace the ReactDOM.render() call ' +\n          'with ReactDOM.hydrate() if you want React to attach to the server HTML.',\n      );\n    }\n  }\n  return createLegacyRoot(\n    container,\n    shouldHydrate\n      ? {\n          hydrate: true,\n        }\n      : undefined,\n  );\n}\n\nfunction warnOnInvalidCallback(callback: mixed, callerName: string): void {\n  if (__DEV__) {\n    if (callback !== null && typeof callback !== 'function') {\n      console.error(\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  }\n}\n/**\n * 将子树渲染到容器中 (初始化 Fiber 数据结构: 创建 fiberRoot 及 rootFiber)\n * parentComponent: 父组件, 初始渲染传入了 null\n * children: render 方法中的第一个参数, 要渲染的 ReactElement\n * container: 渲染容器\n * forceHydrate: true 为服务端渲染, false 为客户端渲染\n * callback: 组件渲染完成后需要执行的回调函数\n **/\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: Container,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  if (__DEV__) {\n    topLevelUpdateWarnings(container);\n    warnOnInvalidCallback(callback === undefined ? null : callback, 'render');\n  }\n\n  /**\n   * 检测 container 是否已经是初始化过的渲染容器\n   * react 在初始渲染时会为最外层容器添加 _reactRootContainer 属性\n   * react 会根据此属性进行不同的渲染方式\n   * root 不存在 表示初始渲染\n   * root 存在 表示更新\n   */\n  // 获取 container 容器对象下是否有 _reactRootContainer 属性\n  let root: RootType = (container._reactRootContainer: any);\n  // 即将存储根 Fiber 对象\n  let fiberRoot;\n  if (!root) {\n    // 初始渲染\n    // 初始化根 Fiber 数据结构\n    // 为 container 容器添加 _reactRootContainer 属性\n    // 在 _reactRootContainer 对象中有一个属性叫做 _internalRoot\n    // _internalRoot 属性值即为 FiberRoot 表示根节点 Fiber 数据结构\n    // legacyCreateRootFromDOMContainer\n    // createLegacyRoot\n    // new ReactDOMBlockingRoot -> this._internalRoot\n    // createRootImpl\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    // 获取 Fiber Root 对象\n    fiberRoot = root._internalRoot;\n    /**\n     * 改变 callback 函数中的 this 指向\n     * 使其指向 render 方法第一个参数的真实 DOM 对象\n     */\n    // 如果 callback 参数是函数类型\n    if (typeof callback === 'function') {\n      // 使用 originalCallback 存储 callback 函数\n      const originalCallback = callback;\n      // 为 callback 参数重新赋值\n      callback = function () {\n        // 获取 render 方法第一个参数的真实 DOM 对象\n        // 实际上就是 id=\"root\" 的 div 的子元素\n        // rootFiber.child.stateNode\n        // rootFiber 就是 id=\"root\" 的 div\n        const instance = getPublicRootInstance(fiberRoot);\n        // 调用原始 callback 函数并改变函数内部 this 指向\n        originalCallback.call(instance);\n      };\n    }\n    // 初始化渲染不执行批量更新\n    // 因为批量更新是异步的是可以被打断的, 但是初始化渲染应该尽快完成不能被打断\n    // 所以不执行批量更新\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    // 非初始化渲染 即更新\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function () {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  // 返回 render 方法第一个参数的真实 DOM 对象作为 render 方法的返回值\n  // 就是说渲染谁 返回谁的真实 DOM 对象\n  return getPublicRootInstance(fiberRoot);\n}\n\nexport function findDOMNode(\n  componentOrElement: Element | ?React$Component<any, any>,\n): null | Element | Text {\n  if (__DEV__) {\n    let owner = (ReactCurrentOwner.current: any);\n    if (owner !== null && owner.stateNode !== null) {\n      const warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n      if (!warnedAboutRefsInRender) {\n        console.error(\n          '%s is accessing findDOMNode inside its render(). ' +\n            'render() should be a pure function of props and state. It should ' +\n            'never access something that requires stale data from the previous ' +\n            'render, such as refs. Move this logic to componentDidMount and ' +\n            'componentDidUpdate instead.',\n          getComponentName(owner.type) || 'A component',\n        );\n      }\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrElement == null) {\n    return null;\n  }\n  if ((componentOrElement: any).nodeType === ELEMENT_NODE) {\n    return (componentOrElement: any);\n  }\n  if (__DEV__) {\n    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\n  }\n  return findHostInstance(componentOrElement);\n}\n\nexport function hydrate(\n  element: React$Node,\n  container: Container,\n  callback: ?Function,\n) {\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.hydrate() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call createRoot(container, {hydrate: true}).render(element)?',\n      );\n    }\n  }\n  // TODO: throw or warn if we couldn't hydrate?\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    true,\n    callback,\n  );\n}\n/**\n * 渲染入口\n * element 要进行渲染的 ReactElement\n * container 渲染容器\n * callback 渲染完成后执行的回调函数\n */\nexport function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n) {\n  // 检测 container 是否是符合要求的渲染容器\n  // 即检测 container 是否是真实的DOM对象\n  // 如果不符合要求就报错\n  invariant(\n    isValidContainer(container),\n    'Target container is not a DOM element.',\n  );\n  // 在开发环境下\n  if (__DEV__) {\n    // 检测 container 是否已经传递给 ReactDOM.createRoot() 方法\n    // 如果已经传递, 则 container 不能再传递给 render 方法\n    // 防止 render 方法和 createRoot 方法重复调用\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    // 如果 container 已经传递给过 createRoot 方法\n    if (isModernRoot) {\n      // 在控制台报错\n      console.error(\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  return legacyRenderSubtreeIntoContainer(\n    // 父组件 初始渲染没有父组件 传递 null 占位\n    null,\n    element,\n    container,\n    // 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染\n    false,\n    callback,\n  );\n}\n\nexport function unstable_renderSubtreeIntoContainer(\n  parentComponent: React$Component<any, any>,\n  element: React$Element<any>,\n  containerNode: Container,\n  callback: ?Function,\n) {\n  invariant(\n    isValidContainer(containerNode),\n    'Target container is not a DOM element.',\n  );\n  invariant(\n    parentComponent != null && hasInstance(parentComponent),\n    'parentComponent must be a valid React Component',\n  );\n  return legacyRenderSubtreeIntoContainer(\n    parentComponent,\n    element,\n    containerNode,\n    false,\n    callback,\n  );\n}\n\nexport function unmountComponentAtNode(container: Container) {\n  invariant(\n    isValidContainer(container),\n    'unmountComponentAtNode(...): Target container is not a DOM element.',\n  );\n\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +\n          'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?',\n      );\n    }\n  }\n\n  if (container._reactRootContainer) {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n      if (renderedByDifferentReact) {\n        console.error(\n          \"unmountComponentAtNode(): The node you're attempting to unmount \" +\n            'was rendered by another copy of React.',\n        );\n      }\n    }\n\n    // Unmount should not be batched.\n    unbatchedUpdates(() => {\n      legacyRenderSubtreeIntoContainer(null, null, container, false, () => {\n        // $FlowFixMe This should probably use `delete container._reactRootContainer`\n        container._reactRootContainer = null;\n        unmarkContainerAsRoot(container);\n      });\n    });\n    // If you call unmountComponentAtNode twice in quick succession, you'll\n    // get `true` twice. That's probably fine?\n    return true;\n  } else {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n      // Check if the container itself is a React root node.\n      const isContainerReactRoot =\n        container.nodeType === ELEMENT_NODE &&\n        isValidContainer(container.parentNode) &&\n        !!container.parentNode._reactRootContainer;\n\n      if (hasNonRootReactChild) {\n        console.error(\n          \"unmountComponentAtNode(): The node you're attempting to unmount \" +\n            'was rendered by React and is not a top-level container. %s',\n          isContainerReactRoot\n            ? 'You may have accidentally passed in a React root node instead ' +\n                'of its container.'\n            : 'Instead, have the parent component update its state and ' +\n                'rerender in order to remove this component.',\n        );\n      }\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}