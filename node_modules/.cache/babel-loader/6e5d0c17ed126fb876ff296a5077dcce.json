{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { NoWork, Sync } from './ReactFiberExpirationTime';\nimport { readContext } from './ReactFiberNewContext';\nimport { createDeprecatedResponderListener } from './ReactFiberDeprecatedEvents';\nimport { Update as UpdateEffect, Passive as PassiveEffect } from 'shared/ReactSideEffectTags';\nimport { HasEffect as HookHasEffect, Layout as HookLayout, Passive as HookPassive } from './ReactHookEffectTags';\nimport { scheduleWork, computeExpirationForFiber, requestCurrentTimeForUpdate, warnIfNotCurrentlyActingEffectsInDEV, warnIfNotCurrentlyActingUpdatesInDev, warnIfNotScopedWithMatchingAct, markRenderEventTimeAndConfig, markUnprocessedUpdateTime } from './ReactFiberWorkLoop';\nimport invariant from 'shared/invariant';\nimport getComponentName from 'shared/getComponentName';\nimport is from 'shared/objectIs';\nimport { markWorkInProgressReceivedUpdate } from './ReactFiberBeginWork';\nimport { requestCurrentSuspenseConfig } from './ReactFiberSuspenseConfig';\nimport { UserBlockingPriority, NormalPriority, runWithPriority, getCurrentPriorityLevel } from './SchedulerWithReactIntegration';\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentBatchConfig\n} = ReactSharedInternals;\nlet didWarnAboutMismatchedHooksForComponent;\n\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nlet renderExpirationTime = NoWork; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nlet currentlyRenderingFiber = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nlet currentHook = null;\nlet workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nlet didScheduleRenderPhaseUpdate = false;\nconst RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nlet currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nlet hookTypesDev = null;\nlet hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nlet ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  if (__DEV__) {\n    const componentName = getComponentName(currentlyRenderingFiber.type);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          let row = `${i + 1}. ${oldHookName}`; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        console.error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  invariant(false, 'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, `[${prevDeps.join(', ')}]`, `[${nextDeps.join(', ')}]`);\n    }\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nexport function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderExpirationTime) {\n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.expirationTime = NoWork; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, secondArg); // Check if there was a render phase update\n\n  if (workInProgress.expirationTime === renderExpirationTime) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    let numberOfReRenders = 0;\n\n    do {\n      workInProgress.expirationTime = NoWork;\n      invariant(numberOfReRenders < RE_RENDER_LIMIT, 'Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n      numberOfReRenders += 1;\n\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__ ? HooksDispatcherOnRerenderInDEV : HooksDispatcherOnRerender;\n      children = Component(props, secondArg);\n    } while (workInProgress.expirationTime === renderExpirationTime);\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n\n\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n  invariant(!didRenderTooFewHooks, 'Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  return children;\n}\nexport function bailoutHooks(current, workInProgress, expirationTime) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.effectTag &= ~(PassiveEffect | UpdateEffect);\n\n  if (current.expirationTime <= expirationTime) {\n    current.expirationTime = NoWork;\n  }\n}\nexport function resetHooksAfterThrow() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook = currentlyRenderingFiber.memoizedState;\n\n    while (hook !== null) {\n      const queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n  }\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n}\n\nfunction mountWorkInProgressHook() {\n  const hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook;\n\n  if (currentHook === null) {\n    let current = currentlyRenderingFiber.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    invariant(nextCurrentHook !== null, 'Rendered more hooks than during the previous render.');\n    currentHook = nextCurrentHook;\n    const newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  const dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(queue !== null, 'Should have a queue. This is likely a bug in React. Please file an issue.');\n  queue.lastRenderedReducer = reducer;\n  const current = currentHook; // The last rebase update that is NOT part of the base state.\n\n  let baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n  let pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      let baseFirst = baseQueue.next;\n      let pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    let first = baseQueue.next;\n    let newState = current.baseState;\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n\n    do {\n      const updateExpirationTime = update.expirationTime;\n\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          expirationTime: update.expirationTime,\n          suspenseConfig: update.suspenseConfig,\n          action: update.action,\n          eagerReducer: update.eagerReducer,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        if (updateExpirationTime > currentlyRenderingFiber.expirationTime) {\n          currentlyRenderingFiber.expirationTime = updateExpirationTime;\n          markUnprocessedUpdateTime(updateExpirationTime);\n        }\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          const clone = {\n            expirationTime: Sync,\n            // This update is going to be committed so we never want uncommit it.\n            suspenseConfig: update.suspenseConfig,\n            action: update.action,\n            eagerReducer: update.eagerReducer,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n\n\n        markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); // Process this update.\n\n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          newState = update.eagerState;\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(queue !== null, 'Should have a queue. This is likely a bug in React. Please file an issue.');\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  const dispatch = queue.dispatch;\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction mountState(initialState) {\n  const hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  const dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer, initialState);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: null\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nfunction mountRef(initialValue) {\n  const hook = mountWorkInProgressHook();\n  const ref = {\n    current: initialValue\n  };\n\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef(initialValue) {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.effectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(HookHasEffect | hookEffectTag, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(hookEffectTag, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.effectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(HookHasEffect | hookEffectTag, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n    }\n  }\n\n  return mountEffectImpl(UpdateEffect | PassiveEffect, HookPassive, create, deps);\n}\n\nfunction updateEffect(create, deps) {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n    }\n  }\n\n  return updateEffectImpl(UpdateEffect | PassiveEffect, HookPassive, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  return mountEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return mountEffectImpl(UpdateEffect, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(UpdateEffect, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value, config) {\n  const [prevValue, setValue] = mountState(value);\n  mountEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction updateDeferredValue(value, config) {\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction rerenderDeferredValue(value, config) {\n  const [prevValue, setValue] = rerenderState(value);\n  updateEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction startTransition(setPending, config, callback) {\n  const priorityLevel = getCurrentPriorityLevel();\n  runWithPriority(priorityLevel < UserBlockingPriority ? UserBlockingPriority : priorityLevel, () => {\n    setPending(true);\n  });\n  runWithPriority(priorityLevel > NormalPriority ? NormalPriority : priorityLevel, () => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n\n    try {\n      setPending(false);\n      callback();\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  });\n}\n\nfunction mountTransition(config) {\n  const [isPending, setPending] = mountState(false);\n  const start = mountCallback(startTransition.bind(null, setPending, config), [setPending, config]);\n  return [start, isPending];\n}\n\nfunction updateTransition(config) {\n  const [isPending, setPending] = updateState(false);\n  const start = updateCallback(startTransition.bind(null, setPending, config), [setPending, config]);\n  return [start, isPending];\n}\n\nfunction rerenderTransition(config) {\n  const [isPending, setPending] = rerenderState(false);\n  const start = updateCallback(startTransition.bind(null, setPending, config), [setPending, config]);\n  return [start, isPending];\n}\n\nfunction dispatchAction(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const currentTime = requestCurrentTimeForUpdate();\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n  const update = {\n    expirationTime,\n    suspenseConfig,\n    action,\n    eagerReducer: null,\n    eagerState: null,\n    next: null\n  };\n\n  if (__DEV__) {\n    update.priority = getCurrentPriorityLevel();\n  } // Append the update to the end of the list.\n\n\n  const pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n  const alternate = fiber.alternate;\n\n  if (fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true;\n    update.expirationTime = renderExpirationTime;\n    currentlyRenderingFiber.expirationTime = renderExpirationTime;\n  } else {\n    if (fiber.expirationTime === NoWork && (alternate === null || alternate.expirationTime === NoWork)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          const currentState = queue.lastRenderedState;\n          const eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    if (__DEV__) {\n      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n      if ('undefined' !== typeof jest) {\n        warnIfNotScopedWithMatchingAct(fiber);\n        warnIfNotCurrentlyActingUpdatesInDev(fiber);\n      }\n    }\n\n    scheduleWork(fiber, expirationTime);\n  }\n}\n\nexport const ContextOnlyDispatcher = {\n  readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useResponder: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError\n};\nconst HooksDispatcherOnMount = {\n  readContext,\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useResponder: createDeprecatedResponderListener,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition\n};\nconst HooksDispatcherOnUpdate = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useResponder: createDeprecatedResponderListener,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition\n};\nconst HooksDispatcherOnRerender = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useResponder: createDeprecatedResponderListener,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition\n};\nlet HooksDispatcherOnMountInDEV = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV = null;\nlet HooksDispatcherOnUpdateInDEV = null;\nlet HooksDispatcherOnRerenderInDEV = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://fb.me/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      mountHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition(config);\n    }\n\n  };\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition(config);\n    }\n\n  };\n  HooksDispatcherOnUpdateInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition(config);\n    }\n\n  };\n  HooksDispatcherOnRerenderInDEV = {\n    readContext(context, observedBits) {\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition(config);\n    }\n\n  };\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext(context, observedBits) {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition(config);\n    }\n\n  };\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext(context, observedBits) {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition(config);\n    }\n\n  };\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext(context, observedBits) {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context, observedBits) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useResponder(responder, props) {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n\n    useDeferredValue(value, config) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value, config);\n    },\n\n    useTransition(config) {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition(config);\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberHooks.js"],"names":["ReactSharedInternals","NoWork","Sync","readContext","createDeprecatedResponderListener","Update","UpdateEffect","Passive","PassiveEffect","HasEffect","HookHasEffect","Layout","HookLayout","HookPassive","scheduleWork","computeExpirationForFiber","requestCurrentTimeForUpdate","warnIfNotCurrentlyActingEffectsInDEV","warnIfNotCurrentlyActingUpdatesInDev","warnIfNotScopedWithMatchingAct","markRenderEventTimeAndConfig","markUnprocessedUpdateTime","invariant","getComponentName","is","markWorkInProgressReceivedUpdate","requestCurrentSuspenseConfig","UserBlockingPriority","NormalPriority","runWithPriority","getCurrentPriorityLevel","ReactCurrentDispatcher","ReactCurrentBatchConfig","didWarnAboutMismatchedHooksForComponent","__DEV__","Set","renderExpirationTime","currentlyRenderingFiber","currentHook","workInProgressHook","didScheduleRenderPhaseUpdate","RE_RENDER_LIMIT","currentHookNameInDev","hookTypesDev","hookTypesUpdateIndexDev","ignorePreviousDependencies","mountHookTypesDev","hookName","push","updateHookTypesDev","warnOnHookMismatchInDev","checkDepsAreArrayDev","deps","undefined","Array","isArray","console","error","currentHookName","componentName","type","has","add","table","secondColumnStart","i","oldHookName","newHookName","row","length","throwInvalidHookError","areHookInputsEqual","nextDeps","prevDeps","join","renderWithHooks","current","workInProgress","Component","props","secondArg","nextRenderExpirationTime","_debugHookTypes","memoizedState","updateQueue","expirationTime","HooksDispatcherOnUpdateInDEV","HooksDispatcherOnMountWithHookTypesInDEV","HooksDispatcherOnMountInDEV","HooksDispatcherOnMount","HooksDispatcherOnUpdate","children","numberOfReRenders","HooksDispatcherOnRerenderInDEV","HooksDispatcherOnRerender","ContextOnlyDispatcher","didRenderTooFewHooks","next","bailoutHooks","effectTag","resetHooksAfterThrow","hook","queue","pending","mountWorkInProgressHook","baseState","baseQueue","updateWorkInProgressHook","nextCurrentHook","alternate","nextWorkInProgressHook","newHook","createFunctionComponentUpdateQueue","lastEffect","basicStateReducer","state","action","mountReducer","reducer","initialArg","init","initialState","dispatch","lastRenderedReducer","lastRenderedState","dispatchAction","bind","updateReducer","pendingQueue","baseFirst","pendingFirst","first","newState","newBaseState","newBaseQueueFirst","newBaseQueueLast","update","updateExpirationTime","clone","suspenseConfig","eagerReducer","eagerState","rerenderReducer","lastRenderPhaseUpdate","firstRenderPhaseUpdate","mountState","updateState","rerenderState","pushEffect","tag","create","destroy","effect","componentUpdateQueue","firstEffect","mountRef","initialValue","ref","Object","seal","updateRef","mountEffectImpl","fiberEffectTag","hookEffectTag","updateEffectImpl","prevEffect","mountEffect","jest","updateEffect","mountLayoutEffect","updateLayoutEffect","imperativeHandleEffect","refCallback","inst","refObject","hasOwnProperty","keys","mountImperativeHandle","effectDeps","concat","updateImperativeHandle","mountDebugValue","value","formatterFn","updateDebugValue","mountCallback","callback","updateCallback","prevState","mountMemo","nextCreate","nextValue","updateMemo","mountDeferredValue","config","prevValue","setValue","previousConfig","suspense","updateDeferredValue","rerenderDeferredValue","startTransition","setPending","priorityLevel","mountTransition","isPending","start","updateTransition","rerenderTransition","fiber","arguments","currentTime","priority","prevDispatcher","InvalidNestedHooksDispatcherOnUpdateInDEV","currentState","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useReducer","useRef","useState","useDebugValue","useResponder","useDeferredValue","useTransition","InvalidNestedHooksDispatcherOnMountInDEV","InvalidNestedHooksDispatcherOnRerenderInDEV","warnInvalidContextAccess","warnInvalidHookAccess","context","observedBits","responder"],"mappings":"AAAA;;;;;;;;AAoBA,OAAOA,oBAAP,MAAiC,6BAAjC;AAEA,SAAQC,MAAR,EAAgBC,IAAhB,QAA2B,4BAA3B;AACA,SAAQC,WAAR,QAA0B,wBAA1B;AACA,SAAQC,iCAAR,QAAgD,8BAAhD;AACA,SACEC,MAAM,IAAIC,YADZ,EAEEC,OAAO,IAAIC,aAFb,QAGO,4BAHP;AAIA,SACEC,SAAS,IAAIC,aADf,EAEEC,MAAM,IAAIC,UAFZ,EAGEL,OAAO,IAAIM,WAHb,QAIO,uBAJP;AAKA,SACEC,YADF,EAEEC,yBAFF,EAGEC,2BAHF,EAIEC,oCAJF,EAKEC,oCALF,EAMEC,8BANF,EAOEC,4BAPF,EAQEC,yBARF,QASO,sBATP;AAWA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,OAAOC,gBAAP,MAA6B,yBAA7B;AACA,OAAOC,EAAP,MAAe,iBAAf;AACA,SAAQC,gCAAR,QAA+C,uBAA/C;AACA,SAAQC,4BAAR,QAA2C,4BAA3C;AACA,SACEC,oBADF,EAEEC,cAFF,EAGEC,eAHF,EAIEC,uBAJF,QAKO,iCALP;AAOA,MAAM;AAACC,EAAAA,sBAAD;AAAyBC,EAAAA;AAAzB,IAAoDhC,oBAA1D;AA4EA,IAAIiC,uCAAJ;;AACA,IAAIC,OAAJ,EAAa;AACXD,EAAAA,uCAAuC,GAAG,IAAIE,GAAJ,EAA1C;AACD;;AA4BD;AACA,IAAIC,oBAAoC,GAAGnC,MAA3C,C,CACA;AACA;;AACA,IAAIoC,uBAA8B,GAAI,IAAtC,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,WAAwB,GAAG,IAA/B;AACA,IAAIC,kBAA+B,GAAG,IAAtC,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,4BAAqC,GAAG,KAA5C;AAEA,MAAMC,eAAe,GAAG,EAAxB,C,CAEA;;AACA,IAAIC,oBAA+B,GAAG,IAAtC,C,CAEA;AACA;AACA;;AACA,IAAIC,YAAoC,GAAG,IAA3C;AACA,IAAIC,uBAA+B,GAAG,CAAC,CAAvC,C,CAEA;AACA;AACA;;AACA,IAAIC,0BAAmC,GAAG,KAA1C;;AAEA,SAASC,iBAAT,GAA6B;AAC3B,MAAIZ,OAAJ,EAAa;AACX,UAAMa,QAAQ,GAAKL,oBAAnB;;AAEA,QAAIC,YAAY,KAAK,IAArB,EAA2B;AACzBA,MAAAA,YAAY,GAAG,CAACI,QAAD,CAAf;AACD,KAFD,MAEO;AACLJ,MAAAA,YAAY,CAACK,IAAb,CAAkBD,QAAlB;AACD;AACF;AACF;;AAED,SAASE,kBAAT,GAA8B;AAC5B,MAAIf,OAAJ,EAAa;AACX,UAAMa,QAAQ,GAAKL,oBAAnB;;AAEA,QAAIC,YAAY,KAAK,IAArB,EAA2B;AACzBC,MAAAA,uBAAuB;;AACvB,UAAID,YAAY,CAACC,uBAAD,CAAZ,KAA0CG,QAA9C,EAAwD;AACtDG,QAAAA,uBAAuB,CAACH,QAAD,CAAvB;AACD;AACF;AACF;AACF;;AAED,SAASI,oBAAT,CAA8BC,IAA9B,EAA2C;AACzC,MAAIlB,OAAJ,EAAa;AACX,QAAIkB,IAAI,KAAKC,SAAT,IAAsBD,IAAI,KAAK,IAA/B,IAAuC,CAACE,KAAK,CAACC,OAAN,CAAcH,IAAd,CAA5C,EAAiE;AAC/D;AACA;AACAI,MAAAA,OAAO,CAACC,KAAR,CACE,sFACE,iDAFJ,EAGEf,oBAHF,EAIE,OAAOU,IAJT;AAMD;AACF;AACF;;AAED,SAASF,uBAAT,CAAiCQ,eAAjC,EAA4D;AAC1D,MAAIxB,OAAJ,EAAa;AACX,UAAMyB,aAAa,GAAGpC,gBAAgB,CAACc,uBAAuB,CAACuB,IAAzB,CAAtC;;AACA,QAAI,CAAC3B,uCAAuC,CAAC4B,GAAxC,CAA4CF,aAA5C,CAAL,EAAiE;AAC/D1B,MAAAA,uCAAuC,CAAC6B,GAAxC,CAA4CH,aAA5C;;AAEA,UAAIhB,YAAY,KAAK,IAArB,EAA2B;AACzB,YAAIoB,KAAK,GAAG,EAAZ;AAEA,cAAMC,iBAAiB,GAAG,EAA1B;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAMrB,uBAAvB,EAA+DqB,CAAC,EAAhE,EAAoE;AAClE,gBAAMC,WAAW,GAAGvB,YAAY,CAACsB,CAAD,CAAhC;AACA,gBAAME,WAAW,GACfF,CAAC,KAAOrB,uBAAR,GACIc,eADJ,GAEIQ,WAHN;AAKA,cAAIE,GAAG,GAAI,GAAEH,CAAC,GAAG,CAAE,KAAIC,WAAY,EAAnC,CAPkE,CASlE;AACA;;AACA,iBAAOE,GAAG,CAACC,MAAJ,GAAaL,iBAApB,EAAuC;AACrCI,YAAAA,GAAG,IAAI,GAAP;AACD;;AAEDA,UAAAA,GAAG,IAAID,WAAW,GAAG,IAArB;AAEAJ,UAAAA,KAAK,IAAIK,GAAT;AACD;;AAEDZ,QAAAA,OAAO,CAACC,KAAR,CACE,qEACE,kDADF,GAEE,iFAFF,GAGE,6CAHF,GAIE,6DAJF,GAKE,IALF,GAME,6DAPJ,EAQEE,aARF,EASEI,KATF;AAWD;AACF;AACF;AACF;;AAED,SAASO,qBAAT,GAAiC;AAC/BhD,EAAAA,SAAS,CACP,KADO,EAEP,kHACE,kCADF,GAEE,wFAFF,GAGE,+CAHF,GAIE,iEAJF,GAKE,6FAPK,CAAT;AASD;;AAED,SAASiD,kBAAT,CACEC,QADF,EAEEC,QAFF,EAGE;AACA,MAAIvC,OAAJ,EAAa;AACX,QAAIW,0BAAJ,EAAgC;AAC9B;AACA,aAAO,KAAP;AACD;AACF;;AAED,MAAI4B,QAAQ,KAAK,IAAjB,EAAuB;AACrB,QAAIvC,OAAJ,EAAa;AACXsB,MAAAA,OAAO,CAACC,KAAR,CACE,qEACE,mEADF,GAEE,yCAHJ,EAIEf,oBAJF;AAMD;;AACD,WAAO,KAAP;AACD;;AAED,MAAIR,OAAJ,EAAa;AACX;AACA;AACA,QAAIsC,QAAQ,CAACH,MAAT,KAAoBI,QAAQ,CAACJ,MAAjC,EAAyC;AACvCb,MAAAA,OAAO,CAACC,KAAR,CACE,uEACE,wDADF,GAEE,gBAFF,GAGE,cAJJ,EAKEf,oBALF,EAMG,IAAG+B,QAAQ,CAACC,IAAT,CAAc,IAAd,CAAoB,GAN1B,EAOG,IAAGF,QAAQ,CAACE,IAAT,CAAc,IAAd,CAAoB,GAP1B;AASD;AACF;;AACD,OAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,QAAQ,CAACJ,MAAb,IAAuBJ,CAAC,GAAGO,QAAQ,CAACH,MAApD,EAA4DJ,CAAC,EAA7D,EAAiE;AAC/D,QAAIzC,EAAE,CAACgD,QAAQ,CAACP,CAAD,CAAT,EAAcQ,QAAQ,CAACR,CAAD,CAAtB,CAAN,EAAkC;AAChC;AACD;;AACD,WAAO,KAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,OAAO,SAASU,eAAT,CACLC,OADK,EAELC,cAFK,EAGLC,SAHK,EAILC,KAJK,EAKLC,SALK,EAMLC,wBANK,EAOA;AACL7C,EAAAA,oBAAoB,GAAG6C,wBAAvB;AACA5C,EAAAA,uBAAuB,GAAGwC,cAA1B;;AAEA,MAAI3C,OAAJ,EAAa;AACXS,IAAAA,YAAY,GACViC,OAAO,KAAK,IAAZ,GACMA,OAAO,CAACM,eADd,GAEI,IAHN;AAIAtC,IAAAA,uBAAuB,GAAG,CAAC,CAA3B,CALW,CAMX;;AACAC,IAAAA,0BAA0B,GACxB+B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAAChB,IAAR,KAAiBiB,cAAc,CAACjB,IADtD;AAED;;AAEDiB,EAAAA,cAAc,CAACM,aAAf,GAA+B,IAA/B;AACAN,EAAAA,cAAc,CAACO,WAAf,GAA6B,IAA7B;AACAP,EAAAA,cAAc,CAACQ,cAAf,GAAgCpF,MAAhC,CAjBK,CAmBL;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AACA,MAAIiC,OAAJ,EAAa;AACX,QAAI0C,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACO,aAAR,KAA0B,IAAlD,EAAwD;AACtDpD,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCU,4BAAjC;AACD,KAFD,MAEO,IAAI3C,YAAY,KAAK,IAArB,EAA2B;AAChC;AACA;AACA;AACA;AACA;AACAZ,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCW,wCAAjC;AACD,KAPM,MAOA;AACLxD,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCY,2BAAjC;AACD;AACF,GAbD,MAaO;AACLzD,IAAAA,sBAAsB,CAAC6C,OAAvB,GACEA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,CAACO,aAAR,KAA0B,IAA9C,GACIM,sBADJ,GAEIC,uBAHN;AAID;;AAED,MAAIC,QAAQ,GAAGb,SAAS,CAACC,KAAD,EAAQC,SAAR,CAAxB,CApDK,CAsDL;;AACA,MAAIH,cAAc,CAACQ,cAAf,KAAkCjD,oBAAtC,EAA4D;AAC1D;AACA;AACA,QAAIwD,iBAAyB,GAAG,CAAhC;;AACA,OAAG;AACDf,MAAAA,cAAc,CAACQ,cAAf,GAAgCpF,MAAhC;AAEAqB,MAAAA,SAAS,CACPsE,iBAAiB,GAAGnD,eADb,EAEP,wEACE,mBAHK,CAAT;AAMAmD,MAAAA,iBAAiB,IAAI,CAArB;;AACA,UAAI1D,OAAJ,EAAa;AACX;AACA;AACAW,QAAAA,0BAA0B,GAAG,KAA7B;AACD,OAdA,CAgBD;;;AACAP,MAAAA,WAAW,GAAG,IAAd;AACAC,MAAAA,kBAAkB,GAAG,IAArB;AAEAsC,MAAAA,cAAc,CAACO,WAAf,GAA6B,IAA7B;;AAEA,UAAIlD,OAAJ,EAAa;AACX;AACAU,QAAAA,uBAAuB,GAAG,CAAC,CAA3B;AACD;;AAEDb,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC1C,OAAO,GACpC2D,8BADoC,GAEpCC,yBAFJ;AAIAH,MAAAA,QAAQ,GAAGb,SAAS,CAACC,KAAD,EAAQC,SAAR,CAApB;AACD,KAhCD,QAgCSH,cAAc,CAACQ,cAAf,KAAkCjD,oBAhC3C;AAiCD,GA5FI,CA8FL;AACA;;;AACAL,EAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCmB,qBAAjC;;AAEA,MAAI7D,OAAJ,EAAa;AACX2C,IAAAA,cAAc,CAACK,eAAf,GAAiCvC,YAAjC;AACD,GApGI,CAsGL;AACA;;;AACA,QAAMqD,oBAAoB,GACxB1D,WAAW,KAAK,IAAhB,IAAwBA,WAAW,CAAC2D,IAAZ,KAAqB,IAD/C;AAGA7D,EAAAA,oBAAoB,GAAGnC,MAAvB;AACAoC,EAAAA,uBAAuB,GAAI,IAA3B;AAEAC,EAAAA,WAAW,GAAG,IAAd;AACAC,EAAAA,kBAAkB,GAAG,IAArB;;AAEA,MAAIL,OAAJ,EAAa;AACXQ,IAAAA,oBAAoB,GAAG,IAAvB;AACAC,IAAAA,YAAY,GAAG,IAAf;AACAC,IAAAA,uBAAuB,GAAG,CAAC,CAA3B;AACD;;AAEDJ,EAAAA,4BAA4B,GAAG,KAA/B;AAEAlB,EAAAA,SAAS,CACP,CAAC0E,oBADM,EAEP,6EACE,yBAHK,CAAT;AAMA,SAAOL,QAAP;AACD;AAED,OAAO,SAASO,YAAT,CACLtB,OADK,EAELC,cAFK,EAGLQ,cAHK,EAIL;AACAR,EAAAA,cAAc,CAACO,WAAf,GAA6BR,OAAO,CAACQ,WAArC;AACAP,EAAAA,cAAc,CAACsB,SAAf,IAA4B,EAAE3F,aAAa,GAAGF,YAAlB,CAA5B;;AACA,MAAIsE,OAAO,CAACS,cAAR,IAA0BA,cAA9B,EAA8C;AAC5CT,IAAAA,OAAO,CAACS,cAAR,GAAyBpF,MAAzB;AACD;AACF;AAED,OAAO,SAASmG,oBAAT,GAAsC;AAC3C;AACA;AACArE,EAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCmB,qBAAjC;;AAEA,MAAIvD,4BAAJ,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAI6D,IAAiB,GAAGhE,uBAAuB,CAAC8C,aAAhD;;AACA,WAAOkB,IAAI,KAAK,IAAhB,EAAsB;AACpB,YAAMC,KAAK,GAAGD,IAAI,CAACC,KAAnB;;AACA,UAAIA,KAAK,KAAK,IAAd,EAAoB;AAClBA,QAAAA,KAAK,CAACC,OAAN,GAAgB,IAAhB;AACD;;AACDF,MAAAA,IAAI,GAAGA,IAAI,CAACJ,IAAZ;AACD;AACF;;AAED7D,EAAAA,oBAAoB,GAAGnC,MAAvB;AACAoC,EAAAA,uBAAuB,GAAI,IAA3B;AAEAC,EAAAA,WAAW,GAAG,IAAd;AACAC,EAAAA,kBAAkB,GAAG,IAArB;;AAEA,MAAIL,OAAJ,EAAa;AACXS,IAAAA,YAAY,GAAG,IAAf;AACAC,IAAAA,uBAAuB,GAAG,CAAC,CAA3B;AAEAF,IAAAA,oBAAoB,GAAG,IAAvB;AACD;;AAEDF,EAAAA,4BAA4B,GAAG,KAA/B;AACD;;AAED,SAASgE,uBAAT,GAAyC;AACvC,QAAMH,IAAU,GAAG;AACjBlB,IAAAA,aAAa,EAAE,IADE;AAGjBsB,IAAAA,SAAS,EAAE,IAHM;AAIjBC,IAAAA,SAAS,EAAE,IAJM;AAKjBJ,IAAAA,KAAK,EAAE,IALU;AAOjBL,IAAAA,IAAI,EAAE;AAPW,GAAnB;;AAUA,MAAI1D,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B;AACAF,IAAAA,uBAAuB,CAAC8C,aAAxB,GAAwC5C,kBAAkB,GAAG8D,IAA7D;AACD,GAHD,MAGO;AACL;AACA9D,IAAAA,kBAAkB,GAAGA,kBAAkB,CAAC0D,IAAnB,GAA0BI,IAA/C;AACD;;AACD,SAAO9D,kBAAP;AACD;;AAED,SAASoE,wBAAT,GAA0C;AACxC;AACA;AACA;AACA;AACA;AACA,MAAIC,eAAJ;;AACA,MAAItE,WAAW,KAAK,IAApB,EAA0B;AACxB,QAAIsC,OAAO,GAAGvC,uBAAuB,CAACwE,SAAtC;;AACA,QAAIjC,OAAO,KAAK,IAAhB,EAAsB;AACpBgC,MAAAA,eAAe,GAAGhC,OAAO,CAACO,aAA1B;AACD,KAFD,MAEO;AACLyB,MAAAA,eAAe,GAAG,IAAlB;AACD;AACF,GAPD,MAOO;AACLA,IAAAA,eAAe,GAAGtE,WAAW,CAAC2D,IAA9B;AACD;;AAED,MAAIa,sBAAJ;;AACA,MAAIvE,kBAAkB,KAAK,IAA3B,EAAiC;AAC/BuE,IAAAA,sBAAsB,GAAGzE,uBAAuB,CAAC8C,aAAjD;AACD,GAFD,MAEO;AACL2B,IAAAA,sBAAsB,GAAGvE,kBAAkB,CAAC0D,IAA5C;AACD;;AAED,MAAIa,sBAAsB,KAAK,IAA/B,EAAqC;AACnC;AACAvE,IAAAA,kBAAkB,GAAGuE,sBAArB;AACAA,IAAAA,sBAAsB,GAAGvE,kBAAkB,CAAC0D,IAA5C;AAEA3D,IAAAA,WAAW,GAAGsE,eAAd;AACD,GAND,MAMO;AACL;AAEAtF,IAAAA,SAAS,CACPsF,eAAe,KAAK,IADb,EAEP,sDAFO,CAAT;AAIAtE,IAAAA,WAAW,GAAGsE,eAAd;AAEA,UAAMG,OAAa,GAAG;AACpB5B,MAAAA,aAAa,EAAE7C,WAAW,CAAC6C,aADP;AAGpBsB,MAAAA,SAAS,EAAEnE,WAAW,CAACmE,SAHH;AAIpBC,MAAAA,SAAS,EAAEpE,WAAW,CAACoE,SAJH;AAKpBJ,MAAAA,KAAK,EAAEhE,WAAW,CAACgE,KALC;AAOpBL,MAAAA,IAAI,EAAE;AAPc,KAAtB;;AAUA,QAAI1D,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B;AACAF,MAAAA,uBAAuB,CAAC8C,aAAxB,GAAwC5C,kBAAkB,GAAGwE,OAA7D;AACD,KAHD,MAGO;AACL;AACAxE,MAAAA,kBAAkB,GAAGA,kBAAkB,CAAC0D,IAAnB,GAA0Bc,OAA/C;AACD;AACF;;AACD,SAAOxE,kBAAP;AACD;;AAED,SAASyE,kCAAT,GAA4E;AAC1E,SAAO;AACLC,IAAAA,UAAU,EAAE;AADP,GAAP;AAGD;;AAED,SAASC,iBAAT,CAA8BC,KAA9B,EAAwCC,MAAxC,EAAwE;AACtE;AACA,SAAO,OAAOA,MAAP,KAAkB,UAAlB,GAA+BA,MAAM,CAACD,KAAD,CAArC,GAA+CC,MAAtD;AACD;;AAED,SAASC,YAAT,CACEC,OADF,EAEEC,UAFF,EAGEC,IAHF,EAIoB;AAClB,QAAMnB,IAAI,GAAGG,uBAAuB,EAApC;AACA,MAAIiB,YAAJ;;AACA,MAAID,IAAI,KAAKnE,SAAb,EAAwB;AACtBoE,IAAAA,YAAY,GAAGD,IAAI,CAACD,UAAD,CAAnB;AACD,GAFD,MAEO;AACLE,IAAAA,YAAY,GAAKF,UAAjB;AACD;;AACDlB,EAAAA,IAAI,CAAClB,aAAL,GAAqBkB,IAAI,CAACI,SAAL,GAAiBgB,YAAtC;AACA,QAAMnB,KAAK,GAAID,IAAI,CAACC,KAAL,GAAa;AAC1BC,IAAAA,OAAO,EAAE,IADiB;AAE1BmB,IAAAA,QAAQ,EAAE,IAFgB;AAG1BC,IAAAA,mBAAmB,EAAEL,OAHK;AAI1BM,IAAAA,iBAAiB,EAAGH;AAJM,GAA5B;AAMA,QAAMC,QAAqB,GAAIpB,KAAK,CAACoB,QAAN,GAAkBG,cAAc,CAACC,IAAf,CAC/C,IAD+C,EAE/CzF,uBAF+C,EAG/CiE,KAH+C,CAAjD;AAKA,SAAO,CAACD,IAAI,CAAClB,aAAN,EAAqBuC,QAArB,CAAP;AACD;;AAED,SAASK,aAAT,CACET,OADF,EAEEC,UAFF,EAGEC,IAHF,EAIoB;AAClB,QAAMnB,IAAI,GAAGM,wBAAwB,EAArC;AACA,QAAML,KAAK,GAAGD,IAAI,CAACC,KAAnB;AACAhF,EAAAA,SAAS,CACPgF,KAAK,KAAK,IADH,EAEP,2EAFO,CAAT;AAKAA,EAAAA,KAAK,CAACqB,mBAAN,GAA4BL,OAA5B;AAEA,QAAM1C,OAAa,GAAItC,WAAvB,CAVkB,CAYlB;;AACA,MAAIoE,SAAS,GAAG9B,OAAO,CAAC8B,SAAxB,CAbkB,CAelB;;AACA,MAAIsB,YAAY,GAAG1B,KAAK,CAACC,OAAzB;;AACA,MAAIyB,YAAY,KAAK,IAArB,EAA2B;AACzB;AACA;AACA,QAAItB,SAAS,KAAK,IAAlB,EAAwB;AACtB;AACA,UAAIuB,SAAS,GAAGvB,SAAS,CAACT,IAA1B;AACA,UAAIiC,YAAY,GAAGF,YAAY,CAAC/B,IAAhC;AACAS,MAAAA,SAAS,CAACT,IAAV,GAAiBiC,YAAjB;AACAF,MAAAA,YAAY,CAAC/B,IAAb,GAAoBgC,SAApB;AACD;;AACDrD,IAAAA,OAAO,CAAC8B,SAAR,GAAoBA,SAAS,GAAGsB,YAAhC;AACA1B,IAAAA,KAAK,CAACC,OAAN,GAAgB,IAAhB;AACD;;AAED,MAAIG,SAAS,KAAK,IAAlB,EAAwB;AACtB;AACA,QAAIyB,KAAK,GAAGzB,SAAS,CAACT,IAAtB;AACA,QAAImC,QAAQ,GAAGxD,OAAO,CAAC6B,SAAvB;AAEA,QAAI4B,YAAY,GAAG,IAAnB;AACA,QAAIC,iBAAiB,GAAG,IAAxB;AACA,QAAIC,gBAAgB,GAAG,IAAvB;AACA,QAAIC,MAAM,GAAGL,KAAb;;AACA,OAAG;AACD,YAAMM,oBAAoB,GAAGD,MAAM,CAACnD,cAApC;;AACA,UAAIoD,oBAAoB,GAAGrG,oBAA3B,EAAiD;AAC/C;AACA;AACA;AACA,cAAMsG,KAAmB,GAAG;AAC1BrD,UAAAA,cAAc,EAAEmD,MAAM,CAACnD,cADG;AAE1BsD,UAAAA,cAAc,EAAEH,MAAM,CAACG,cAFG;AAG1BvB,UAAAA,MAAM,EAAEoB,MAAM,CAACpB,MAHW;AAI1BwB,UAAAA,YAAY,EAAEJ,MAAM,CAACI,YAJK;AAK1BC,UAAAA,UAAU,EAAEL,MAAM,CAACK,UALO;AAM1B5C,UAAAA,IAAI,EAAG;AANmB,SAA5B;;AAQA,YAAIsC,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BD,UAAAA,iBAAiB,GAAGC,gBAAgB,GAAGG,KAAvC;AACAL,UAAAA,YAAY,GAAGD,QAAf;AACD,SAHD,MAGO;AACLG,UAAAA,gBAAgB,GAAGA,gBAAgB,CAACtC,IAAjB,GAAwByC,KAA3C;AACD,SAjB8C,CAkB/C;;;AACA,YAAID,oBAAoB,GAAGpG,uBAAuB,CAACgD,cAAnD,EAAmE;AACjEhD,UAAAA,uBAAuB,CAACgD,cAAxB,GAAyCoD,oBAAzC;AACApH,UAAAA,yBAAyB,CAACoH,oBAAD,CAAzB;AACD;AACF,OAvBD,MAuBO;AACL;AAEA,YAAIF,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,gBAAMG,KAAmB,GAAG;AAC1BrD,YAAAA,cAAc,EAAEnF,IADU;AACJ;AACtByI,YAAAA,cAAc,EAAEH,MAAM,CAACG,cAFG;AAG1BvB,YAAAA,MAAM,EAAEoB,MAAM,CAACpB,MAHW;AAI1BwB,YAAAA,YAAY,EAAEJ,MAAM,CAACI,YAJK;AAK1BC,YAAAA,UAAU,EAAEL,MAAM,CAACK,UALO;AAM1B5C,YAAAA,IAAI,EAAG;AANmB,WAA5B;AAQAsC,UAAAA,gBAAgB,GAAGA,gBAAgB,CAACtC,IAAjB,GAAwByC,KAA3C;AACD,SAbI,CAeL;AACA;AACA;AACA;AACA;AACA;;;AACAtH,QAAAA,4BAA4B,CAC1BqH,oBAD0B,EAE1BD,MAAM,CAACG,cAFmB,CAA5B,CArBK,CA0BL;;AACA,YAAIH,MAAM,CAACI,YAAP,KAAwBtB,OAA5B,EAAqC;AACnC;AACA;AACAc,UAAAA,QAAQ,GAAKI,MAAM,CAACK,UAApB;AACD,SAJD,MAIO;AACL,gBAAMzB,MAAM,GAAGoB,MAAM,CAACpB,MAAtB;AACAgB,UAAAA,QAAQ,GAAGd,OAAO,CAACc,QAAD,EAAWhB,MAAX,CAAlB;AACD;AACF;;AACDoB,MAAAA,MAAM,GAAGA,MAAM,CAACvC,IAAhB;AACD,KA9DD,QA8DSuC,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKL,KA9DvC;;AAgEA,QAAII,gBAAgB,KAAK,IAAzB,EAA+B;AAC7BF,MAAAA,YAAY,GAAGD,QAAf;AACD,KAFD,MAEO;AACLG,MAAAA,gBAAgB,CAACtC,IAAjB,GAAyBqC,iBAAzB;AACD,KA7EqB,CA+EtB;AACA;;;AACA,QAAI,CAAC9G,EAAE,CAAC4G,QAAD,EAAW/B,IAAI,CAAClB,aAAhB,CAAP,EAAuC;AACrC1D,MAAAA,gCAAgC;AACjC;;AAED4E,IAAAA,IAAI,CAAClB,aAAL,GAAqBiD,QAArB;AACA/B,IAAAA,IAAI,CAACI,SAAL,GAAiB4B,YAAjB;AACAhC,IAAAA,IAAI,CAACK,SAAL,GAAiB6B,gBAAjB;AAEAjC,IAAAA,KAAK,CAACsB,iBAAN,GAA0BQ,QAA1B;AACD;;AAED,QAAMV,QAAqB,GAAIpB,KAAK,CAACoB,QAArC;AACA,SAAO,CAACrB,IAAI,CAAClB,aAAN,EAAqBuC,QAArB,CAAP;AACD;;AAED,SAASoB,eAAT,CACExB,OADF,EAEEC,UAFF,EAGEC,IAHF,EAIoB;AAClB,QAAMnB,IAAI,GAAGM,wBAAwB,EAArC;AACA,QAAML,KAAK,GAAGD,IAAI,CAACC,KAAnB;AACAhF,EAAAA,SAAS,CACPgF,KAAK,KAAK,IADH,EAEP,2EAFO,CAAT;AAKAA,EAAAA,KAAK,CAACqB,mBAAN,GAA4BL,OAA5B,CARkB,CAUlB;AACA;;AACA,QAAMI,QAAqB,GAAIpB,KAAK,CAACoB,QAArC;AACA,QAAMqB,qBAAqB,GAAGzC,KAAK,CAACC,OAApC;AACA,MAAI6B,QAAQ,GAAG/B,IAAI,CAAClB,aAApB;;AACA,MAAI4D,qBAAqB,KAAK,IAA9B,EAAoC;AAClC;AACAzC,IAAAA,KAAK,CAACC,OAAN,GAAgB,IAAhB;AAEA,UAAMyC,sBAAsB,GAAGD,qBAAqB,CAAC9C,IAArD;AACA,QAAIuC,MAAM,GAAGQ,sBAAb;;AACA,OAAG;AACD;AACA;AACA;AACA,YAAM5B,MAAM,GAAGoB,MAAM,CAACpB,MAAtB;AACAgB,MAAAA,QAAQ,GAAGd,OAAO,CAACc,QAAD,EAAWhB,MAAX,CAAlB;AACAoB,MAAAA,MAAM,GAAGA,MAAM,CAACvC,IAAhB;AACD,KAPD,QAOSuC,MAAM,KAAKQ,sBAPpB,EANkC,CAelC;AACA;;;AACA,QAAI,CAACxH,EAAE,CAAC4G,QAAD,EAAW/B,IAAI,CAAClB,aAAhB,CAAP,EAAuC;AACrC1D,MAAAA,gCAAgC;AACjC;;AAED4E,IAAAA,IAAI,CAAClB,aAAL,GAAqBiD,QAArB,CArBkC,CAsBlC;AACA;AACA;AACA;;AACA,QAAI/B,IAAI,CAACK,SAAL,KAAmB,IAAvB,EAA6B;AAC3BL,MAAAA,IAAI,CAACI,SAAL,GAAiB2B,QAAjB;AACD;;AAED9B,IAAAA,KAAK,CAACsB,iBAAN,GAA0BQ,QAA1B;AACD;;AACD,SAAO,CAACA,QAAD,EAAWV,QAAX,CAAP;AACD;;AAED,SAASuB,UAAT,CACExB,YADF,EAEsC;AACpC,QAAMpB,IAAI,GAAGG,uBAAuB,EAApC;;AACA,MAAI,OAAOiB,YAAP,KAAwB,UAA5B,EAAwC;AACtC;AACAA,IAAAA,YAAY,GAAGA,YAAY,EAA3B;AACD;;AACDpB,EAAAA,IAAI,CAAClB,aAAL,GAAqBkB,IAAI,CAACI,SAAL,GAAiBgB,YAAtC;AACA,QAAMnB,KAAK,GAAID,IAAI,CAACC,KAAL,GAAa;AAC1BC,IAAAA,OAAO,EAAE,IADiB;AAE1BmB,IAAAA,QAAQ,EAAE,IAFgB;AAG1BC,IAAAA,mBAAmB,EAAET,iBAHK;AAI1BU,IAAAA,iBAAiB,EAAGH;AAJM,GAA5B;AAMA,QAAMC,QAEL,GAAIpB,KAAK,CAACoB,QAAN,GAAkBG,cAAc,CAACC,IAAf,CACrB,IADqB,EAErBzF,uBAFqB,EAGrBiE,KAHqB,CAFvB;AAOA,SAAO,CAACD,IAAI,CAAClB,aAAN,EAAqBuC,QAArB,CAAP;AACD;;AAED,SAASwB,WAAT,CACEzB,YADF,EAEsC;AACpC,SAAOM,aAAa,CAACb,iBAAD,EAAqBO,YAArB,CAApB;AACD;;AAED,SAAS0B,aAAT,CACE1B,YADF,EAEsC;AACpC,SAAOqB,eAAe,CAAC5B,iBAAD,EAAqBO,YAArB,CAAtB;AACD;;AAED,SAAS2B,UAAT,CAAoBC,GAApB,EAAyBC,MAAzB,EAAiCC,OAAjC,EAA0CnG,IAA1C,EAAgD;AAC9C,QAAMoG,MAAc,GAAG;AACrBH,IAAAA,GADqB;AAErBC,IAAAA,MAFqB;AAGrBC,IAAAA,OAHqB;AAIrBnG,IAAAA,IAJqB;AAKrB;AACA6C,IAAAA,IAAI,EAAG;AANc,GAAvB;AAQA,MAAIwD,oBAAyD,GAAIpH,uBAAuB,CAAC+C,WAAzF;;AACA,MAAIqE,oBAAoB,KAAK,IAA7B,EAAmC;AACjCA,IAAAA,oBAAoB,GAAGzC,kCAAkC,EAAzD;AACA3E,IAAAA,uBAAuB,CAAC+C,WAAxB,GAAuCqE,oBAAvC;AACAA,IAAAA,oBAAoB,CAACxC,UAArB,GAAkCuC,MAAM,CAACvD,IAAP,GAAcuD,MAAhD;AACD,GAJD,MAIO;AACL,UAAMvC,UAAU,GAAGwC,oBAAoB,CAACxC,UAAxC;;AACA,QAAIA,UAAU,KAAK,IAAnB,EAAyB;AACvBwC,MAAAA,oBAAoB,CAACxC,UAArB,GAAkCuC,MAAM,CAACvD,IAAP,GAAcuD,MAAhD;AACD,KAFD,MAEO;AACL,YAAME,WAAW,GAAGzC,UAAU,CAAChB,IAA/B;AACAgB,MAAAA,UAAU,CAAChB,IAAX,GAAkBuD,MAAlB;AACAA,MAAAA,MAAM,CAACvD,IAAP,GAAcyD,WAAd;AACAD,MAAAA,oBAAoB,CAACxC,UAArB,GAAkCuC,MAAlC;AACD;AACF;;AACD,SAAOA,MAAP;AACD;;AAED,SAASG,QAAT,CAAqBC,YAArB,EAAsD;AACpD,QAAMvD,IAAI,GAAGG,uBAAuB,EAApC;AACA,QAAMqD,GAAG,GAAG;AAACjF,IAAAA,OAAO,EAAEgF;AAAV,GAAZ;;AACA,MAAI1H,OAAJ,EAAa;AACX4H,IAAAA,MAAM,CAACC,IAAP,CAAYF,GAAZ;AACD;;AACDxD,EAAAA,IAAI,CAAClB,aAAL,GAAqB0E,GAArB;AACA,SAAOA,GAAP;AACD;;AAED,SAASG,SAAT,CAAsBJ,YAAtB,EAAuD;AACrD,QAAMvD,IAAI,GAAGM,wBAAwB,EAArC;AACA,SAAON,IAAI,CAAClB,aAAZ;AACD;;AAED,SAAS8E,eAAT,CAAyBC,cAAzB,EAAyCC,aAAzC,EAAwDb,MAAxD,EAAgElG,IAAhE,EAA4E;AAC1E,QAAMiD,IAAI,GAAGG,uBAAuB,EAApC;AACA,QAAMhC,QAAQ,GAAGpB,IAAI,KAAKC,SAAT,GAAqB,IAArB,GAA4BD,IAA7C;AACAf,EAAAA,uBAAuB,CAAC8D,SAAxB,IAAqC+D,cAArC;AACA7D,EAAAA,IAAI,CAAClB,aAAL,GAAqBiE,UAAU,CAC7B1I,aAAa,GAAGyJ,aADa,EAE7Bb,MAF6B,EAG7BjG,SAH6B,EAI7BmB,QAJ6B,CAA/B;AAMD;;AAED,SAAS4F,gBAAT,CAA0BF,cAA1B,EAA0CC,aAA1C,EAAyDb,MAAzD,EAAiElG,IAAjE,EAA6E;AAC3E,QAAMiD,IAAI,GAAGM,wBAAwB,EAArC;AACA,QAAMnC,QAAQ,GAAGpB,IAAI,KAAKC,SAAT,GAAqB,IAArB,GAA4BD,IAA7C;AACA,MAAImG,OAAO,GAAGlG,SAAd;;AAEA,MAAIf,WAAW,KAAK,IAApB,EAA0B;AACxB,UAAM+H,UAAU,GAAG/H,WAAW,CAAC6C,aAA/B;AACAoE,IAAAA,OAAO,GAAGc,UAAU,CAACd,OAArB;;AACA,QAAI/E,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAMC,QAAQ,GAAG4F,UAAU,CAACjH,IAA5B;;AACA,UAAImB,kBAAkB,CAACC,QAAD,EAAWC,QAAX,CAAtB,EAA4C;AAC1C2E,QAAAA,UAAU,CAACe,aAAD,EAAgBb,MAAhB,EAAwBC,OAAxB,EAAiC/E,QAAjC,CAAV;AACA;AACD;AACF;AACF;;AAEDnC,EAAAA,uBAAuB,CAAC8D,SAAxB,IAAqC+D,cAArC;AAEA7D,EAAAA,IAAI,CAAClB,aAAL,GAAqBiE,UAAU,CAC7B1I,aAAa,GAAGyJ,aADa,EAE7Bb,MAF6B,EAG7BC,OAH6B,EAI7B/E,QAJ6B,CAA/B;AAMD;;AAED,SAAS8F,WAAT,CACEhB,MADF,EAEElG,IAFF,EAGQ;AACN,MAAIlB,OAAJ,EAAa;AACX;AACA,QAAI,gBAAgB,OAAOqI,IAA3B,EAAiC;AAC/BtJ,MAAAA,oCAAoC,CAACoB,uBAAD,CAApC;AACD;AACF;;AACD,SAAO4H,eAAe,CACpB3J,YAAY,GAAGE,aADK,EAEpBK,WAFoB,EAGpByI,MAHoB,EAIpBlG,IAJoB,CAAtB;AAMD;;AAED,SAASoH,YAAT,CACElB,MADF,EAEElG,IAFF,EAGQ;AACN,MAAIlB,OAAJ,EAAa;AACX;AACA,QAAI,gBAAgB,OAAOqI,IAA3B,EAAiC;AAC/BtJ,MAAAA,oCAAoC,CAACoB,uBAAD,CAApC;AACD;AACF;;AACD,SAAO+H,gBAAgB,CACrB9J,YAAY,GAAGE,aADM,EAErBK,WAFqB,EAGrByI,MAHqB,EAIrBlG,IAJqB,CAAvB;AAMD;;AAED,SAASqH,iBAAT,CACEnB,MADF,EAEElG,IAFF,EAGQ;AACN,SAAO6G,eAAe,CAAC3J,YAAD,EAAeM,UAAf,EAA2B0I,MAA3B,EAAmClG,IAAnC,CAAtB;AACD;;AAED,SAASsH,kBAAT,CACEpB,MADF,EAEElG,IAFF,EAGQ;AACN,SAAOgH,gBAAgB,CAAC9J,YAAD,EAAeM,UAAf,EAA2B0I,MAA3B,EAAmClG,IAAnC,CAAvB;AACD;;AAED,SAASuH,sBAAT,CACErB,MADF,EAEEO,GAFF,EAGE;AACA,MAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7B,UAAMe,WAAW,GAAGf,GAApB;AACA,UAAMgB,IAAI,GAAGvB,MAAM,EAAnB;AACAsB,IAAAA,WAAW,CAACC,IAAD,CAAX;AACA,WAAO,MAAM;AACXD,MAAAA,WAAW,CAAC,IAAD,CAAX;AACD,KAFD;AAGD,GAPD,MAOO,IAAIf,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAKxG,SAA5B,EAAuC;AAC5C,UAAMyH,SAAS,GAAGjB,GAAlB;;AACA,QAAI3H,OAAJ,EAAa;AACX,UAAI,CAAC4I,SAAS,CAACC,cAAV,CAAyB,SAAzB,CAAL,EAA0C;AACxCvH,QAAAA,OAAO,CAACC,KAAR,CACE,kEACE,iEAFJ,EAGE,0BAA0BqG,MAAM,CAACkB,IAAP,CAAYF,SAAZ,EAAuBpG,IAAvB,CAA4B,IAA5B,CAA1B,GAA8D,GAHhE;AAKD;AACF;;AACD,UAAMmG,IAAI,GAAGvB,MAAM,EAAnB;AACAwB,IAAAA,SAAS,CAAClG,OAAV,GAAoBiG,IAApB;AACA,WAAO,MAAM;AACXC,MAAAA,SAAS,CAAClG,OAAV,GAAoB,IAApB;AACD,KAFD;AAGD;AACF;;AAED,SAASqG,qBAAT,CACEpB,GADF,EAEEP,MAFF,EAGElG,IAHF,EAIQ;AACN,MAAIlB,OAAJ,EAAa;AACX,QAAI,OAAOoH,MAAP,KAAkB,UAAtB,EAAkC;AAChC9F,MAAAA,OAAO,CAACC,KAAR,CACE,qEACE,8CAFJ,EAGE6F,MAAM,KAAK,IAAX,GAAkB,OAAOA,MAAzB,GAAkC,MAHpC;AAKD;AACF,GATK,CAWN;;;AACA,QAAM4B,UAAU,GACd9H,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAKC,SAA1B,GAAsCD,IAAI,CAAC+H,MAAL,CAAY,CAACtB,GAAD,CAAZ,CAAtC,GAA2D,IAD7D;AAGA,SAAOI,eAAe,CACpB3J,YADoB,EAEpBM,UAFoB,EAGpB+J,sBAAsB,CAAC7C,IAAvB,CAA4B,IAA5B,EAAkCwB,MAAlC,EAA0CO,GAA1C,CAHoB,EAIpBqB,UAJoB,CAAtB;AAMD;;AAED,SAASE,sBAAT,CACEvB,GADF,EAEEP,MAFF,EAGElG,IAHF,EAIQ;AACN,MAAIlB,OAAJ,EAAa;AACX,QAAI,OAAOoH,MAAP,KAAkB,UAAtB,EAAkC;AAChC9F,MAAAA,OAAO,CAACC,KAAR,CACE,qEACE,8CAFJ,EAGE6F,MAAM,KAAK,IAAX,GAAkB,OAAOA,MAAzB,GAAkC,MAHpC;AAKD;AACF,GATK,CAWN;;;AACA,QAAM4B,UAAU,GACd9H,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAKC,SAA1B,GAAsCD,IAAI,CAAC+H,MAAL,CAAY,CAACtB,GAAD,CAAZ,CAAtC,GAA2D,IAD7D;AAGA,SAAOO,gBAAgB,CACrB9J,YADqB,EAErBM,UAFqB,EAGrB+J,sBAAsB,CAAC7C,IAAvB,CAA4B,IAA5B,EAAkCwB,MAAlC,EAA0CO,GAA1C,CAHqB,EAIrBqB,UAJqB,CAAvB;AAMD;;AAED,SAASG,eAAT,CAA4BC,KAA5B,EAAsCC,WAAtC,EAA+E,CAC7E;AACA;AACA;AACD;;AAED,MAAMC,gBAAgB,GAAGH,eAAzB;;AAEA,SAASI,aAAT,CAA0BC,QAA1B,EAAuCtI,IAAvC,EAA4E;AAC1E,QAAMiD,IAAI,GAAGG,uBAAuB,EAApC;AACA,QAAMhC,QAAQ,GAAGpB,IAAI,KAAKC,SAAT,GAAqB,IAArB,GAA4BD,IAA7C;AACAiD,EAAAA,IAAI,CAAClB,aAAL,GAAqB,CAACuG,QAAD,EAAWlH,QAAX,CAArB;AACA,SAAOkH,QAAP;AACD;;AAED,SAASC,cAAT,CAA2BD,QAA3B,EAAwCtI,IAAxC,EAA6E;AAC3E,QAAMiD,IAAI,GAAGM,wBAAwB,EAArC;AACA,QAAMnC,QAAQ,GAAGpB,IAAI,KAAKC,SAAT,GAAqB,IAArB,GAA4BD,IAA7C;AACA,QAAMwI,SAAS,GAAGvF,IAAI,CAAClB,aAAvB;;AACA,MAAIyG,SAAS,KAAK,IAAlB,EAAwB;AACtB,QAAIpH,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAMC,QAA6B,GAAGmH,SAAS,CAAC,CAAD,CAA/C;;AACA,UAAIrH,kBAAkB,CAACC,QAAD,EAAWC,QAAX,CAAtB,EAA4C;AAC1C,eAAOmH,SAAS,CAAC,CAAD,CAAhB;AACD;AACF;AACF;;AACDvF,EAAAA,IAAI,CAAClB,aAAL,GAAqB,CAACuG,QAAD,EAAWlH,QAAX,CAArB;AACA,SAAOkH,QAAP;AACD;;AAED,SAASG,SAAT,CACEC,UADF,EAEE1I,IAFF,EAGK;AACH,QAAMiD,IAAI,GAAGG,uBAAuB,EAApC;AACA,QAAMhC,QAAQ,GAAGpB,IAAI,KAAKC,SAAT,GAAqB,IAArB,GAA4BD,IAA7C;AACA,QAAM2I,SAAS,GAAGD,UAAU,EAA5B;AACAzF,EAAAA,IAAI,CAAClB,aAAL,GAAqB,CAAC4G,SAAD,EAAYvH,QAAZ,CAArB;AACA,SAAOuH,SAAP;AACD;;AAED,SAASC,UAAT,CACEF,UADF,EAEE1I,IAFF,EAGK;AACH,QAAMiD,IAAI,GAAGM,wBAAwB,EAArC;AACA,QAAMnC,QAAQ,GAAGpB,IAAI,KAAKC,SAAT,GAAqB,IAArB,GAA4BD,IAA7C;AACA,QAAMwI,SAAS,GAAGvF,IAAI,CAAClB,aAAvB;;AACA,MAAIyG,SAAS,KAAK,IAAlB,EAAwB;AACtB;AACA,QAAIpH,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAMC,QAA6B,GAAGmH,SAAS,CAAC,CAAD,CAA/C;;AACA,UAAIrH,kBAAkB,CAACC,QAAD,EAAWC,QAAX,CAAtB,EAA4C;AAC1C,eAAOmH,SAAS,CAAC,CAAD,CAAhB;AACD;AACF;AACF;;AACD,QAAMG,SAAS,GAAGD,UAAU,EAA5B;AACAzF,EAAAA,IAAI,CAAClB,aAAL,GAAqB,CAAC4G,SAAD,EAAYvH,QAAZ,CAArB;AACA,SAAOuH,SAAP;AACD;;AAED,SAASE,kBAAT,CACEX,KADF,EAEEY,MAFF,EAGK;AACH,QAAM,CAACC,SAAD,EAAYC,QAAZ,IAAwBnD,UAAU,CAACqC,KAAD,CAAxC;AACAhB,EAAAA,WAAW,CAAC,MAAM;AAChB,UAAM+B,cAAc,GAAGrK,uBAAuB,CAACsK,QAA/C;AACAtK,IAAAA,uBAAuB,CAACsK,QAAxB,GAAmCJ,MAAM,KAAK7I,SAAX,GAAuB,IAAvB,GAA8B6I,MAAjE;;AACA,QAAI;AACFE,MAAAA,QAAQ,CAACd,KAAD,CAAR;AACD,KAFD,SAEU;AACRtJ,MAAAA,uBAAuB,CAACsK,QAAxB,GAAmCD,cAAnC;AACD;AACF,GARU,EAQR,CAACf,KAAD,EAAQY,MAAR,CARQ,CAAX;AASA,SAAOC,SAAP;AACD;;AAED,SAASI,mBAAT,CACEjB,KADF,EAEEY,MAFF,EAGK;AACH,QAAM,CAACC,SAAD,EAAYC,QAAZ,IAAwBlD,WAAW,CAACoC,KAAD,CAAzC;AACAd,EAAAA,YAAY,CAAC,MAAM;AACjB,UAAM6B,cAAc,GAAGrK,uBAAuB,CAACsK,QAA/C;AACAtK,IAAAA,uBAAuB,CAACsK,QAAxB,GAAmCJ,MAAM,KAAK7I,SAAX,GAAuB,IAAvB,GAA8B6I,MAAjE;;AACA,QAAI;AACFE,MAAAA,QAAQ,CAACd,KAAD,CAAR;AACD,KAFD,SAEU;AACRtJ,MAAAA,uBAAuB,CAACsK,QAAxB,GAAmCD,cAAnC;AACD;AACF,GARW,EAQT,CAACf,KAAD,EAAQY,MAAR,CARS,CAAZ;AASA,SAAOC,SAAP;AACD;;AAED,SAASK,qBAAT,CACElB,KADF,EAEEY,MAFF,EAGK;AACH,QAAM,CAACC,SAAD,EAAYC,QAAZ,IAAwBjD,aAAa,CAACmC,KAAD,CAA3C;AACAd,EAAAA,YAAY,CAAC,MAAM;AACjB,UAAM6B,cAAc,GAAGrK,uBAAuB,CAACsK,QAA/C;AACAtK,IAAAA,uBAAuB,CAACsK,QAAxB,GAAmCJ,MAAM,KAAK7I,SAAX,GAAuB,IAAvB,GAA8B6I,MAAjE;;AACA,QAAI;AACFE,MAAAA,QAAQ,CAACd,KAAD,CAAR;AACD,KAFD,SAEU;AACRtJ,MAAAA,uBAAuB,CAACsK,QAAxB,GAAmCD,cAAnC;AACD;AACF,GARW,EAQT,CAACf,KAAD,EAAQY,MAAR,CARS,CAAZ;AASA,SAAOC,SAAP;AACD;;AAED,SAASM,eAAT,CAAyBC,UAAzB,EAAqCR,MAArC,EAA6CR,QAA7C,EAAuD;AACrD,QAAMiB,aAAa,GAAG7K,uBAAuB,EAA7C;AACAD,EAAAA,eAAe,CACb8K,aAAa,GAAGhL,oBAAhB,GAAuCA,oBAAvC,GAA8DgL,aADjD,EAEb,MAAM;AACJD,IAAAA,UAAU,CAAC,IAAD,CAAV;AACD,GAJY,CAAf;AAMA7K,EAAAA,eAAe,CACb8K,aAAa,GAAG/K,cAAhB,GAAiCA,cAAjC,GAAkD+K,aADrC,EAEb,MAAM;AACJ,UAAMN,cAAc,GAAGrK,uBAAuB,CAACsK,QAA/C;AACAtK,IAAAA,uBAAuB,CAACsK,QAAxB,GAAmCJ,MAAM,KAAK7I,SAAX,GAAuB,IAAvB,GAA8B6I,MAAjE;;AACA,QAAI;AACFQ,MAAAA,UAAU,CAAC,KAAD,CAAV;AACAhB,MAAAA,QAAQ;AACT,KAHD,SAGU;AACR1J,MAAAA,uBAAuB,CAACsK,QAAxB,GAAmCD,cAAnC;AACD;AACF,GAXY,CAAf;AAaD;;AAED,SAASO,eAAT,CACEV,MADF,EAEmC;AACjC,QAAM,CAACW,SAAD,EAAYH,UAAZ,IAA0BzD,UAAU,CAAC,KAAD,CAA1C;AACA,QAAM6D,KAAK,GAAGrB,aAAa,CAACgB,eAAe,CAAC3E,IAAhB,CAAqB,IAArB,EAA2B4E,UAA3B,EAAuCR,MAAvC,CAAD,EAAiD,CAC1EQ,UAD0E,EAE1ER,MAF0E,CAAjD,CAA3B;AAIA,SAAO,CAACY,KAAD,EAAQD,SAAR,CAAP;AACD;;AAED,SAASE,gBAAT,CACEb,MADF,EAEmC;AACjC,QAAM,CAACW,SAAD,EAAYH,UAAZ,IAA0BxD,WAAW,CAAC,KAAD,CAA3C;AACA,QAAM4D,KAAK,GAAGnB,cAAc,CAACc,eAAe,CAAC3E,IAAhB,CAAqB,IAArB,EAA2B4E,UAA3B,EAAuCR,MAAvC,CAAD,EAAiD,CAC3EQ,UAD2E,EAE3ER,MAF2E,CAAjD,CAA5B;AAIA,SAAO,CAACY,KAAD,EAAQD,SAAR,CAAP;AACD;;AAED,SAASG,kBAAT,CACEd,MADF,EAEmC;AACjC,QAAM,CAACW,SAAD,EAAYH,UAAZ,IAA0BvD,aAAa,CAAC,KAAD,CAA7C;AACA,QAAM2D,KAAK,GAAGnB,cAAc,CAACc,eAAe,CAAC3E,IAAhB,CAAqB,IAArB,EAA2B4E,UAA3B,EAAuCR,MAAvC,CAAD,EAAiD,CAC3EQ,UAD2E,EAE3ER,MAF2E,CAAjD,CAA5B;AAIA,SAAO,CAACY,KAAD,EAAQD,SAAR,CAAP;AACD;;AAED,SAAShF,cAAT,CACEoF,KADF,EAEE3G,KAFF,EAGEc,MAHF,EAIE;AACA,MAAIlF,OAAJ,EAAa;AACX,QAAI,OAAOgL,SAAS,CAAC,CAAD,CAAhB,KAAwB,UAA5B,EAAwC;AACtC1J,MAAAA,OAAO,CAACC,KAAR,CACE,gFACE,2DADF,GAEE,+DAHJ;AAKD;AACF;;AAED,QAAM0J,WAAW,GAAGnM,2BAA2B,EAA/C;AACA,QAAM2H,cAAc,GAAGjH,4BAA4B,EAAnD;AACA,QAAM2D,cAAc,GAAGtE,yBAAyB,CAC9CoM,WAD8C,EAE9CF,KAF8C,EAG9CtE,cAH8C,CAAhD;AAMA,QAAMH,MAAoB,GAAG;AAC3BnD,IAAAA,cAD2B;AAE3BsD,IAAAA,cAF2B;AAG3BvB,IAAAA,MAH2B;AAI3BwB,IAAAA,YAAY,EAAE,IAJa;AAK3BC,IAAAA,UAAU,EAAE,IALe;AAM3B5C,IAAAA,IAAI,EAAG;AANoB,GAA7B;;AASA,MAAI/D,OAAJ,EAAa;AACXsG,IAAAA,MAAM,CAAC4E,QAAP,GAAkBtL,uBAAuB,EAAzC;AACD,GA9BD,CAgCA;;;AACA,QAAMyE,OAAO,GAAGD,KAAK,CAACC,OAAtB;;AACA,MAAIA,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACAiC,IAAAA,MAAM,CAACvC,IAAP,GAAcuC,MAAd;AACD,GAHD,MAGO;AACLA,IAAAA,MAAM,CAACvC,IAAP,GAAcM,OAAO,CAACN,IAAtB;AACAM,IAAAA,OAAO,CAACN,IAAR,GAAeuC,MAAf;AACD;;AACDlC,EAAAA,KAAK,CAACC,OAAN,GAAgBiC,MAAhB;AAEA,QAAM3B,SAAS,GAAGoG,KAAK,CAACpG,SAAxB;;AACA,MACEoG,KAAK,KAAK5K,uBAAV,IACCwE,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKxE,uBAFvC,EAGE;AACA;AACA;AACA;AACAG,IAAAA,4BAA4B,GAAG,IAA/B;AACAgG,IAAAA,MAAM,CAACnD,cAAP,GAAwBjD,oBAAxB;AACAC,IAAAA,uBAAuB,CAACgD,cAAxB,GAAyCjD,oBAAzC;AACD,GAVD,MAUO;AACL,QACE6K,KAAK,CAAC5H,cAAN,KAAyBpF,MAAzB,KACC4G,SAAS,KAAK,IAAd,IAAsBA,SAAS,CAACxB,cAAV,KAA6BpF,MADpD,CADF,EAGE;AACA;AACA;AACA;AACA,YAAM0H,mBAAmB,GAAGrB,KAAK,CAACqB,mBAAlC;;AACA,UAAIA,mBAAmB,KAAK,IAA5B,EAAkC;AAChC,YAAI0F,cAAJ;;AACA,YAAInL,OAAJ,EAAa;AACXmL,UAAAA,cAAc,GAAGtL,sBAAsB,CAAC6C,OAAxC;AACA7C,UAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;AACD;;AACD,YAAI;AACF,gBAAMC,YAAe,GAAIjH,KAAK,CAACsB,iBAA/B;AACA,gBAAMiB,UAAU,GAAGlB,mBAAmB,CAAC4F,YAAD,EAAenG,MAAf,CAAtC,CAFE,CAGF;AACA;AACA;AACA;;AACAoB,UAAAA,MAAM,CAACI,YAAP,GAAsBjB,mBAAtB;AACAa,UAAAA,MAAM,CAACK,UAAP,GAAoBA,UAApB;;AACA,cAAIrH,EAAE,CAACqH,UAAD,EAAa0E,YAAb,CAAN,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACD;AACF,SAhBD,CAgBE,OAAO9J,KAAP,EAAc,CACd;AACD,SAlBD,SAkBU;AACR,cAAIvB,OAAJ,EAAa;AACXH,YAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF;AACF;AACF;;AACD,QAAInL,OAAJ,EAAa;AACX;AACA,UAAI,gBAAgB,OAAOqI,IAA3B,EAAiC;AAC/BpJ,QAAAA,8BAA8B,CAAC8L,KAAD,CAA9B;AACA/L,QAAAA,oCAAoC,CAAC+L,KAAD,CAApC;AACD;AACF;;AACDnM,IAAAA,YAAY,CAACmM,KAAD,EAAQ5H,cAAR,CAAZ;AACD;AACF;;AAED,OAAO,MAAMU,qBAAiC,GAAG;AAC/C5F,EAAAA,WAD+C;AAG/CqN,EAAAA,WAAW,EAAElJ,qBAHkC;AAI/CmJ,EAAAA,UAAU,EAAEnJ,qBAJmC;AAK/CoJ,EAAAA,SAAS,EAAEpJ,qBALoC;AAM/CqJ,EAAAA,mBAAmB,EAAErJ,qBAN0B;AAO/CsJ,EAAAA,eAAe,EAAEtJ,qBAP8B;AAQ/CuJ,EAAAA,OAAO,EAAEvJ,qBARsC;AAS/CwJ,EAAAA,UAAU,EAAExJ,qBATmC;AAU/CyJ,EAAAA,MAAM,EAAEzJ,qBAVuC;AAW/C0J,EAAAA,QAAQ,EAAE1J,qBAXqC;AAY/C2J,EAAAA,aAAa,EAAE3J,qBAZgC;AAa/C4J,EAAAA,YAAY,EAAE5J,qBAbiC;AAc/C6J,EAAAA,gBAAgB,EAAE7J,qBAd6B;AAe/C8J,EAAAA,aAAa,EAAE9J;AAfgC,CAA1C;AAkBP,MAAMmB,sBAAkC,GAAG;AACzCtF,EAAAA,WADyC;AAGzCqN,EAAAA,WAAW,EAAE/B,aAH4B;AAIzCgC,EAAAA,UAAU,EAAEtN,WAJ6B;AAKzCuN,EAAAA,SAAS,EAAEpD,WAL8B;AAMzCqD,EAAAA,mBAAmB,EAAE1C,qBANoB;AAOzC2C,EAAAA,eAAe,EAAEnD,iBAPwB;AAQzCoD,EAAAA,OAAO,EAAEhC,SARgC;AASzCiC,EAAAA,UAAU,EAAEzG,YAT6B;AAUzC0G,EAAAA,MAAM,EAAEpE,QAViC;AAWzCqE,EAAAA,QAAQ,EAAE/E,UAX+B;AAYzCgF,EAAAA,aAAa,EAAE5C,eAZ0B;AAazC6C,EAAAA,YAAY,EAAE9N,iCAb2B;AAczC+N,EAAAA,gBAAgB,EAAElC,kBAduB;AAezCmC,EAAAA,aAAa,EAAExB;AAf0B,CAA3C;AAkBA,MAAMlH,uBAAmC,GAAG;AAC1CvF,EAAAA,WAD0C;AAG1CqN,EAAAA,WAAW,EAAE7B,cAH6B;AAI1C8B,EAAAA,UAAU,EAAEtN,WAJ8B;AAK1CuN,EAAAA,SAAS,EAAElD,YAL+B;AAM1CmD,EAAAA,mBAAmB,EAAEvC,sBANqB;AAO1CwC,EAAAA,eAAe,EAAElD,kBAPyB;AAQ1CmD,EAAAA,OAAO,EAAE7B,UARiC;AAS1C8B,EAAAA,UAAU,EAAE/F,aAT8B;AAU1CgG,EAAAA,MAAM,EAAE/D,SAVkC;AAW1CgE,EAAAA,QAAQ,EAAE9E,WAXgC;AAY1C+E,EAAAA,aAAa,EAAEzC,gBAZ2B;AAa1C0C,EAAAA,YAAY,EAAE9N,iCAb4B;AAc1C+N,EAAAA,gBAAgB,EAAE5B,mBAdwB;AAe1C6B,EAAAA,aAAa,EAAErB;AAf2B,CAA5C;AAkBA,MAAMjH,yBAAqC,GAAG;AAC5C3F,EAAAA,WAD4C;AAG5CqN,EAAAA,WAAW,EAAE7B,cAH+B;AAI5C8B,EAAAA,UAAU,EAAEtN,WAJgC;AAK5CuN,EAAAA,SAAS,EAAElD,YALiC;AAM5CmD,EAAAA,mBAAmB,EAAEvC,sBANuB;AAO5CwC,EAAAA,eAAe,EAAElD,kBAP2B;AAQ5CmD,EAAAA,OAAO,EAAE7B,UARmC;AAS5C8B,EAAAA,UAAU,EAAEhF,eATgC;AAU5CiF,EAAAA,MAAM,EAAE/D,SAVoC;AAW5CgE,EAAAA,QAAQ,EAAE7E,aAXkC;AAY5C8E,EAAAA,aAAa,EAAEzC,gBAZ6B;AAa5C0C,EAAAA,YAAY,EAAE9N,iCAb8B;AAc5C+N,EAAAA,gBAAgB,EAAE3B,qBAd0B;AAe5C4B,EAAAA,aAAa,EAAEpB;AAf6B,CAA9C;AAkBA,IAAIxH,2BAA8C,GAAG,IAArD;AACA,IAAID,wCAA2D,GAAG,IAAlE;AACA,IAAID,4BAA+C,GAAG,IAAtD;AACA,IAAIO,8BAAiD,GAAG,IAAxD;AACA,IAAIwI,wCAA2D,GAAG,IAAlE;AACA,IAAIf,yCAA4D,GAAG,IAAnE;AACA,IAAIgB,2CAA8D,GAAG,IAArE;;AAEA,IAAIpM,OAAJ,EAAa;AACX,QAAMqM,wBAAwB,GAAG,MAAM;AACrC/K,IAAAA,OAAO,CAACC,KAAR,CACE,wDACE,gFADF,GAEE,iFAFF,GAGE,8CAJJ;AAMD,GAPD;;AASA,QAAM+K,qBAAqB,GAAG,MAAM;AAClChL,IAAAA,OAAO,CAACC,KAAR,CACE,qFACE,mEADF,GAEE,4BAFF,GAGE,8BAJJ;AAMD,GAPD;;AASA+B,EAAAA,2BAA2B,GAAG;AAC5BrF,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACH,aAAOvO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAN2B;;AAQ5BlB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACAI,MAAAA,iBAAiB;AACjBK,MAAAA,oBAAoB,CAACC,IAAD,CAApB;AACA,aAAOqI,aAAa,CAACC,QAAD,EAAWtI,IAAX,CAApB;AACD,KAb2B;;AAc5BqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACAI,MAAAA,iBAAiB;AACjB,aAAO3C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KArB2B;;AAsB5BhB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACAI,MAAAA,iBAAiB;AACjBK,MAAAA,oBAAoB,CAACC,IAAD,CAApB;AACA,aAAOkH,WAAW,CAAChB,MAAD,EAASlG,IAAT,CAAlB;AACD,KA9B2B;;AA+B5BuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACAI,MAAAA,iBAAiB;AACjBK,MAAAA,oBAAoB,CAACC,IAAD,CAApB;AACA,aAAO6H,qBAAqB,CAACpB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA5B;AACD,KAxC2B;;AAyC5BwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACAI,MAAAA,iBAAiB;AACjBK,MAAAA,oBAAoB,CAACC,IAAD,CAApB;AACA,aAAOqH,iBAAiB,CAACnB,MAAD,EAASlG,IAAT,CAAxB;AACD,KAjD2B;;AAkD5ByK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACAI,MAAAA,iBAAiB;AACjBK,MAAAA,oBAAoB,CAACC,IAAD,CAApB;AACA,YAAMiK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOxC,SAAS,CAACvC,MAAD,EAASlG,IAAT,CAAhB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA7D2B;;AA8D5BS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACAI,MAAAA,iBAAiB;AACjB,YAAMuK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOhH,YAAY,CAACC,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAAnB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA5E2B;;AA6E5BU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACAI,MAAAA,iBAAiB;AACjB,aAAO6G,QAAQ,CAACC,YAAD,CAAf;AACD,KAjF2B;;AAkF5BoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACAI,MAAAA,iBAAiB;AACjB,YAAMuK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOpF,UAAU,CAACxB,YAAD,CAAjB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA9F2B;;AA+F5BY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACAI,MAAAA,iBAAiB;AACjB,aAAOuI,eAAe,CAACC,KAAD,EAAQC,WAAR,CAAtB;AACD,KAnG2B;;AAoG5B2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACAI,MAAAA,iBAAiB;AACjB,aAAO1C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KA3G2B;;AA4G5BoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACAI,MAAAA,iBAAiB;AACjB,aAAOmJ,kBAAkB,CAACX,KAAD,EAAQY,MAAR,CAAzB;AACD,KAhH2B;;AAiH5BkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACAI,MAAAA,iBAAiB;AACjB,aAAO8J,eAAe,CAACV,MAAD,CAAtB;AACD;;AAvH2B,GAA9B;AA0HA3G,EAAAA,wCAAwC,GAAG;AACzCpF,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACH,aAAOvO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KANwC;;AAQzClB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOwI,aAAa,CAACC,QAAD,EAAWtI,IAAX,CAApB;AACD,KAZwC;;AAazCqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO9C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KApBwC;;AAqBzChB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOqH,WAAW,CAAChB,MAAD,EAASlG,IAAT,CAAlB;AACD,KA5BwC;;AA6BzCuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOgI,qBAAqB,CAACpB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA5B;AACD,KArCwC;;AAsCzCwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOwH,iBAAiB,CAACnB,MAAD,EAASlG,IAAT,CAAxB;AACD,KA7CwC;;AA8CzCyK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOxC,SAAS,CAACvC,MAAD,EAASlG,IAAT,CAAhB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAxDwC;;AAyDzCS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOhH,YAAY,CAACC,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAAnB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAvEwC;;AAwEzCU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO0G,QAAQ,CAACC,YAAD,CAAf;AACD,KA5EwC;;AA6EzCoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOpF,UAAU,CAACxB,YAAD,CAAjB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAzFwC;;AA0FzCY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOoI,eAAe,CAACC,KAAD,EAAQC,WAAR,CAAtB;AACD,KA9FwC;;AA+FzC2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO7C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KAtGwC;;AAuGzCoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOgJ,kBAAkB,CAACX,KAAD,EAAQY,MAAR,CAAzB;AACD,KA3GwC;;AA4GzCkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO2J,eAAe,CAACV,MAAD,CAAtB;AACD;;AAlHwC,GAA3C;AAqHA5G,EAAAA,4BAA4B,GAAG;AAC7BnF,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACH,aAAOvO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAN4B;;AAQ7BlB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO0I,cAAc,CAACD,QAAD,EAAWtI,IAAX,CAArB;AACD,KAZ4B;;AAa7BqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO9C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KApB4B;;AAqB7BhB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOuH,YAAY,CAAClB,MAAD,EAASlG,IAAT,CAAnB;AACD,KA5B4B;;AA6B7BuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOmI,sBAAsB,CAACvB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA7B;AACD,KArC4B;;AAsC7BwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOyH,kBAAkB,CAACpB,MAAD,EAASlG,IAAT,CAAzB;AACD,KA7C4B;;AA8C7ByK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOtB,UAAU,CAAC1C,MAAD,EAASlG,IAAT,CAAjB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAxD4B;;AAyD7BS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOvF,aAAa,CAACT,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAApB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAvE4B;;AAwE7BU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO+G,SAAS,CAACJ,YAAD,CAAhB;AACD,KA5E4B;;AA6E7BoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOpE,WAAW,CAACzB,YAAD,CAAlB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAzF4B;;AA0F7BY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOuI,gBAAgB,CAACF,KAAD,EAAQC,WAAR,CAAvB;AACD,KA9F4B;;AA+F7B2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO7C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KAtG4B;;AAuG7BoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOsJ,mBAAmB,CAACjB,KAAD,EAAQY,MAAR,CAA1B;AACD,KA3G4B;;AA4G7BkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO8J,gBAAgB,CAACb,MAAD,CAAvB;AACD;;AAlH4B,GAA/B;AAqHArG,EAAAA,8BAA8B,GAAG;AAC/B1F,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACH,aAAOvO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAN8B;;AAQ/BlB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO0I,cAAc,CAACD,QAAD,EAAWtI,IAAX,CAArB;AACD,KAZ8B;;AAa/BqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO9C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KApB8B;;AAqB/BhB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOuH,YAAY,CAAClB,MAAD,EAASlG,IAAT,CAAnB;AACD,KA5B8B;;AA6B/BuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOmI,sBAAsB,CAACvB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA7B;AACD,KArC8B;;AAsC/BwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOyH,kBAAkB,CAACpB,MAAD,EAASlG,IAAT,CAAzB;AACD,KA7C8B;;AA8C/ByK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0J,2CAAjC;;AACA,UAAI;AACF,eAAOtC,UAAU,CAAC1C,MAAD,EAASlG,IAAT,CAAjB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAxD8B;;AAyD/BS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0J,2CAAjC;;AACA,UAAI;AACF,eAAOxF,eAAe,CAACxB,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAAtB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAvE8B;;AAwE/BU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO+G,SAAS,CAACJ,YAAD,CAAhB;AACD,KA5E8B;;AA6E/BoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACAO,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0J,2CAAjC;;AACA,UAAI;AACF,eAAOnF,aAAa,CAAC1B,YAAD,CAApB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAzF8B;;AA0F/BY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOuI,gBAAgB,CAACF,KAAD,EAAQC,WAAR,CAAvB;AACD,KA9F8B;;AA+F/B2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO7C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KAtG8B;;AAuG/BoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAOuJ,qBAAqB,CAAClB,KAAD,EAAQY,MAAR,CAA5B;AACD,KA3G8B;;AA4G/BkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACAO,MAAAA,kBAAkB;AAClB,aAAO+J,kBAAkB,CAACd,MAAD,CAAzB;AACD;;AAlH8B,GAAjC;AAqHAmC,EAAAA,wCAAwC,GAAG;AACzClO,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACHH,MAAAA,wBAAwB;AACxB,aAAOpO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAPwC;;AASzClB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAO2I,aAAa,CAACC,QAAD,EAAWtI,IAAX,CAApB;AACD,KAdwC;;AAezCqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAO3C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAvBwC;;AAwBzChB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAOwH,WAAW,CAAChB,MAAD,EAASlG,IAAT,CAAlB;AACD,KAhCwC;;AAiCzCuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAOmI,qBAAqB,CAACpB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA5B;AACD,KA1CwC;;AA2CzCwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAO2H,iBAAiB,CAACnB,MAAD,EAASlG,IAAT,CAAxB;AACD,KAnDwC;;AAoDzCyK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,YAAMuK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOxC,SAAS,CAACvC,MAAD,EAASlG,IAAT,CAAhB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA/DwC;;AAgEzCS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,YAAMuK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOhH,YAAY,CAACC,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAAnB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA/EwC;;AAgFzCU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAO6G,QAAQ,CAACC,YAAD,CAAf;AACD,KArFwC;;AAsFzCoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,YAAMuK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyJ,wCAAjC;;AACA,UAAI;AACF,eAAOpF,UAAU,CAACxB,YAAD,CAAjB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAnGwC;;AAoGzCY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAOuI,eAAe,CAACC,KAAD,EAAQC,WAAR,CAAtB;AACD,KAzGwC;;AA0GzC2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAO1C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KAlHwC;;AAmHzCoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAOmJ,kBAAkB,CAACX,KAAD,EAAQY,MAAR,CAAzB;AACD,KAxHwC;;AAyHzCkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACA8L,MAAAA,qBAAqB;AACrB1L,MAAAA,iBAAiB;AACjB,aAAO8J,eAAe,CAACV,MAAD,CAAtB;AACD;;AAhIwC,GAA3C;AAmIAoB,EAAAA,yCAAyC,GAAG;AAC1CnN,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACHH,MAAAA,wBAAwB;AACxB,aAAOpO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAPyC;;AAS1ClB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO0I,cAAc,CAACD,QAAD,EAAWtI,IAAX,CAArB;AACD,KAdyC;;AAe1CqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO9C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAvByC;;AAwB1ChB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOuH,YAAY,CAAClB,MAAD,EAASlG,IAAT,CAAnB;AACD,KAhCyC;;AAiC1CuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOmI,sBAAsB,CAACvB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA7B;AACD,KA1CyC;;AA2C1CwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOyH,kBAAkB,CAACpB,MAAD,EAASlG,IAAT,CAAzB;AACD,KAnDyC;;AAoD1CyK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOtB,UAAU,CAAC1C,MAAD,EAASlG,IAAT,CAAjB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA/DyC;;AAgE1CS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOvF,aAAa,CAACT,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAApB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA/EyC;;AAgF1CU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO+G,SAAS,CAACJ,YAAD,CAAhB;AACD,KArFyC;;AAsF1CoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOpE,WAAW,CAACzB,YAAD,CAAlB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAnGyC;;AAoG1CY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOuI,gBAAgB,CAACF,KAAD,EAAQC,WAAR,CAAvB;AACD,KAzGyC;;AA0G1C2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO7C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KAlHyC;;AAmH1CoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOsJ,mBAAmB,CAACjB,KAAD,EAAQY,MAAR,CAA1B;AACD,KAxHyC;;AAyH1CkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO8J,gBAAgB,CAACb,MAAD,CAAvB;AACD;;AAhIyC,GAA5C;AAmIAoC,EAAAA,2CAA2C,GAAG;AAC5CnO,IAAAA,WAAW,CACTsO,OADS,EAETC,YAFS,EAGN;AACHH,MAAAA,wBAAwB;AACxB,aAAOpO,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAP2C;;AAS5ClB,IAAAA,WAAW,CAAI9B,QAAJ,EAAiBtI,IAAjB,EAAsD;AAC/DV,MAAAA,oBAAoB,GAAG,aAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO0I,cAAc,CAACD,QAAD,EAAWtI,IAAX,CAArB;AACD,KAd2C;;AAe5CqK,IAAAA,UAAU,CACRgB,OADQ,EAERC,YAFQ,EAGL;AACHhM,MAAAA,oBAAoB,GAAG,YAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO9C,WAAW,CAACsO,OAAD,EAAUC,YAAV,CAAlB;AACD,KAvB2C;;AAwB5ChB,IAAAA,SAAS,CACPpE,MADO,EAEPlG,IAFO,EAGD;AACNV,MAAAA,oBAAoB,GAAG,WAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOuH,YAAY,CAAClB,MAAD,EAASlG,IAAT,CAAnB;AACD,KAhC2C;;AAiC5CuK,IAAAA,mBAAmB,CACjB9D,GADiB,EAEjBP,MAFiB,EAGjBlG,IAHiB,EAIX;AACNV,MAAAA,oBAAoB,GAAG,qBAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOmI,sBAAsB,CAACvB,GAAD,EAAMP,MAAN,EAAclG,IAAd,CAA7B;AACD,KA1C2C;;AA2C5CwK,IAAAA,eAAe,CACbtE,MADa,EAEblG,IAFa,EAGP;AACNV,MAAAA,oBAAoB,GAAG,iBAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOyH,kBAAkB,CAACpB,MAAD,EAASlG,IAAT,CAAzB;AACD,KAnD2C;;AAoD5CyK,IAAAA,OAAO,CAAIvE,MAAJ,EAAqBlG,IAArB,EAA0D;AAC/DV,MAAAA,oBAAoB,GAAG,SAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOtB,UAAU,CAAC1C,MAAD,EAASlG,IAAT,CAAjB;AACD,OAFD,SAEU;AACRrB,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA/D2C;;AAgE5CS,IAAAA,UAAU,CACRxG,OADQ,EAERC,UAFQ,EAGRC,IAHQ,EAIU;AAClB9E,MAAAA,oBAAoB,GAAG,YAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOxE,eAAe,CAACxB,OAAD,EAAUC,UAAV,EAAsBC,IAAtB,CAAtB;AACD,OAFD,SAEU;AACRzF,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KA/E2C;;AAgF5CU,IAAAA,MAAM,CAAInE,YAAJ,EAAqC;AACzClH,MAAAA,oBAAoB,GAAG,QAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO+G,SAAS,CAACJ,YAAD,CAAhB;AACD,KArF2C;;AAsF5CoE,IAAAA,QAAQ,CACNvG,YADM,EAE8B;AACpC/E,MAAAA,oBAAoB,GAAG,UAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,YAAMoK,cAAc,GAAGtL,sBAAsB,CAAC6C,OAA9C;AACA7C,MAAAA,sBAAsB,CAAC6C,OAAvB,GAAiC0I,yCAAjC;;AACA,UAAI;AACF,eAAOnE,aAAa,CAAC1B,YAAD,CAApB;AACD,OAFD,SAEU;AACR1F,QAAAA,sBAAsB,CAAC6C,OAAvB,GAAiCyI,cAAjC;AACD;AACF,KAnG2C;;AAoG5CY,IAAAA,aAAa,CAAI3C,KAAJ,EAAcC,WAAd,EAAuD;AAClE7I,MAAAA,oBAAoB,GAAG,eAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOuI,gBAAgB,CAACF,KAAD,EAAQC,WAAR,CAAvB;AACD,KAzG2C;;AA0G5C2C,IAAAA,YAAY,CACVS,SADU,EAEV5J,KAFU,EAGyB;AACnCrC,MAAAA,oBAAoB,GAAG,cAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO7C,iCAAiC,CAACuO,SAAD,EAAY5J,KAAZ,CAAxC;AACD,KAlH2C;;AAmH5CoJ,IAAAA,gBAAgB,CAAI7C,KAAJ,EAAcY,MAAd,EAAsD;AACpExJ,MAAAA,oBAAoB,GAAG,kBAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAOuJ,qBAAqB,CAAClB,KAAD,EAAQY,MAAR,CAA5B;AACD,KAxH2C;;AAyH5CkC,IAAAA,aAAa,CACXlC,MADW,EAEsB;AACjCxJ,MAAAA,oBAAoB,GAAG,eAAvB;AACA8L,MAAAA,qBAAqB;AACrBvL,MAAAA,kBAAkB;AAClB,aAAO+J,kBAAkB,CAACd,MAAD,CAAzB;AACD;;AAhI2C,GAA9C;AAkID","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactEventResponder,\n  ReactContext,\n  ReactEventResponderListener,\n} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {HookEffectTag} from './ReactHookEffectTags';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {NoWork, Sync} from './ReactFiberExpirationTime';\nimport {readContext} from './ReactFiberNewContext';\nimport {createDeprecatedResponderListener} from './ReactFiberDeprecatedEvents';\nimport {\n  Update as UpdateEffect,\n  Passive as PassiveEffect,\n} from 'shared/ReactSideEffectTags';\nimport {\n  HasEffect as HookHasEffect,\n  Layout as HookLayout,\n  Passive as HookPassive,\n} from './ReactHookEffectTags';\nimport {\n  scheduleWork,\n  computeExpirationForFiber,\n  requestCurrentTimeForUpdate,\n  warnIfNotCurrentlyActingEffectsInDEV,\n  warnIfNotCurrentlyActingUpdatesInDev,\n  warnIfNotScopedWithMatchingAct,\n  markRenderEventTimeAndConfig,\n  markUnprocessedUpdateTime,\n} from './ReactFiberWorkLoop';\n\nimport invariant from 'shared/invariant';\nimport getComponentName from 'shared/getComponentName';\nimport is from 'shared/objectIs';\nimport {markWorkInProgressReceivedUpdate} from './ReactFiberBeginWork';\nimport {requestCurrentSuspenseConfig} from './ReactFiberSuspenseConfig';\nimport {\n  UserBlockingPriority,\n  NormalPriority,\n  runWithPriority,\n  getCurrentPriorityLevel,\n} from './SchedulerWithReactIntegration';\n\nconst {ReactCurrentDispatcher, ReactCurrentBatchConfig} = ReactSharedInternals;\n\nexport type Dispatcher = {|\n  readContext<T>(\n    context: ReactContext<T>,\n    observedBits: void | number | boolean,\n  ): T,\n  useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],\n  useReducer<S, I, A>(\n    reducer: (S, A) => S,\n    initialArg: I,\n    init?: (I) => S,\n  ): [S, Dispatch<A>],\n  useContext<T>(\n    context: ReactContext<T>,\n    observedBits: void | number | boolean,\n  ): T,\n  useRef<T>(initialValue: T): {|current: T|},\n  useEffect(\n    create: () => (() => void) | void,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useLayoutEffect(\n    create: () => (() => void) | void,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useCallback<T>(callback: T, deps: Array<mixed> | void | null): T,\n  useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T,\n  useImperativeHandle<T>(\n    ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n    create: () => T,\n    deps: Array<mixed> | void | null,\n  ): void,\n  useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,\n  useResponder<E, C>(\n    responder: ReactEventResponder<E, C>,\n    props: Object,\n  ): ReactEventResponderListener<E, C>,\n  useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T,\n  useTransition(\n    config: SuspenseConfig | void | null,\n  ): [(() => void) => void, boolean],\n|};\n\ntype Update<S, A> = {|\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n  action: A,\n  eagerReducer: ((S, A) => S) | null,\n  eagerState: S | null,\n  next: Update<S, A>,\n  priority?: ReactPriorityLevel,\n|};\n\ntype UpdateQueue<S, A> = {|\n  pending: Update<S, A> | null,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n|};\n\nexport type HookType =\n  | 'useState'\n  | 'useReducer'\n  | 'useContext'\n  | 'useRef'\n  | 'useEffect'\n  | 'useLayoutEffect'\n  | 'useCallback'\n  | 'useMemo'\n  | 'useImperativeHandle'\n  | 'useDebugValue'\n  | 'useResponder'\n  | 'useDeferredValue'\n  | 'useTransition';\n\nlet didWarnAboutMismatchedHooksForComponent;\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\nexport type Hook = {|\n  memoizedState: any,\n  baseState: any,\n  baseQueue: Update<any, any> | null,\n  queue: UpdateQueue<any, any> | null,\n  next: Hook | null,\n|};\n\nexport type Effect = {|\n  tag: HookEffectTag,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | null,\n  next: Effect,\n|};\n\nexport type FunctionComponentUpdateQueue = {|lastEffect: Effect | null|};\n\nexport type TimeoutConfig = {|\n  timeoutMs: number,\n|};\n\ntype BasicStateAction<S> = (S => S) | S;\n\ntype Dispatch<A> = A => void;\n\n// These are set right before calling the component.\nlet renderExpirationTime: ExpirationTime = NoWork;\n// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nlet currentlyRenderingFiber: Fiber = (null: any);\n\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet currentHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\n\n// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nlet didScheduleRenderPhaseUpdate: boolean = false;\n\nconst RE_RENDER_LIMIT = 25;\n\n// In DEV, this is the name of the currently executing primitive hook\nlet currentHookNameInDev: ?HookType = null;\n\n// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nlet hookTypesDev: Array<HookType> | null = null;\nlet hookTypesUpdateIndexDev: number = -1;\n\n// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nlet ignorePreviousDependencies: boolean = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps: mixed) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error(\n        '%s received a final argument that is not an array (instead, received `%s`). When ' +\n          'specified, the final argument must be an array.',\n        currentHookNameInDev,\n        typeof deps,\n      );\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName: HookType) {\n  if (__DEV__) {\n    const componentName = getComponentName(currentlyRenderingFiber.type);\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= ((hookTypesUpdateIndexDev: any): number); i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName =\n            i === ((hookTypesUpdateIndexDev: any): number)\n              ? currentHookName\n              : oldHookName;\n\n          let row = `${i + 1}. ${oldHookName}`;\n\n          // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n\n          table += row;\n        }\n\n        console.error(\n          'React has detected a change in the order of Hooks called by %s. ' +\n            'This will lead to bugs and errors if not fixed. ' +\n            'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\\n\\n' +\n            '   Previous render            Next render\\n' +\n            '   ------------------------------------------------------\\n' +\n            '%s' +\n            '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',\n          componentName,\n          table,\n        );\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  invariant(\n    false,\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n      ' one of the following reasons:\\n' +\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n      '2. You might be breaking the Rules of Hooks\\n' +\n      '3. You might have more than one copy of React in the same app\\n' +\n      'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',\n  );\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error(\n        '%s received a final argument during this render, but not during ' +\n          'the previous render. Even though the final argument is optional, ' +\n          'its type cannot change between renders.',\n        currentHookNameInDev,\n      );\n    }\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error(\n        'The final argument passed to %s changed size between renders. The ' +\n          'order and size of this array must remain constant.\\n\\n' +\n          'Previous: %s\\n' +\n          'Incoming: %s',\n        currentHookNameInDev,\n        `[${prevDeps.join(', ')}]`,\n        `[${nextDeps.join(', ')}]`,\n      );\n    }\n  }\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function renderWithHooks(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  props: any,\n  secondArg: any,\n  nextRenderExpirationTime: ExpirationTime,\n): any {\n  renderExpirationTime = nextRenderExpirationTime;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n    // Used for hot reloading:\n    ignorePreviousDependencies =\n      current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.expirationTime = NoWork;\n\n  // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n\n  // didScheduleRenderPhaseUpdate = false;\n\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current =\n      current === null || current.memoizedState === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n\n  let children = Component(props, secondArg);\n\n  // Check if there was a render phase update\n  if (workInProgress.expirationTime === renderExpirationTime) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    let numberOfReRenders: number = 0;\n    do {\n      workInProgress.expirationTime = NoWork;\n\n      invariant(\n        numberOfReRenders < RE_RENDER_LIMIT,\n        'Too many re-renders. React limits the number of renders to prevent ' +\n          'an infinite loop.',\n      );\n\n      numberOfReRenders += 1;\n      if (__DEV__) {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      }\n\n      // Start over from the beginning of the list\n      currentHook = null;\n      workInProgressHook = null;\n\n      workInProgress.updateQueue = null;\n\n      if (__DEV__) {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher.current = __DEV__\n        ? HooksDispatcherOnRerenderInDEV\n        : HooksDispatcherOnRerender;\n\n      children = Component(props, secondArg);\n    } while (workInProgress.expirationTime === renderExpirationTime);\n  }\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  }\n\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n\n  invariant(\n    !didRenderTooFewHooks,\n    'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n      'early return statement.',\n  );\n\n  return children;\n}\n\nexport function bailoutHooks(\n  current: Fiber,\n  workInProgress: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.effectTag &= ~(PassiveEffect | UpdateEffect);\n  if (current.expirationTime <= expirationTime) {\n    current.expirationTime = NoWork;\n  }\n}\n\nexport function resetHooksAfterThrow(): void {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrancy.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook: Hook | null = currentlyRenderingFiber.memoizedState;\n    while (hook !== null) {\n      const queue = hook.queue;\n      if (queue !== null) {\n        queue.pending = null;\n      }\n      hook = hook.next;\n    }\n  }\n\n  renderExpirationTime = NoWork;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    currentHookNameInDev = null;\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n}\n\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook(): Hook {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook: null | Hook;\n  if (currentHook === null) {\n    let current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook: null | Hook;\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n\n    invariant(\n      nextCurrentHook !== null,\n      'Rendered more hooks than during the previous render.',\n    );\n    currentHook = nextCurrentHook;\n\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n\n      next: null,\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue {\n  return {\n    lastEffect: null,\n  };\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  });\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'Should have a queue. This is likely a bug in React. Please file an issue.',\n  );\n\n  queue.lastRenderedReducer = reducer;\n\n  const current: Hook = (currentHook: any);\n\n  // The last rebase update that is NOT part of the base state.\n  let baseQueue = current.baseQueue;\n\n  // The last pending update that hasn't been processed yet.\n  let pendingQueue = queue.pending;\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      let baseFirst = baseQueue.next;\n      let pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    let first = baseQueue.next;\n    let newState = current.baseState;\n\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n    do {\n      const updateExpirationTime = update.expirationTime;\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone: Update<S, A> = {\n          expirationTime: update.expirationTime,\n          suspenseConfig: update.suspenseConfig,\n          action: update.action,\n          eagerReducer: update.eagerReducer,\n          eagerState: update.eagerState,\n          next: (null: any),\n        };\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n        // Update the remaining priority in the queue.\n        if (updateExpirationTime > currentlyRenderingFiber.expirationTime) {\n          currentlyRenderingFiber.expirationTime = updateExpirationTime;\n          markUnprocessedUpdateTime(updateExpirationTime);\n        }\n      } else {\n        // This update does have sufficient priority.\n\n        if (newBaseQueueLast !== null) {\n          const clone: Update<S, A> = {\n            expirationTime: Sync, // This update is going to be committed so we never want uncommit it.\n            suspenseConfig: update.suspenseConfig,\n            action: update.action,\n            eagerReducer: update.eagerReducer,\n            eagerState: update.eagerState,\n            next: (null: any),\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n\n        // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markRenderEventTimeAndConfig(\n          updateExpirationTime,\n          update.suspenseConfig,\n        );\n\n        // Process this update.\n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          newState = ((update.eagerState: any): S);\n        } else {\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'Should have a queue. This is likely a bug in React. Please file an issue.',\n  );\n\n  queue.lastRenderedReducer = reducer;\n\n  // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate);\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = (hook.queue = {\n    pending: null,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  });\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\nfunction rerenderState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return rerenderReducer(basicStateReducer, (initialState: any));\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\nfunction mountRef<T>(initialValue: T): {|current: T|} {\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  hook.memoizedState = ref;\n  return ref;\n}\n\nfunction updateRef<T>(initialValue: T): {|current: T|} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.effectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookEffectTag,\n    create,\n    undefined,\n    nextDeps,\n  );\n}\n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(hookEffectTag, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.effectTag |= fiberEffectTag;\n\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookEffectTag,\n    create,\n    destroy,\n    nextDeps,\n  );\n}\n\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n    }\n  }\n  return mountEffectImpl(\n    UpdateEffect | PassiveEffect,\n    HookPassive,\n    create,\n    deps,\n  );\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber);\n    }\n  }\n  return updateEffectImpl(\n    UpdateEffect | PassiveEffect,\n    HookPassive,\n    create,\n    deps,\n  );\n}\n\nfunction mountLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return mountEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error(\n          'Expected useImperativeHandle() first argument to either be a ' +\n            'ref callback or React.createRef() object. Instead received: %s.',\n          'an object with keys {' + Object.keys(refObject).join(', ') + '}',\n        );\n      }\n    }\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle<T>(\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error(\n        'Expected useImperativeHandle() second argument to be a function ' +\n          'that creates a handle. Instead received: %s.',\n        create !== null ? typeof create : 'null',\n      );\n    }\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return mountEffectImpl(\n    UpdateEffect,\n    HookLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction updateImperativeHandle<T>(\n  ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error(\n        'Expected useImperativeHandle() second argument to be a function ' +\n          'that creates a handle. Instead received: %s.',\n        create !== null ? typeof create : 'null',\n      );\n    }\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  return updateEffectImpl(\n    UpdateEffect,\n    HookLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction mountDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n  // This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue<T>(\n  value: T,\n  config: TimeoutConfig | void | null,\n): T {\n  const [prevValue, setValue] = mountState(value);\n  mountEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction updateDeferredValue<T>(\n  value: T,\n  config: TimeoutConfig | void | null,\n): T {\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction rerenderDeferredValue<T>(\n  value: T,\n  config: TimeoutConfig | void | null,\n): T {\n  const [prevValue, setValue] = rerenderState(value);\n  updateEffect(() => {\n    const previousConfig = ReactCurrentBatchConfig.suspense;\n    ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.suspense = previousConfig;\n    }\n  }, [value, config]);\n  return prevValue;\n}\n\nfunction startTransition(setPending, config, callback) {\n  const priorityLevel = getCurrentPriorityLevel();\n  runWithPriority(\n    priorityLevel < UserBlockingPriority ? UserBlockingPriority : priorityLevel,\n    () => {\n      setPending(true);\n    },\n  );\n  runWithPriority(\n    priorityLevel > NormalPriority ? NormalPriority : priorityLevel,\n    () => {\n      const previousConfig = ReactCurrentBatchConfig.suspense;\n      ReactCurrentBatchConfig.suspense = config === undefined ? null : config;\n      try {\n        setPending(false);\n        callback();\n      } finally {\n        ReactCurrentBatchConfig.suspense = previousConfig;\n      }\n    },\n  );\n}\n\nfunction mountTransition(\n  config: SuspenseConfig | void | null,\n): [(() => void) => void, boolean] {\n  const [isPending, setPending] = mountState(false);\n  const start = mountCallback(startTransition.bind(null, setPending, config), [\n    setPending,\n    config,\n  ]);\n  return [start, isPending];\n}\n\nfunction updateTransition(\n  config: SuspenseConfig | void | null,\n): [(() => void) => void, boolean] {\n  const [isPending, setPending] = updateState(false);\n  const start = updateCallback(startTransition.bind(null, setPending, config), [\n    setPending,\n    config,\n  ]);\n  return [start, isPending];\n}\n\nfunction rerenderTransition(\n  config: SuspenseConfig | void | null,\n): [(() => void) => void, boolean] {\n  const [isPending, setPending] = rerenderState(false);\n  const start = updateCallback(startTransition.bind(null, setPending, config), [\n    setPending,\n    config,\n  ]);\n  return [start, isPending];\n}\n\nfunction dispatchAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\n          'second callback argument. To execute a side effect after ' +\n          'rendering, declare it in the component body with useEffect().',\n      );\n    }\n  }\n\n  const currentTime = requestCurrentTimeForUpdate();\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  const expirationTime = computeExpirationForFiber(\n    currentTime,\n    fiber,\n    suspenseConfig,\n  );\n\n  const update: Update<S, A> = {\n    expirationTime,\n    suspenseConfig,\n    action,\n    eagerReducer: null,\n    eagerState: null,\n    next: (null: any),\n  };\n\n  if (__DEV__) {\n    update.priority = getCurrentPriorityLevel();\n  }\n\n  // Append the update to the end of the list.\n  const pending = queue.pending;\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n  queue.pending = update;\n\n  const alternate = fiber.alternate;\n  if (\n    fiber === currentlyRenderingFiber ||\n    (alternate !== null && alternate === currentlyRenderingFiber)\n  ) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true;\n    update.expirationTime = renderExpirationTime;\n    currentlyRenderingFiber.expirationTime = renderExpirationTime;\n  } else {\n    if (\n      fiber.expirationTime === NoWork &&\n      (alternate === null || alternate.expirationTime === NoWork)\n    ) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          const eagerState = lastRenderedReducer(currentState, action);\n          // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n          update.eagerReducer = lastRenderedReducer;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n    if (__DEV__) {\n      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n      if ('undefined' !== typeof jest) {\n        warnIfNotScopedWithMatchingAct(fiber);\n        warnIfNotCurrentlyActingUpdatesInDev(fiber);\n      }\n    }\n    scheduleWork(fiber, expirationTime);\n  }\n}\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useResponder: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n};\n\nconst HooksDispatcherOnMount: Dispatcher = {\n  readContext,\n\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useResponder: createDeprecatedResponderListener,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useResponder: createDeprecatedResponderListener,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n};\n\nconst HooksDispatcherOnRerender: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useResponder: createDeprecatedResponderListener,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n};\n\nlet HooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error(\n      'Context can only be read while React is rendering. ' +\n        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\n        'In function components, you can read it directly in the function body, but not ' +\n        'inside Hooks like useReducer() or useMemo().',\n    );\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error(\n      'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\n        'You can only call Hooks at the top level of your React function. ' +\n        'For more information, see ' +\n        'https://fb.me/rules-of-hooks',\n    );\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      mountHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition(config);\n    },\n  };\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition(config);\n    },\n  };\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition(config);\n    },\n  };\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition(config);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition(config);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition(config);\n    },\n  };\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      warnInvalidContextAccess();\n      return readContext(context, observedBits);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(\n      context: ReactContext<T>,\n      observedBits: void | number | boolean,\n    ): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context, observedBits);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {|current: T|} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useResponder<E, C>(\n      responder: ReactEventResponder<E, C>,\n      props,\n    ): ReactEventResponderListener<E, C> {\n      currentHookNameInDev = 'useResponder';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return createDeprecatedResponderListener(responder, props);\n    },\n    useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value, config);\n    },\n    useTransition(\n      config: SuspenseConfig | void | null,\n    ): [(() => void) => void, boolean] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition(config);\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}