{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { precacheFiberNode, updateFiberProps, getClosestInstanceFromNode } from './ReactDOMComponentTree';\nimport { createElement, createTextNode, setInitialProperties, diffProperties, updateProperties, diffHydratedProperties, diffHydratedText, trapClickOnNonInteractiveElement, warnForUnmatchedText, warnForDeletedHydratableElement, warnForDeletedHydratableText, warnForInsertedHydratedElement, warnForInsertedHydratedText, listenToEventResponderEventTypes } from './ReactDOMComponent';\nimport { getSelectionInformation, restoreSelection } from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport { validateDOMNesting, updatedAncestorInfo } from './validateDOMNesting';\nimport { isEnabled as ReactBrowserEventEmitterIsEnabled, setEnabled as ReactBrowserEventEmitterSetEnabled } from '../events/ReactDOMEventListener';\nimport { getChildNamespace } from '../shared/DOMNamespaces';\nimport { ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE } from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport { mountEventResponder, unmountEventResponder, DEPRECATED_dispatchEventForResponderEventSystem } from '../events/DeprecatedDOMEventResponderSystem';\nimport { retryIfBlockedOn } from '../events/ReactDOMEventReplaying';\nimport { enableSuspenseServerRenderer, enableDeprecatedFlareAPI, enableFundamentalAPI } from 'shared/ReactFeatureFlags';\nimport { HostComponent } from 'shared/ReactWorkTags';\nimport { RESPONDER_EVENT_SYSTEM, IS_PASSIVE } from 'legacy-events/EventSystemFlags';\nlet SUPPRESS_HYDRATION_WARNING;\n\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\nconst STYLE = 'style';\nlet eventsEnabled = null;\nlet selectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n\n  return false;\n}\n\nexport * from 'shared/HostConfigWithNoPersistence';\nexport function getRootHostContext(rootContainerInstance) {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        let root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n\n    default:\n      {\n        const container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        const ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  return namespace;\n}\nexport function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  if (__DEV__) {\n    const parentHostContextDev = parentHostContext;\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  const parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\nexport function getPublicInstance(instance) {\n  return instance;\n}\nexport function prepareForCommit(containerInfo) {\n  // true\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  ReactBrowserEventEmitterSetEnabled(false);\n}\nexport function resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n\n  if (enableDeprecatedFlareAPI) {\n    const activeElementDetached = selectionInformation.activeElementDetached;\n\n    if (activeElementDetached !== null) {\n      dispatchDetachedBlur(activeElementDetached);\n    }\n  }\n\n  selectionInformation = null;\n}\nexport function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  let parentNamespace;\n\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  const domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\nexport function appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\nexport function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\nexport function shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\nexport function shouldDeprioritizeSubtree(type, props) {\n  return !!props.hidden;\n}\nexport function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n\n  const textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true; // This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n\nexport const scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nexport const cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\nexport const noTimeout = -1; // -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\nexport function commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    domElement.focus();\n  }\n}\nexport function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.\n\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\nexport function resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\nexport function commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\nexport function appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function appendChildToContainer(container, child) {\n  let parentNode; // 监测 container 是否注释节点\n\n  if (container.nodeType === COMMENT_NODE) {\n    // 获取父级的父级\n    parentNode = container.parentNode; // 将子级节点插入到注释节点的前面\n\n    parentNode.insertBefore(child, container);\n  } else {\n    // 直接将 child 插入到父级中\n    parentNode = container;\n    parentNode.appendChild(child);\n  } // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n\n\n  const reactRootContainer = container._reactRootContainer;\n\n  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\nexport function insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\nexport function insertInContainerBefore(container, child, beforeChild) {\n  // 如果父容器是注释节点\n  if (container.nodeType === COMMENT_NODE) {\n    // 找到注释节点的父级节点 因为注释节点没法调用 insertBefore\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    // 将 child 插入到 beforeChild 的前面\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction dispatchBeforeDetachedBlur(target) {\n  const targetInstance = getClosestInstanceFromNode(target);\n  selectionInformation.activeElementDetached = target;\n  DEPRECATED_dispatchEventForResponderEventSystem('beforeblur', targetInstance, {\n    target,\n    timeStamp: Date.now()\n  }, target, RESPONDER_EVENT_SYSTEM | IS_PASSIVE);\n}\n\nfunction dispatchDetachedBlur(target) {\n  DEPRECATED_dispatchEventForResponderEventSystem('blur', null, {\n    isTargetAttached: false,\n    target,\n    timeStamp: Date.now()\n  }, target, RESPONDER_EVENT_SYSTEM | IS_PASSIVE);\n} // This is a specific event for the React Flare\n// event system, so event responders can act\n// accordingly to a DOM node being unmounted that\n// previously had active document focus.\n\n\nexport function beforeRemoveInstance(instance) {\n  if (enableDeprecatedFlareAPI && selectionInformation && instance === selectionInformation.focusedElem) {\n    dispatchBeforeDetachedBlur(instance);\n  }\n}\nexport function removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\nexport function removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\nexport function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  let node = suspenseInstance; // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  do {\n    let nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      let data = nextNode.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode); // Retry if any event replaying was blocked on this.\n\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = nextNode;\n  } while (node); // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary(container.parentNode, suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary(container, suspenseInstance);\n  } else {// Document nodes should never contain suspense boundaries.\n  } // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(container);\n}\n\nfunction instanceContainsElem(instance, element) {\n  let fiber = getClosestInstanceFromNode(element);\n\n  while (fiber !== null) {\n    if (fiber.tag === HostComponent && fiber.stateNode === element) {\n      return true;\n    }\n\n    fiber = fiber.return;\n  }\n\n  return false;\n}\n\nexport function hideInstance(instance) {\n  // Ensure we trigger `onBeforeBlur` if the active focused elment\n  // is ether the instance of a child or the instance. We need\n  // to traverse the Fiber tree here rather than use node.contains()\n  // as the child node might be inside a Portal.\n  if (enableDeprecatedFlareAPI && selectionInformation) {\n    const focusedElem = selectionInformation.focusedElem;\n\n    if (focusedElem !== null && instanceContainsElem(instance, focusedElem)) {\n      dispatchBeforeDetachedBlur(focusedElem);\n    }\n  } // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n\n\n  instance = instance;\n  const style = instance.style;\n\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\nexport function hideTextInstance(textInstance) {\n  textInstance.nodeValue = '';\n}\nexport function unhideInstance(instance, props) {\n  instance = instance;\n  const styleProp = props[STYLE];\n  const display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\nexport function unhideTextInstance(textInstance, text) {\n  textInstance.nodeValue = text;\n} // -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\nexport function canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  } // This has now been refined to an element node.\n\n\n  return instance;\n}\nexport function canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a text node.\n\n\n  return instance;\n}\nexport function canHydrateSuspenseInstance(instance) {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a suspense node.\n\n\n  return instance;\n}\nexport function isSuspenseInstancePending(instance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\nexport function isSuspenseInstanceFallback(instance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\nexport function registerSuspenseInstanceRetry(instance, callback) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n\n    if (enableSuspenseServerRenderer) {\n      if (nodeType === COMMENT_NODE) {\n        const nodeData = node.data;\n\n        if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n          break;\n        }\n      }\n    }\n  }\n\n  return node;\n}\n\nexport function getNextHydratableSibling(instance) {\n  return getNextHydratable(instance.nextSibling);\n}\nexport function getFirstHydratableChild(parentInstance) {\n  return getNextHydratable(parentInstance.firstChild);\n}\nexport function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n\n  updateFiberProps(instance, props);\n  let parentNamespace;\n\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n}\nexport function hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\nexport function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\nexport function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n  let node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = node.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling(node);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.nextSibling;\n  } // TODO: Warn, we didn't find the end comment boundary.\n\n\n  return null;\n} // Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\n\nexport function getParentSuspenseInstance(targetInstance) {\n  let node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = node.data;\n\n      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        if (depth === 0) {\n          return node;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.previousSibling;\n  }\n\n  return null;\n}\nexport function commitHydratedContainer(container) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\nexport function commitHydratedSuspenseInstance(suspenseInstance) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\nexport function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\nexport function didNotHydrateContainerInstance(parentContainer, instance) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\nexport function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  }\n}\nexport function didNotFindHydratableContainerInstance(parentContainer, type, props) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\nexport function didNotFindHydratableContainerTextInstance(parentContainer, text) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\nexport function didNotFindHydratableContainerSuspenseInstance(parentContainer) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSupsense(parentContainer);\n  }\n}\nexport function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {// TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\nexport function DEPRECATED_mountResponderInstance(responder, responderInstance, responderProps, responderState, instance) {\n  // Listen to events\n  const doc = instance.ownerDocument;\n  const {\n    targetEventTypes\n  } = responder;\n\n  if (targetEventTypes !== null) {\n    listenToEventResponderEventTypes(targetEventTypes, doc);\n  }\n\n  mountEventResponder(responder, responderInstance, responderProps, responderState);\n  return responderInstance;\n}\nexport function DEPRECATED_unmountResponderInstance(responderInstance) {\n  if (enableDeprecatedFlareAPI) {\n    // TODO stop listening to targetEventTypes\n    unmountEventResponder(responderInstance);\n  }\n}\nexport function getFundamentalComponentInstance(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      currentFiber,\n      impl,\n      props,\n      state\n    } = fundamentalInstance;\n    const instance = impl.getInstance(null, props, state);\n    precacheFiberNode(currentFiber, instance);\n    return instance;\n  } // Because of the flag above, this gets around the Flow error;\n\n\n  return null;\n}\nexport function mountFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      instance,\n      props,\n      state\n    } = fundamentalInstance;\n    const onMount = impl.onMount;\n\n    if (onMount !== undefined) {\n      onMount(null, instance, props, state);\n    }\n  }\n}\nexport function shouldUpdateFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      prevProps,\n      props,\n      state\n    } = fundamentalInstance;\n    const shouldUpdate = impl.shouldUpdate;\n\n    if (shouldUpdate !== undefined) {\n      return shouldUpdate(null, prevProps, props, state);\n    }\n  }\n\n  return true;\n}\nexport function updateFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      instance,\n      prevProps,\n      props,\n      state\n    } = fundamentalInstance;\n    const onUpdate = impl.onUpdate;\n\n    if (onUpdate !== undefined) {\n      onUpdate(null, instance, prevProps, props, state);\n    }\n  }\n}\nexport function unmountFundamentalComponent(fundamentalInstance) {\n  if (enableFundamentalAPI) {\n    const {\n      impl,\n      instance,\n      props,\n      state\n    } = fundamentalInstance;\n    const onUnmount = impl.onUnmount;\n\n    if (onUnmount !== undefined) {\n      onUnmount(null, instance, props, state);\n    }\n  }\n}\nexport function getInstanceFromNode(node) {\n  return getClosestInstanceFromNode(node) || null;\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-dom/src/client/ReactDOMHostConfig.js"],"names":["precacheFiberNode","updateFiberProps","getClosestInstanceFromNode","createElement","createTextNode","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","trapClickOnNonInteractiveElement","warnForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","listenToEventResponderEventTypes","getSelectionInformation","restoreSelection","setTextContent","validateDOMNesting","updatedAncestorInfo","isEnabled","ReactBrowserEventEmitterIsEnabled","setEnabled","ReactBrowserEventEmitterSetEnabled","getChildNamespace","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","dangerousStyleValue","mountEventResponder","unmountEventResponder","DEPRECATED_dispatchEventForResponderEventSystem","retryIfBlockedOn","enableSuspenseServerRenderer","enableDeprecatedFlareAPI","enableFundamentalAPI","HostComponent","RESPONDER_EVENT_SYSTEM","IS_PASSIVE","SUPPRESS_HYDRATION_WARNING","__DEV__","SUSPENSE_START_DATA","SUSPENSE_END_DATA","SUSPENSE_PENDING_START_DATA","SUSPENSE_FALLBACK_START_DATA","STYLE","eventsEnabled","selectionInformation","shouldAutoFocusHostComponent","type","props","autoFocus","getRootHostContext","rootContainerInstance","namespace","nodeType","root","documentElement","namespaceURI","container","parentNode","ownNamespace","tagName","validatedTag","toLowerCase","ancestorInfo","getChildHostContext","parentHostContext","parentHostContextDev","parentNamespace","getPublicInstance","instance","prepareForCommit","containerInfo","resetAfterCommit","activeElementDetached","dispatchDetachedBlur","createInstance","hostContext","internalInstanceHandle","hostContextDev","children","string","ownAncestorInfo","domElement","appendInitialChild","parentInstance","child","appendChild","finalizeInitialChildren","prepareUpdate","oldProps","newProps","shouldSetTextContent","dangerouslySetInnerHTML","__html","shouldDeprioritizeSubtree","hidden","createTextInstance","text","textNode","isPrimaryRenderer","warnsIfNotActing","scheduleTimeout","setTimeout","undefined","cancelTimeout","clearTimeout","noTimeout","supportsMutation","commitMount","focus","commitUpdate","updatePayload","resetTextContent","commitTextUpdate","textInstance","oldText","newText","nodeValue","appendChildToContainer","insertBefore","reactRootContainer","_reactRootContainer","onclick","beforeChild","insertInContainerBefore","dispatchBeforeDetachedBlur","target","targetInstance","timeStamp","Date","now","isTargetAttached","beforeRemoveInstance","focusedElem","removeChild","removeChildFromContainer","clearSuspenseBoundary","suspenseInstance","node","depth","nextNode","nextSibling","data","clearSuspenseBoundaryFromContainer","instanceContainsElem","element","fiber","tag","stateNode","return","hideInstance","style","setProperty","display","hideTextInstance","unhideInstance","styleProp","hasOwnProperty","unhideTextInstance","supportsHydration","canHydrateInstance","nodeName","canHydrateTextInstance","canHydrateSuspenseInstance","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","callback","_reactRetry","getNextHydratable","nodeData","getNextHydratableSibling","getFirstHydratableChild","firstChild","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","getParentSuspenseInstance","previousSibling","commitHydratedContainer","commitHydratedSuspenseInstance","didNotMatchHydratedContainerTextInstance","parentContainer","didNotMatchHydratedTextInstance","parentType","parentProps","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableContainerSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","DEPRECATED_mountResponderInstance","responder","responderInstance","responderProps","responderState","doc","ownerDocument","targetEventTypes","DEPRECATED_unmountResponderInstance","getFundamentalComponentInstance","fundamentalInstance","currentFiber","impl","state","getInstance","mountFundamentalComponent","onMount","shouldUpdateFundamentalComponent","prevProps","shouldUpdate","updateFundamentalComponent","onUpdate","unmountFundamentalComponent","onUnmount","getInstanceFromNode"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {RootType} from './ReactDOMRoot';\n\nimport {\n  precacheFiberNode,\n  updateFiberProps,\n  getClosestInstanceFromNode,\n} from './ReactDOMComponentTree';\nimport {\n  createElement,\n  createTextNode,\n  setInitialProperties,\n  diffProperties,\n  updateProperties,\n  diffHydratedProperties,\n  diffHydratedText,\n  trapClickOnNonInteractiveElement,\n  warnForUnmatchedText,\n  warnForDeletedHydratableElement,\n  warnForDeletedHydratableText,\n  warnForInsertedHydratedElement,\n  warnForInsertedHydratedText,\n  listenToEventResponderEventTypes,\n} from './ReactDOMComponent';\nimport {getSelectionInformation, restoreSelection} from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport {validateDOMNesting, updatedAncestorInfo} from './validateDOMNesting';\nimport {\n  isEnabled as ReactBrowserEventEmitterIsEnabled,\n  setEnabled as ReactBrowserEventEmitterSetEnabled,\n} from '../events/ReactDOMEventListener';\nimport {getChildNamespace} from '../shared/DOMNamespaces';\nimport {\n  ELEMENT_NODE,\n  TEXT_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n} from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\n\nimport type {\n  ReactDOMEventResponder,\n  ReactDOMEventResponderInstance,\n  ReactDOMFundamentalComponentInstance,\n} from 'shared/ReactDOMTypes';\nimport {\n  mountEventResponder,\n  unmountEventResponder,\n  DEPRECATED_dispatchEventForResponderEventSystem,\n} from '../events/DeprecatedDOMEventResponderSystem';\nimport {retryIfBlockedOn} from '../events/ReactDOMEventReplaying';\n\nimport {\n  enableSuspenseServerRenderer,\n  enableDeprecatedFlareAPI,\n  enableFundamentalAPI,\n} from 'shared/ReactFeatureFlags';\nimport {HostComponent} from 'shared/ReactWorkTags';\nimport {\n  RESPONDER_EVENT_SYSTEM,\n  IS_PASSIVE,\n} from 'legacy-events/EventSystemFlags';\n\nexport type Type = string;\nexport type Props = {\n  autoFocus?: boolean,\n  children?: mixed,\n  hidden?: boolean,\n  suppressHydrationWarning?: boolean,\n  dangerouslySetInnerHTML?: mixed,\n  style?: {display?: string, ...},\n  bottom?: null | number,\n  left?: null | number,\n  right?: null | number,\n  top?: null | number,\n  ...\n};\nexport type EventTargetChildElement = {\n  type: string,\n  props: null | {\n    style?: {\n      position?: string,\n      zIndex?: number,\n      bottom?: string,\n      left?: string,\n      right?: string,\n      top?: string,\n      ...\n    },\n    ...\n  },\n  ...\n};\nexport type Container =\n  | (Element & {_reactRootContainer?: RootType, ...})\n  | (Document & {_reactRootContainer?: RootType, ...});\nexport type Instance = Element;\nexport type TextInstance = Text;\nexport type SuspenseInstance = Comment & {_reactRetry?: () => void, ...};\nexport type HydratableInstance = Instance | TextInstance | SuspenseInstance;\nexport type PublicInstance = Element | Text;\ntype HostContextDev = {\n  namespace: string,\n  ancestorInfo: mixed,\n  ...\n};\ntype HostContextProd = string;\nexport type HostContext = HostContextDev | HostContextProd;\nexport type UpdatePayload = Array<mixed>;\nexport type ChildSet = void; // Unused\nexport type TimeoutHandle = TimeoutID;\nexport type NoTimeout = -1;\n\ntype SelectionInformation = {|\n  activeElementDetached: null | HTMLElement,\n  focusedElem: null | HTMLElement,\n  selectionRange: mixed,\n|};\n\nlet SUPPRESS_HYDRATION_WARNING;\nif (__DEV__) {\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\n\nconst STYLE = 'style';\n\nlet eventsEnabled: ?boolean = null;\nlet selectionInformation: null | SelectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type: string, props: Props): boolean {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nexport * from 'shared/HostConfigWithNoPersistence';\n\nexport function getRootHostContext(\n  rootContainerInstance: Container,\n): HostContext {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE: {\n      type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n      let root = (rootContainerInstance: any).documentElement;\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n      break;\n    }\n    default: {\n      const container: any =\n        nodeType === COMMENT_NODE\n          ? rootContainerInstance.parentNode\n          : rootContainerInstance;\n      const ownNamespace = container.namespaceURI || null;\n      type = container.tagName;\n      namespace = getChildNamespace(ownNamespace, type);\n      break;\n    }\n  }\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return {namespace, ancestorInfo};\n  }\n  return namespace;\n}\n\nexport function getChildHostContext(\n  parentHostContext: HostContext,\n  type: string,\n  rootContainerInstance: Container,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfo(\n      parentHostContextDev.ancestorInfo,\n      type,\n    );\n    return {namespace, ancestorInfo};\n  }\n  const parentNamespace = ((parentHostContext: any): HostContextProd);\n  return getChildNamespace(parentNamespace, type);\n}\n\nexport function getPublicInstance(instance: Instance): * {\n  return instance;\n}\n\nexport function prepareForCommit(containerInfo: Container): void {\n  // true\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  ReactBrowserEventEmitterSetEnabled(false);\n}\n\nexport function resetAfterCommit(containerInfo: Container): void {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n  if (enableDeprecatedFlareAPI) {\n    const activeElementDetached = (selectionInformation: any)\n      .activeElementDetached;\n    if (activeElementDetached !== null) {\n      dispatchDetachedBlur(activeElementDetached);\n    }\n  }\n  selectionInformation = null;\n}\n\nexport function createInstance(\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): Instance {\n  let parentNamespace: string;\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (\n      typeof props.children === 'string' ||\n      typeof props.children === 'number'\n    ) {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  const domElement: Instance = createElement(\n    type,\n    props,\n    rootContainerInstance,\n    parentNamespace,\n  );\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nexport function appendInitialChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function finalizeInitialChildren(\n  domElement: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): boolean {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nexport function prepareUpdate(\n  domElement: Instance,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n): null | Array<mixed> {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    if (\n      typeof newProps.children !== typeof oldProps.children &&\n      (typeof newProps.children === 'string' ||\n        typeof newProps.children === 'number')\n    ) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfo(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(\n    domElement,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n  );\n}\n\nexport function shouldSetTextContent(type: string, props: Props): boolean {\n  return (\n    type === 'textarea' ||\n    type === 'option' ||\n    type === 'noscript' ||\n    typeof props.children === 'string' ||\n    typeof props.children === 'number' ||\n    (typeof props.dangerouslySetInnerHTML === 'object' &&\n      props.dangerouslySetInnerHTML !== null &&\n      props.dangerouslySetInnerHTML.__html != null)\n  );\n}\n\nexport function shouldDeprioritizeSubtree(type: string, props: Props): boolean {\n  return !!props.hidden;\n}\n\nexport function createTextInstance(\n  text: string,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): TextInstance {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n  const textNode: TextInstance = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true;\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\nexport const cancelTimeout: any =\n  typeof clearTimeout === 'function' ? clearTimeout : (undefined: any);\nexport const noTimeout = -1;\n\n// -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\n\nexport function commitMount(\n  domElement: Instance,\n  type: string,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    ((domElement: any):\n      | HTMLButtonElement\n      | HTMLInputElement\n      | HTMLSelectElement\n      | HTMLTextAreaElement).focus();\n  }\n}\n\nexport function commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nexport function resetTextContent(domElement: Instance): void {\n  setTextContent(domElement, '');\n}\n\nexport function commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\nexport function appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function appendChildToContainer(\n  container: Container,\n  child: Instance | TextInstance,\n): void {\n  let parentNode;\n  // 监测 container 是否注释节点\n  if (container.nodeType === COMMENT_NODE) {\n    // 获取父级的父级\n    parentNode = (container.parentNode: any);\n    // 将子级节点插入到注释节点的前面\n    parentNode.insertBefore(child, container);\n  } else {\n    // 直接将 child 插入到父级中\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n  const reactRootContainer = container._reactRootContainer;\n  if (\n    (reactRootContainer === null || reactRootContainer === undefined) &&\n    parentNode.onclick === null\n  ) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement));\n  }\n}\n\nexport function insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nexport function insertInContainerBefore(\n  container: Container,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  // 如果父容器是注释节点\n  if (container.nodeType === COMMENT_NODE) {\n    // 找到注释节点的父级节点 因为注释节点没法调用 insertBefore\n    (container.parentNode: any).insertBefore(child, beforeChild);\n  } else {\n    // 将 child 插入到 beforeChild 的前面\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction dispatchBeforeDetachedBlur(target: HTMLElement): void {\n  const targetInstance = getClosestInstanceFromNode(target);\n  ((selectionInformation: any): SelectionInformation).activeElementDetached = target;\n\n  DEPRECATED_dispatchEventForResponderEventSystem(\n    'beforeblur',\n    targetInstance,\n    ({\n      target,\n      timeStamp: Date.now(),\n    }: any),\n    target,\n    RESPONDER_EVENT_SYSTEM | IS_PASSIVE,\n  );\n}\n\nfunction dispatchDetachedBlur(target: HTMLElement): void {\n  DEPRECATED_dispatchEventForResponderEventSystem(\n    'blur',\n    null,\n    ({\n      isTargetAttached: false,\n      target,\n      timeStamp: Date.now(),\n    }: any),\n    target,\n    RESPONDER_EVENT_SYSTEM | IS_PASSIVE,\n  );\n}\n\n// This is a specific event for the React Flare\n// event system, so event responders can act\n// accordingly to a DOM node being unmounted that\n// previously had active document focus.\nexport function beforeRemoveInstance(\n  instance: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (\n    enableDeprecatedFlareAPI &&\n    selectionInformation &&\n    instance === selectionInformation.focusedElem\n  ) {\n    dispatchBeforeDetachedBlur(((instance: any): HTMLElement));\n  }\n}\n\nexport function removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\nexport function removeChildFromContainer(\n  container: Container,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\nexport function clearSuspenseBoundary(\n  parentInstance: Instance,\n  suspenseInstance: SuspenseInstance,\n): void {\n  let node = suspenseInstance;\n  // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  do {\n    let nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      let data = ((nextNode: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode);\n          // Retry if any event replaying was blocked on this.\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = nextNode;\n  } while (node);\n  // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\n\nexport function clearSuspenseBoundaryFromContainer(\n  container: Container,\n  suspenseInstance: SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary((container.parentNode: any), suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary((container: any), suspenseInstance);\n  } else {\n    // Document nodes should never contain suspense boundaries.\n  }\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\n\nfunction instanceContainsElem(instance: Instance, element: HTMLElement) {\n  let fiber = getClosestInstanceFromNode(element);\n  while (fiber !== null) {\n    if (fiber.tag === HostComponent && fiber.stateNode === element) {\n      return true;\n    }\n    fiber = fiber.return;\n  }\n  return false;\n}\n\nexport function hideInstance(instance: Instance): void {\n  // Ensure we trigger `onBeforeBlur` if the active focused elment\n  // is ether the instance of a child or the instance. We need\n  // to traverse the Fiber tree here rather than use node.contains()\n  // as the child node might be inside a Portal.\n  if (enableDeprecatedFlareAPI && selectionInformation) {\n    const focusedElem = selectionInformation.focusedElem;\n    if (focusedElem !== null && instanceContainsElem(instance, focusedElem)) {\n      dispatchBeforeDetachedBlur(((focusedElem: any): HTMLElement));\n    }\n  }\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = ((instance: any): HTMLElement);\n  const style = instance.style;\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\n\nexport function hideTextInstance(textInstance: TextInstance): void {\n  textInstance.nodeValue = '';\n}\n\nexport function unhideInstance(instance: Instance, props: Props): void {\n  instance = ((instance: any): HTMLElement);\n  const styleProp = props[STYLE];\n  const display =\n    styleProp !== undefined &&\n    styleProp !== null &&\n    styleProp.hasOwnProperty('display')\n      ? styleProp.display\n      : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\n\nexport function unhideTextInstance(\n  textInstance: TextInstance,\n  text: string,\n): void {\n  textInstance.nodeValue = text;\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\n\nexport function canHydrateInstance(\n  instance: HydratableInstance,\n  type: string,\n  props: Props,\n): null | Instance {\n  if (\n    instance.nodeType !== ELEMENT_NODE ||\n    type.toLowerCase() !== instance.nodeName.toLowerCase()\n  ) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return ((instance: any): Instance);\n}\n\nexport function canHydrateTextInstance(\n  instance: HydratableInstance,\n  text: string,\n): null | TextInstance {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return ((instance: any): TextInstance);\n}\n\nexport function canHydrateSuspenseInstance(\n  instance: HydratableInstance,\n): null | SuspenseInstance {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a suspense node.\n  return ((instance: any): SuspenseInstance);\n}\n\nexport function isSuspenseInstancePending(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\n\nexport function isSuspenseInstanceFallback(instance: SuspenseInstance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\n\nexport function registerSuspenseInstanceRetry(\n  instance: SuspenseInstance,\n  callback: () => void,\n) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n      break;\n    }\n    if (enableSuspenseServerRenderer) {\n      if (nodeType === COMMENT_NODE) {\n        const nodeData = (node: any).data;\n        if (\n          nodeData === SUSPENSE_START_DATA ||\n          nodeData === SUSPENSE_FALLBACK_START_DATA ||\n          nodeData === SUSPENSE_PENDING_START_DATA\n        ) {\n          break;\n        }\n      }\n    }\n  }\n  return (node: any);\n}\n\nexport function getNextHydratableSibling(\n  instance: HydratableInstance,\n): null | HydratableInstance {\n  return getNextHydratable(instance.nextSibling);\n}\n\nexport function getFirstHydratableChild(\n  parentInstance: Container | Instance,\n): null | HydratableInstance {\n  return getNextHydratable(parentInstance.firstChild);\n}\n\nexport function hydrateInstance(\n  instance: Instance,\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): null | Array<mixed> {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  let parentNamespace: string;\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  return diffHydratedProperties(\n    instance,\n    type,\n    props,\n    parentNamespace,\n    rootContainerInstance,\n  );\n}\n\nexport function hydrateTextInstance(\n  textInstance: TextInstance,\n  text: string,\n  internalInstanceHandle: Object,\n): boolean {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nexport function hydrateSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n  internalInstanceHandle: Object,\n) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\n\nexport function getNextHydratableInstanceAfterSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): null | HydratableInstance {\n  let node = suspenseInstance.nextSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = ((node: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling((node: any));\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = node.nextSibling;\n  }\n  // TODO: Warn, we didn't find the end comment boundary.\n  return null;\n}\n\n// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nexport function getParentSuspenseInstance(\n  targetInstance: Instance,\n): null | SuspenseInstance {\n  let node = targetInstance.previousSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      let data = ((node: any).data: string);\n      if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        if (depth === 0) {\n          return ((node: any): SuspenseInstance);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n    node = node.previousSibling;\n  }\n  return null;\n}\n\nexport function commitHydratedContainer(container: Container): void {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\n\nexport function commitHydratedSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): void {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\n\nexport function didNotMatchHydratedContainerTextInstance(\n  parentContainer: Container,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotMatchHydratedTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  textInstance: TextInstance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nexport function didNotHydrateContainerInstance(\n  parentContainer: Container,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, (instance: any));\n    }\n  }\n}\n\nexport function didNotHydrateInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  instance: HydratableInstance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentInstance, (instance: any));\n    }\n  }\n}\n\nexport function didNotFindHydratableContainerInstance(\n  parentContainer: Container,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nexport function didNotFindHydratableContainerTextInstance(\n  parentContainer: Container,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nexport function didNotFindHydratableContainerSuspenseInstance(\n  parentContainer: Container,\n) {\n  if (__DEV__) {\n    // TODO: warnForInsertedHydratedSupsense(parentContainer);\n  }\n}\n\nexport function didNotFindHydratableInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  text: string,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n) {\n  if (__DEV__ && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    // TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\n\nexport function DEPRECATED_mountResponderInstance(\n  responder: ReactDOMEventResponder,\n  responderInstance: ReactDOMEventResponderInstance,\n  responderProps: Object,\n  responderState: Object,\n  instance: Instance,\n): ReactDOMEventResponderInstance {\n  // Listen to events\n  const doc = instance.ownerDocument;\n  const {targetEventTypes} = ((responder: any): ReactDOMEventResponder);\n  if (targetEventTypes !== null) {\n    listenToEventResponderEventTypes(targetEventTypes, doc);\n  }\n  mountEventResponder(\n    responder,\n    responderInstance,\n    responderProps,\n    responderState,\n  );\n  return responderInstance;\n}\n\nexport function DEPRECATED_unmountResponderInstance(\n  responderInstance: ReactDOMEventResponderInstance,\n): void {\n  if (enableDeprecatedFlareAPI) {\n    // TODO stop listening to targetEventTypes\n    unmountEventResponder(responderInstance);\n  }\n}\n\nexport function getFundamentalComponentInstance(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): Instance {\n  if (enableFundamentalAPI) {\n    const {currentFiber, impl, props, state} = fundamentalInstance;\n    const instance = impl.getInstance(null, props, state);\n    precacheFiberNode(currentFiber, instance);\n    return instance;\n  }\n  // Because of the flag above, this gets around the Flow error;\n  return (null: any);\n}\n\nexport function mountFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): void {\n  if (enableFundamentalAPI) {\n    const {impl, instance, props, state} = fundamentalInstance;\n    const onMount = impl.onMount;\n    if (onMount !== undefined) {\n      onMount(null, instance, props, state);\n    }\n  }\n}\n\nexport function shouldUpdateFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): boolean {\n  if (enableFundamentalAPI) {\n    const {impl, prevProps, props, state} = fundamentalInstance;\n    const shouldUpdate = impl.shouldUpdate;\n    if (shouldUpdate !== undefined) {\n      return shouldUpdate(null, prevProps, props, state);\n    }\n  }\n  return true;\n}\n\nexport function updateFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): void {\n  if (enableFundamentalAPI) {\n    const {impl, instance, prevProps, props, state} = fundamentalInstance;\n    const onUpdate = impl.onUpdate;\n    if (onUpdate !== undefined) {\n      onUpdate(null, instance, prevProps, props, state);\n    }\n  }\n}\n\nexport function unmountFundamentalComponent(\n  fundamentalInstance: ReactDOMFundamentalComponentInstance,\n): void {\n  if (enableFundamentalAPI) {\n    const {impl, instance, props, state} = fundamentalInstance;\n    const onUnmount = impl.onUnmount;\n    if (onUnmount !== undefined) {\n      onUnmount(null, instance, props, state);\n    }\n  }\n}\n\nexport function getInstanceFromNode(node: HTMLElement): null | Object {\n  return getClosestInstanceFromNode(node) || null;\n}\n"]},"metadata":{},"sourceType":"module"}