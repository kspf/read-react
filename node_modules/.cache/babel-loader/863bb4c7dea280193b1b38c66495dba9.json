{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { warnAboutDeprecatedLifecycles, deferPassiveEffectCleanupDuringUnmount, runAllPassiveEffectDestroysBeforeCreates, enableUserTimingAPI, enableSuspenseServerRenderer, replayFailedUnitOfWorkWithInvokeGuardedCallback, enableProfilerTimer, enableSchedulerTracing, warnAboutUnmockedScheduler, flushSuspenseFallbacksInTests, disableSchedulerTimeoutBasedOnReactExpirationTime, enableTrainModelFix } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\nimport { scheduleCallback, cancelCallback, getCurrentPriorityLevel, runWithPriority, shouldYield, requestPaint, now, NoPriority, ImmediatePriority, UserBlockingPriority, NormalPriority, LowPriority, IdlePriority, flushSyncCallbackQueue, scheduleSyncCallback } from './SchedulerWithReactIntegration'; // The scheduler is imported here *only* to detect whether it's been mocked\n\nimport * as Scheduler from 'scheduler';\nimport { __interactionsRef, __subscriberRef } from 'scheduler/tracing';\nimport { prepareForCommit, resetAfterCommit, scheduleTimeout, cancelTimeout, noTimeout, warnsIfNotActing } from './ReactFiberHostConfig';\nimport { createWorkInProgress, assignFiberPropertiesInDEV } from './ReactFiber';\nimport { isRootSuspendedAtTime, markRootSuspendedAtTime, markRootFinishedAtTime, markRootUpdatedAtTime, markRootExpiredAtTime } from './ReactFiberRoot';\nimport { NoMode, StrictMode, ProfileMode, BlockingMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostRoot, ClassComponent, SuspenseComponent, SuspenseListComponent, FunctionComponent, ForwardRef, MemoComponent, SimpleMemoComponent, Block } from 'shared/ReactWorkTags';\nimport { NoEffect, PerformedWork, Placement, Update, PlacementAndUpdate, Deletion, Ref, ContentReset, Snapshot, Callback, Passive, Incomplete, HostEffectMask, Hydrating, HydratingAndUpdate } from 'shared/ReactSideEffectTags';\nimport { NoWork, Sync, Never, msToExpirationTime, expirationTimeToMs, computeInteractiveExpiration, computeAsyncExpiration, computeSuspenseExpiration, inferPriorityFromExpirationTime, LOW_PRIORITY_EXPIRATION, Batched, Idle } from './ReactFiberExpirationTime';\nimport { beginWork as originalBeginWork } from './ReactFiberBeginWork';\nimport { completeWork } from './ReactFiberCompleteWork';\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork';\nimport { throwException, createRootErrorUpdate, createClassErrorUpdate } from './ReactFiberThrow';\nimport { commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber, commitLifeCycles as commitLayoutEffectOnFiber, commitPassiveHookEffects, commitPlacement, commitWork, commitDeletion, commitDetachRef, commitAttachRef, commitResetTextContent } from './ReactFiberCommitWork';\nimport { enqueueUpdate } from './ReactUpdateQueue';\nimport { resetContextDependencies } from './ReactFiberNewContext';\nimport { resetHooksAfterThrow, ContextOnlyDispatcher } from './ReactFiberHooks';\nimport { createCapturedValue } from './ReactCapturedValue';\nimport { recordCommitTime, startProfilerTimer, stopProfilerTimerIfRunningAndRecordDelta } from './ReactProfilerTimer'; // DEV stuff\n\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { isRendering as ReactCurrentDebugFiberIsRenderingInDEV, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV, getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { recordEffect, recordScheduleUpdate, startWorkTimer, stopWorkTimer, stopFailedWorkTimer, startWorkLoopTimer, stopWorkLoopTimer, startCommitTimer, stopCommitTimer, startCommitSnapshotEffectsTimer, stopCommitSnapshotEffectsTimer, startCommitHostEffectsTimer, stopCommitHostEffectsTimer, startCommitLifeCyclesTimer, stopCommitLifeCyclesTimer } from './ReactDebugFiberPerf';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { onCommitRoot } from './ReactFiberDevToolsHook';\nconst ceil = Math.ceil;\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  IsSomeRendererActing\n} = ReactSharedInternals;\nconst NoContext =\n/*                    */\n0b000000;\nconst BatchedContext =\n/*               */\n0b000001;\nconst EventContext =\n/*                 */\n0b000010;\nconst DiscreteEventContext =\n/*         */\n0b000100;\nconst LegacyUnbatchedContext =\n/*       */\n0b001000;\nconst RenderContext =\n/*                */\n0b010000;\nconst CommitContext =\n/*                */\n0b100000;\nconst RootIncomplete = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\n// Describes where we are in the React execution stack\nlet executionContext = NoContext; // The root we're working on\n\nlet workInProgressRoot = null; // The fiber we're working on\n\nlet workInProgress = null; // The expiration time we're rendering\n\nlet renderExpirationTime = NoWork; // Whether to root completed, errored, suspended, etc.\n\nlet workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown\n\nlet workInProgressRootFatalError = null; // Most recent event time among processed updates during this render.\n// This is conceptually a time stamp but expressed in terms of an ExpirationTime\n// because we deal mostly with expiration times in the hot path, so this avoids\n// the conversion happening in the hot path.\n\nlet workInProgressRootLatestProcessedExpirationTime = Sync;\nlet workInProgressRootLatestSuspenseTimeout = Sync;\nlet workInProgressRootCanSuspendUsingConfig = null; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nlet workInProgressRootNextUnprocessedUpdateTime = NoWork; // If we're pinged while rendering we don't always restart immediately.\n// This flag determines if it might be worthwhile to restart if an opportunity\n// happens latere.\n\nlet workInProgressRootHasPendingPing = false; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nlet globalMostRecentFallbackTime = 0;\nconst FALLBACK_THROTTLE_MS = 500;\nlet nextEffect = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed = null;\nlet rootDoesHavePassiveEffects = false;\nlet rootWithPendingPassiveEffects = null;\nlet pendingPassiveEffectsRenderPriority = NoPriority;\nlet pendingPassiveEffectsExpirationTime = NoWork;\nlet pendingPassiveHookEffectsMount = [];\nlet pendingPassiveHookEffectsUnmount = [];\nlet rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates\n\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount = 0;\nlet rootWithNestedUpdates = null;\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount = 0;\nlet interruptedBy = null; // Marks the need to reschedule pending interactions at these expiration times\n// during the commit phase. This enables them to be traced across components\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\n// hydration or SuspenseList.\n\nlet spawnedWorkDuringRender = null; // Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\n\nlet currentEventTime = NoWork;\nexport function requestCurrentTimeForUpdate() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\nexport function getCurrentTime() {\n  return msToExpirationTime(now());\n}\nexport function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {\n  const mode = fiber.mode;\n\n  if ((mode & BlockingMode) === NoMode) {\n    return Sync;\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(currentTime, suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n\n      case NormalPriority:\n      case LowPriority:\n        // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  } // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n\n\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n/**\n * 判断任务是否为同步 调用同步任务入口\n */\n\nexport function scheduleUpdateOnFiber(fiber, expirationTime) {\n  /**\n   * fiber: 初始化渲染时为 rootFiber, 即 <div id=\"root\"></div> 对应的 Fiber 对象\n   * expirationTime: 任务过期时间 => 1073741823\n   */\n\n  /**\n   * 判断是否是无限循环的 update 如果是就报错\n   * 在 componentWillUpdate 或者 componentDidUpdate 生命周期函数中重复调用\n   * setState 方法时, 可能会发生这种情况, React 限制了嵌套更新的数量以防止无限循环\n   * 限制的嵌套更新数量为 50, 可通过 NESTED_UPDATE_LIMIT 全局变量获取\n   */\n  checkForNestedUpdates(); // 开发环境下执行的代码 忽略\n\n  warnAboutRenderPhaseUpdatesInDEV(fiber); // 遍历更新子节点的过期时间 返回 FiberRoot\n\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n\n  if (root === null) {\n    // 开发环境下执行 忽略\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  } // 判断是否有高优先级任务打断当前正在执行的任务\n  // 内部判断条件不成立 内部代码没有得到执行\n\n\n  checkForInterruption(fiber, expirationTime); // 报告调度更新, 测试环境执行, 忽略\n\n  recordScheduleUpdate(); // 获取当前调度任务的优先级 数值类型 从90开始 数值越大 优先级越高\n  // 97 普通优先级任务\n\n  const priorityLevel = getCurrentPriorityLevel(); // 判断任务是否是同步任务 Sync的值为: 1073741823\n\n  if (expirationTime === Sync) {\n    if ( // 检查是否处于非批量更新模式\n    (executionContext & LegacyUnbatchedContext) !== NoContext && // 检查是否没有处于正在进行渲染的任务\n    (executionContext & (RenderContext | CommitContext)) === NoContext) {\n      // 在根上注册待处理的交互, 以避免丢失跟踪的交互数据\n      // 初始渲染时内部条件判断不成立, 内部代码没有得到执行\n      schedulePendingInteractions(root, expirationTime); // 同步任务入口点\n\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of legacy mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  } // 初始渲染不执行\n\n\n  if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered\n  // discrete, even inside a discrete event.\n  priorityLevel === UserBlockingPriority || priorityLevel === ImmediatePriority)) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber; // This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\n\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n\n  let alternate = fiber.alternate;\n\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  } // Walk the parent path to the root and update the child expiration time.\n\n\n  let node = fiber.return;\n  let root = null;\n\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n\n        if (alternate !== null && alternate.childExpirationTime < expirationTime) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (alternate !== null && alternate.childExpirationTime < expirationTime) {\n        alternate.childExpirationTime = expirationTime;\n      }\n\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    } // Mark that the root has a pending update.\n\n\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\nfunction getNextRootExpirationTimeToWorkOn(root) {\n  // Determines the next expiration time that the root should render, taking\n  // into account levels that may be suspended, or levels that may have\n  // received a ping.\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime !== NoWork) {\n    return lastExpiredTime;\n  } // \"Pending\" refers to any update that hasn't committed yet, including if it\n  // suspended. The \"suspended\" range is therefore a subset.\n\n\n  const firstPendingTime = root.firstPendingTime;\n\n  if (!isRootSuspendedAtTime(root, firstPendingTime)) {\n    // The highest priority pending time is not suspended. Let's work on that.\n    return firstPendingTime;\n  } // If the first pending time is suspended, check if there's a lower priority\n  // pending level that we know about. Or check if we received a ping. Work\n  // on whichever is higher priority.\n\n\n  const lastPingedTime = root.lastPingedTime;\n  const nextKnownPendingLevel = root.nextKnownPendingLevel;\n  const nextLevel = lastPingedTime > nextKnownPendingLevel ? lastPingedTime : nextKnownPendingLevel;\n\n  if (enableTrainModelFix && nextLevel <= Idle && firstPendingTime !== nextLevel) {\n    // Don't work on Idle/Never priority unless everything else is committed.\n    return NoWork;\n  }\n\n  return nextLevel;\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\n\n\nfunction ensureRootIsScheduled(root) {\n  const lastExpiredTime = root.lastExpiredTime;\n\n  if (lastExpiredTime !== NoWork) {\n    // Special case: Expired work should flush synchronously.\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n\n    return;\n  } // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n\n\n  const currentTime = requestCurrentTimeForUpdate();\n  const priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime); // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n\n    if ( // Callback must have the exact same expiration time.\n    existingCallbackExpirationTime === expirationTime && // Callback must have greater or equal priority.\n    existingCallbackPriority >= priorityLevel) {\n      // Existing callback is sufficient.\n      return;\n    } // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n\n\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n  let callbackNode;\n\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  } else {\n    callbackNode = scheduleCallback(priorityLevel, performConcurrentWorkOnRoot.bind(null, root), // Compute a task timeout based on the expiration time. This also affects\n    // ordering because tasks are processed in timeout order.\n    {\n      timeout: expirationTimeToMs(expirationTime) - now()\n    });\n  }\n\n  root.callbackNode = callbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTimeForUpdate();\n    markRootExpiredAtTime(root, currentTime); // This will schedule a synchronous callback.\n\n    ensureRootIsScheduled(root);\n    return null;\n  } // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n    invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.');\n    flushPassiveEffects(); // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n    if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    } // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n\n\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n\n      do {\n        try {\n          workLoopConcurrent();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n\n      if (enableSchedulerTracing) {\n        popInteractions(prevInteractions);\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n        const finishedWork = root.finishedWork = root.current.alternate;\n        root.finishedExpirationTime = expirationTime;\n        finishConcurrentRender(root, finishedWork, workInProgressRootExitStatus, expirationTime);\n      }\n\n      ensureRootIsScheduled(root);\n\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction finishConcurrentRender(root, finishedWork, exitStatus, expirationTime) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored:\n      {\n        invariant(false, 'Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // If this was an async render, the error may have happened due to\n        // a mutation in a concurrent event. Try rendering one more time,\n        // synchronously, to see if the error goes away. If there are\n        // lower priority updates, let's include those, too, in case they\n        // fix the inconsistency. Render at Idle to include all updates.\n        // If it was Idle or Never or some not-yet-invented time, render\n        // at that time.\n        markRootExpiredAtTime(root, expirationTime > Idle ? Idle : expirationTime); // We assume that this second render pass will be synchronous\n        // and therefore not hit this path again.\n\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspendedAtTime(root, expirationTime);\n        const lastSuspendedTime = root.lastSuspendedTime;\n\n        if (expirationTime === lastSuspendedTime) {\n          root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n        } // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n        // If we have processed new updates during this render, we may now\n        // have a new loading state ready. We want to ensure that we commit\n        // that as soon as possible.\n\n\n        const hasNotProcessedNewUpdates = workInProgressRootLatestProcessedExpirationTime === Sync;\n\n        if (hasNotProcessedNewUpdates && // do not delay if we're inside an act() scope\n        !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current)) {\n          // If we have not processed any new updates during this pass, then\n          // this is either a retry of an existing fallback state or a\n          // hidden tree. Hidden trees shouldn't be batched with other work\n          // and after that's fixed it can only be a retry. We're going to\n          // throttle committing retries so that we don't show too many\n          // loading states too quickly.\n          let msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            if (workInProgressRootHasPendingPing) {\n              const lastPingedTime = root.lastPingedTime;\n\n              if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n                // This render was pinged but we didn't get to restart\n                // earlier so try restarting now instead.\n                root.lastPingedTime = expirationTime;\n                prepareFreshStack(root, expirationTime);\n                break;\n              }\n            }\n\n            const nextTime = getNextRootExpirationTimeToWorkOn(root);\n\n            if (nextTime !== NoWork && nextTime !== expirationTime) {\n              // There's additional work on this root.\n              break;\n            }\n\n            if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              root.lastPingedTime = lastSuspendedTime;\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspendedAtTime(root, expirationTime);\n        const lastSuspendedTime = root.lastSuspendedTime;\n\n        if (expirationTime === lastSuspendedTime) {\n          root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n        }\n\n        if ( // do not delay if we're inside an act() scope\n        !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current)) {\n          // We're suspended in a state that should be avoided. We'll try to\n          // avoid committing it for as long as the timeouts let us.\n          if (workInProgressRootHasPendingPing) {\n            const lastPingedTime = root.lastPingedTime;\n\n            if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n              // This render was pinged but we didn't get to restart earlier\n              // so try restarting now instead.\n              root.lastPingedTime = expirationTime;\n              prepareFreshStack(root, expirationTime);\n              break;\n            }\n          }\n\n          const nextTime = getNextRootExpirationTimeToWorkOn(root);\n\n          if (nextTime !== NoWork && nextTime !== expirationTime) {\n            // There's additional work on this root.\n            break;\n          }\n\n          if (lastSuspendedTime !== NoWork && lastSuspendedTime !== expirationTime) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            root.lastPingedTime = lastSuspendedTime;\n            break;\n          }\n\n          let msUntilTimeout;\n\n          if (workInProgressRootLatestSuspenseTimeout !== Sync) {\n            // We have processed a suspense config whose expiration time we\n            // can use as the timeout.\n            msUntilTimeout = expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();\n          } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {\n            // This should never normally happen because only new updates\n            // cause delayed states, so we should have processed something.\n            // However, this could also happen in an offscreen tree.\n            msUntilTimeout = 0;\n          } else {\n            // If we don't have a suspense config, we're going to use a\n            // heuristic to determine how long we can suspend.\n            const eventTimeMs = inferTimeFromExpirationTime(workInProgressRootLatestProcessedExpirationTime);\n            const currentTimeMs = now();\n            const timeUntilExpirationMs = expirationTimeToMs(expirationTime) - currentTimeMs;\n            let timeElapsed = currentTimeMs - eventTimeMs;\n\n            if (timeElapsed < 0) {\n              // We get this wrong some time since we estimate the time.\n              timeElapsed = 0;\n            }\n\n            msUntilTimeout = jnd(timeElapsed) - timeElapsed; // Clamp the timeout to the expiration time. TODO: Once the\n            // event time is exact instead of inferred from expiration time\n            // we don't need this.\n\n            if (timeUntilExpirationMs < msUntilTimeout) {\n              msUntilTimeout = timeUntilExpirationMs;\n            }\n          } // Don't bother with a very short suspense time.\n\n\n          if (msUntilTimeout > 10) {\n            // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        if ( // do not delay if we're inside an act() scope\n        !(__DEV__ && flushSuspenseFallbacksInTests && IsThisRendererActing.current) && workInProgressRootLatestProcessedExpirationTime !== Sync && workInProgressRootCanSuspendUsingConfig !== null) {\n          // If we have exceeded the minimum loading delay, which probably\n          // means we have shown a spinner already, we might have to suspend\n          // a bit longer to ensure that the spinner is shown for\n          // enough time.\n          const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(workInProgressRootLatestProcessedExpirationTime, expirationTime, workInProgressRootCanSuspendUsingConfig);\n\n          if (msUntilTimeout > 10) {\n            markRootSuspendedAtTime(root, expirationTime);\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);\n            break;\n          }\n        }\n\n        commitRoot(root);\n        break;\n      }\n\n    default:\n      {\n        invariant(false, 'Unknown root exit status.');\n      }\n  }\n} // 进入 render 阶段, 构建 workInProgress Fiber 树\n\n\nfunction performSyncWorkOnRoot(root) {\n  // 参数 root 为 fiberRoot 对象\n  // 检查是否有过期的任务\n  // 如果没有过期的任务 值为 0\n  // 初始化渲染没有过期的任务待执行\n  const lastExpiredTime = root.lastExpiredTime; // NoWork 值为 0\n  // 如果有过期的任务 将过期时间设置为 lastExpiredTime 否则将过期时间设置为 Sync\n  // 初始渲染过期时间被设置成了 Sync\n\n  const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.'); // 处理 useEffect\n\n  flushPassiveEffects(); // 如果 root 和 workInProgressRoot 不相等\n  // 说明 workInProgressRoot 不存在, 说明还没有构建 workInProgress Fiber 树\n  // workInProgressRoot 为全局变量 默认值为 null, 初始渲染时值为 null\n  // expirationTime => 1073741823\n  // renderExpirationTime => 0\n  // true\n\n  if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n    // 构建 workInProgressFiber 树及 rootFiber\n    prepareFreshStack(root, expirationTime); // 初始渲染不执行 内部条件判断不成立\n\n    startWorkOnPendingInteractions(root, expirationTime);\n  } // workInProgress 如果不为 null\n\n\n  if (workInProgress !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= RenderContext;\n    const prevDispatcher = pushDispatcher(root);\n    const prevInteractions = pushInteractions(root);\n    startWorkLoopTimer(workInProgress);\n\n    do {\n      try {\n        // 以同步的方式开始构建 Fiber 对象\n        workLoopSync();\n        break;\n      } catch (thrownValue) {\n        handleError(root, thrownValue);\n      }\n    } while (true);\n\n    resetContextDependencies();\n    executionContext = prevExecutionContext;\n    popDispatcher(prevDispatcher);\n\n    if (enableSchedulerTracing) {\n      popInteractions(prevInteractions);\n    } // 初始渲染 不执行\n\n\n    if (workInProgressRootExitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      stopInterruptedWorkLoopTimer();\n      prepareFreshStack(root, expirationTime);\n      markRootSuspendedAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n      throw fatalError;\n    }\n\n    if (workInProgress !== null) {\n      // 这是一个同步渲染, 所以我们应该完成整棵树\n      // 无法提交不完整的 root, 此错误可能是由于React中的错误所致. 请提出问题.\n      invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n    } else {\n      // We now have a consistent tree. Because this is a sync render, we\n      // will commit it even if something suspended.\n      stopFinishedWorkLoopTimer(); // 将构建好的新 Fiber 对象存储在 finishedWork 属性中\n      // 提交阶段使用\n\n      root.finishedWork = root.current.alternate;\n      root.finishedExpirationTime = expirationTime; // 结束 render 阶段\n      // 进入 commit 阶段\n\n      finishSyncRender(root);\n    } // Before exiting, make sure there's a callback scheduled for the next\n    // pending level.\n\n\n    ensureRootIsScheduled(root);\n  }\n\n  return null;\n}\n\nfunction finishSyncRender(root) {\n  // 销毁 workInProgress Fiber 树\n  // 因为待提交 Fiber 对象已经被存储在了 root.finishedWork 中\n  workInProgressRoot = null; // 进入 commit 阶段\n\n  commitRoot(root);\n}\n\nexport function flushRoot(root, expirationTime) {\n  markRootExpiredAtTime(root, expirationTime);\n  ensureRootIsScheduled(root);\n\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushSyncCallbackQueue();\n  }\n}\nexport function flushDiscreteUpdates() {\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\n  // as a public API.\n  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {\n    if (__DEV__) {\n      if ((executionContext & RenderContext) !== NoContext) {\n        console.error('unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');\n      }\n    } // We're already rendering, so we can't synchronously flush pending work.\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\n    // like `el.focus()`. Exit.\n\n\n    return;\n  }\n\n  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that\n  // they fire before the next serial event.\n\n  flushPassiveEffects();\n}\nexport function deferredUpdates(fn) {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\nexport function syncUpdates(fn, a, b, c) {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      markRootExpiredAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n    }); // Now flush the immediate queue.\n\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function batchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function batchedEventUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= EventContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function discreteUpdates(fn, a, b, c, d) {\n  const prevExecutionContext = executionContext;\n  executionContext |= DiscreteEventContext;\n\n  try {\n    // Should this\n    return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c, d));\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function unbatchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\nexport function flushSync(fn, a) {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be ' + 'called when React is already rendering.');\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    flushSyncCallbackQueue();\n  }\n}\nexport function flushControlled(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n/**\n * 构建 workInProgressFiber 树及 rootFiber\n */\n\nfunction prepareFreshStack(root, expirationTime) {\n  // 为 FiberRoot 对象添加 finishedWork 属性\n  // finishedWork 表示 render 阶段执行完成后构建的待提交的 Fiber 对象\n  root.finishedWork = null; // 初始化 finishedExpirationTime 值为 0\n\n  root.finishedExpirationTime = NoWork;\n  const timeoutHandle = root.timeoutHandle; // 初始化渲染不执行 timeoutHandle => -1 noTimeout => -1\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  } // 初始化渲染不执行 workInProgress 全局变量 初始化为 null\n  // false\n\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  } // 建构 workInProgress Fiber 树的 fiberRoot 对象\n\n\n  workInProgressRoot = root; // 构建 workInProgress Fiber 树中的 rootFiber\n\n  workInProgress = createWorkInProgress(root.current, null);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false; // true\n\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentDebugFiberInDEV();\n\n      if (workInProgress === null || workInProgress.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // interntionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n        workInProgress = null;\n        return null;\n      }\n\n      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n      }\n\n      throwException(root, workInProgress.return, workInProgress, thrownValue, renderExpirationTime);\n      workInProgress = completeUnitOfWork(workInProgress);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher(root) {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nfunction pushInteractions(root) {\n  if (enableSchedulerTracing) {\n    const prevInteractions = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n    return prevInteractions;\n  }\n\n  return null;\n}\n\nfunction popInteractions(prevInteractions) {\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = prevInteractions;\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nexport function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {\n  if (expirationTime < workInProgressRootLatestProcessedExpirationTime && expirationTime > Idle) {\n    workInProgressRootLatestProcessedExpirationTime = expirationTime;\n  }\n\n  if (suspenseConfig !== null) {\n    if (expirationTime < workInProgressRootLatestSuspenseTimeout && expirationTime > Idle) {\n      workInProgressRootLatestSuspenseTimeout = expirationTime; // Most of the time we only have one config and getting wrong is not bad.\n\n      workInProgressRootCanSuspendUsingConfig = suspenseConfig;\n    }\n  }\n}\nexport function markUnprocessedUpdateTime(expirationTime) {\n  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {\n    workInProgressRootNextUnprocessedUpdateTime = expirationTime;\n  }\n}\nexport function renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nexport function renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there's a lower priority update somewhere else in the tree.\n\n\n  if (workInProgressRootNextUnprocessedUpdateTime !== NoWork && workInProgressRoot !== null) {\n    // Mark the current render as suspended, and then mark that there's a\n    // pending update.\n    // TODO: This should immediately interrupt the current render, instead\n    // of waiting until the next time we yield.\n    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime);\n    markRootUpdatedAtTime(workInProgressRoot, workInProgressRootNextUnprocessedUpdateTime);\n  }\n}\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootCompleted) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nexport function renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction inferTimeFromExpirationTime(expirationTime) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction inferTimeFromExpirationTimeWithSuspenseConfig(expirationTime, suspenseConfig) {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time by subtracting the timeout\n  // that was added to the event time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION);\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // workInProgress 是一个 fiber 对象\n  // 它的值不为 null 意味着该 fiber 对象上仍然有更新要执行\n  // while 方法支撑 render 阶段 所有 fiber 节点的构建\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n} // 构建 Fiber 对象\n\n\nfunction performUnitOfWork(unitOfWork) {\n  // unitOfWork => workInProgress Fiber 树中的 rootFiber\n  // current => currentFiber 树中的 rootFiber\n  const current = unitOfWork.alternate;\n  startWorkTimer(unitOfWork); // 开发环境执行 忽略\n\n  setCurrentDebugFiberInDEV(unitOfWork); // 存储下一个要构建的子级 Fiber 对象\n\n  let next; // 初始渲染 不执行\n  // false\n\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    // beginWork: 从父到子, 构建 Fiber 节点对象\n    // 返回值 next 为当前节点的子节点\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  } // 开发环境执行 忽略\n\n\n  resetCurrentDebugFiberInDEV(); // 为旧的 props 属性赋值\n  // 此次更新后 pendingProps 变为 memoizedProps\n\n  unitOfWork.memoizedProps = unitOfWork.pendingProps; // 如果子节点不存在说明当前节点向下遍历子节点已经到底了\n  // 继续向上返回 遇到兄弟节点 构建兄弟节点的子 Fiber 对象 直到返回到根 Fiber 对象\n\n  if (next === null) {\n    // 从子到父, 构建其余节点 Fiber 对象\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n/**\n * 1. 创建 Fiber 对象\n * 2. 创建每一个节点的真实 DOM 对象并将其添加到 stateNode 属性中\n * 3. 收集要执行 DOM 操作的 Fiber 节点, 组建 effect 链表结构\n */\n\n\nfunction completeUnitOfWork(unitOfWork) {\n  // 为 workInProgress 全局变量重新赋值\n  workInProgress = unitOfWork;\n\n  do {\n    // 获取备份节点\n    // 初始化渲染 非根 Fiber 对象没有备份节点 所以 current 为 null\n    const current = workInProgress.alternate; // 父级 Fiber 对象, 非根 Fiber 对象都有父级\n\n    const returnFiber = workInProgress.return; // 判断传入的 Fiber 对象是否构建完成, 任务调度相关\n    // & 是表示位的与运算, 把左右两边的数字转化为二进制\n    // 然后每一位分别进行比较, 如果相等就为1, 不相等即为0\n    // 此处应用\"位与\"运算符的目的是\"清零\"\n    // true\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // 开发环境代码 忽略\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next; // 如果不能使用分析器的 timer, 直接执行 completeWork\n      // enableProfilerTimer => true\n      // 但此处无论条件是否成立都会执行 completeWork\n\n      if (!enableProfilerTimer || (workInProgress.mode & ProfileMode) === NoMode) {\n        // 重点代码(二)\n        // 创建节点真实 DOM 对象并将其添加到 stateNode 属性中\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        // 否则执行分析器timer, 并执行 completeWork\n        startProfilerTimer(workInProgress); // 创建节点真实 DOM 对象并将其添加到 stateNode 属性中\n\n        next = completeWork(current, workInProgress, renderExpirationTime); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress); // 重点代码(一)\n      // 如果子级存在\n\n      if (next !== null) {\n        // 返回子级 一直返回到 workLoopSync\n        // 再重新执行 performUnitOfWork 构建子级 Fiber 节点对象\n        return next;\n      } // 构建 effect 链表结构\n      // 如果不是根 Fiber 就是 true 否则就是 false\n      // 将子树和此 Fiber 的所有 effect 附加到父级的 effect 列表中\n\n\n      if ( // 如果父 Fiber 存在 并且\n      returnFiber !== null && // 父 Fiber 对象中的 effectTag 为 0\n      (returnFiber.effectTag & Incomplete) === NoEffect) {\n        // 将子树和此 Fiber 的所有副作用附加到父级的 effect 列表上\n        // 以下两个判断的作用是搜集子 Fiber的 effect 到父 Fiber\n        if (returnFiber.firstEffect === null) {\n          // first\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            // next\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          } // last\n\n\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        } // 获取副作用标记\n        // 初始渲染时除[根组件]以外的 Fiber, effectTag 值都为 0, 即不需要执行任何真实DOM操作\n        // 根组件的 effectTag 值为 3, 即需要将此节点对应的真实DOM对象添加到页面中\n\n\n        const effectTag = workInProgress.effectTag; // 创建 effect 列表时跳过 NoWork(0) 和 PerformedWork(1) 标记\n        // PerformedWork 由 React DevTools 读取, 不提交\n        // 初始渲染时 只有遍历到了根组件 判断条件才能成立, 将 effect 链表添加到 rootFiber\n        // 初始渲染 FiberRoot 对象中的 firstEffect 和 lastEffect 都是 App 组件\n        // 因为当所有节点在内存中构建完成后, 只需要一次将所有 DOM 添加到页面中\n\n        if (effectTag > PerformedWork) {\n          // false\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            // 为 fiberRoot 添加 firstEffect\n            returnFiber.firstEffect = workInProgress;\n          } // 为 fiberRoot 添加 lastEffect\n\n\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // 初始渲染不执行\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime); // Because this fiber did not complete, don't reset its expiration time.\n\n      if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); // Include the time spent working on failed children before continuing.\n\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    } // 获取下一个同级 Fiber 对象\n\n\n    const siblingFiber = workInProgress.sibling; // 如果下一个同级 Fiber 对象存在\n\n    if (siblingFiber !== null) {\n      // 返回下一个同级 Fiber 对象\n      return siblingFiber;\n    } // 否则退回父级\n\n\n    workInProgress = returnFiber;\n  } while (workInProgress !== null); // 当执行到这里的时候, 说明遍历到了 root 节点, 已完成遍历\n  // 更新 workInProgressRootExitStatus 的状态为 已完成\n\n\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n\n  return null;\n}\n\nfunction getRemainingExpirationTime(fiber) {\n  const updateExpirationTime = fiber.expirationTime;\n  const childExpirationTime = fiber.childExpirationTime;\n  return updateExpirationTime > childExpirationTime ? updateExpirationTime : childExpirationTime;\n}\n\nfunction resetChildExpirationTime(completedWork) {\n  if (renderExpirationTime !== Never && completedWork.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork; // Bubble up the earliest expiration time.\n\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n\n    const shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;\n    let child = completedWork.child;\n\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root) {\n  // 获取任务优先级 97 => 普通优先级\n  const renderPriorityLevel = getCurrentPriorityLevel(); // 使用最高优先级执行当前任务, 因为 commit 阶段不可以被打断\n  // ImmediatePriority, 优先级为 99, 最高优先级\n\n  runWithPriority(ImmediatePriority, commitRootImpl.bind(null, root, renderPriorityLevel));\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // 触发useEffect回调与其他同步任务\n    // 由于这些任务可能触发新的渲染\n    // 所以这里要一直遍历执行直到没有任务\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null); // 开发环境执行 忽略\n\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Should not already be working.'); // 获取待提交 Fiber 对象 rootFiber\n\n  const finishedWork = root.finishedWork; // 1073741823\n\n  const expirationTime = root.finishedExpirationTime; // 如果没有任务要执行\n\n  if (finishedWork === null) {\n    // 阻止程序继续向下执行\n    return null;\n  } // 重置为默认值\n\n\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n  invariant(finishedWork !== root.current, 'Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.'); // commitRoot 是最后阶段, 不会再被异步调用了\n  // 所以清除 callback 相关的属性\n\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n  root.callbackPriority = NoPriority;\n  root.nextKnownPendingLevel = NoWork;\n  startCommitTimer(); // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  const remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(finishedWork); // 重置优先级相关变量\n\n  markRootFinishedAtTime(root, expirationTime, remainingExpirationTimeBeforeCommit); // false\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {// 这表明我们处理的最后一个根与我们现在提交的根不同\n    // 最常见的情况是在挂起的根超时时发生\n  } // 将 effectList 赋值给 firstEffect\n  // 由于每个 Fiber 的 effectList 只包含他的子孙节点\n  // 所以根节点如果有 effectTag 则不会被包含进来\n  // 所以这里将有 effectTag 的根节点插入到 effectList 尾部\n  // 这样才能保证有 effect 的 fiber 都在 effectList 中\n\n\n  let firstEffect; // finishedWork.effectTag => 0\n  // PerformedWork => 1\n  // false\n\n  if (finishedWork.effectTag > PerformedWork) {\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // 根节点没有 effectTag\n    // 获取要执行 DOM 操作的副作用列表\n    firstEffect = finishedWork.firstEffect;\n  } // 以上代码为 commit 之前所做的准备工作\n  // firstEffect 会在 commit 的三个子阶段会用到\n  // true\n\n\n  if (firstEffect !== null) {\n    // 8\n    const prevExecutionContext = executionContext; // 40\n\n    executionContext |= CommitContext;\n    const prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect; // commit 第一个子阶段\n    // 处理类组件的 getSnapShotBeforeUpdate 生命周期函数\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    } // The next phase is the mutation phase, where we mutate the host tree.\n\n\n    startCommitHostEffectsTimer(); // commit 第二个子阶段\n\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects(root, renderPriorityLevel);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n\n    startCommitLifeCyclesTimer(); // commit 第三个子阶段\n\n    nextEffect = firstEffect;\n\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitLayoutEffects, null, root, expirationTime);\n\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n\n    stopCommitLifeCyclesTimer(); // 重置 nextEffect\n\n    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n\n    requestPaint();\n\n    if (enableSchedulerTracing) {\n      popInteractions(prevInteractions);\n    }\n\n    executionContext = prevExecutionContext;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n  } else {\n    // We are done with the effect chain at this point so let's clear the\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\n    // clear this in flushPassiveEffects.\n    nextEffect = firstEffect;\n\n    while (nextEffect !== null) {\n      const nextNextEffect = nextEffect.nextEffect;\n      nextEffect.nextEffect = null;\n      nextEffect = nextNextEffect;\n    }\n  } // Check if there's remaining work on this root\n\n\n  const remainingExpirationTime = root.firstPendingTime;\n\n  if (remainingExpirationTime !== NoWork) {\n    if (enableSchedulerTracing) {\n      if (spawnedWorkDuringRender !== null) {\n        const expirationTimes = spawnedWorkDuringRender;\n        spawnedWorkDuringRender = null;\n\n        for (let i = 0; i < expirationTimes.length; i++) {\n          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);\n        }\n      }\n\n      schedulePendingInteractions(root, remainingExpirationTime);\n    }\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (enableSchedulerTracing) {\n    if (!rootDidHavePassiveEffects) {\n      // If there are no passive effects, then we can complete the pending interactions.\n      // Otherwise, we'll wait until after the passive effects are flushed.\n      // Wait to do this until after remaining work has been scheduled,\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  onCommitRoot(finishedWork.stateNode, expirationTime); // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n  ensureRootIsScheduled(root);\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbackQueue();\n  return null;\n} // commit 阶段的第一个子阶段\n// 调用类组件的 getSnapshotBeforeUpdate 生命周期函数\n\n\nfunction commitBeforeMutationEffects() {\n  // 循环 effect 链\n  while (nextEffect !== null) {\n    // nextEffect 是 effect 链上从 firstEffect 到 lastEffect\n    // 的每一个需要commit的 fiber 对象\n    // 初始化渲染第一个 nextEffect 为 App 组件\n    // effectTag => 3\n    const effectTag = nextEffect.effectTag; // console.log(effectTag);\n    // nextEffect = null;\n    // return;\n    // 如果 fiber 对象中里有 Snapshot 这个 effectTag 的话\n    // Snapshot 和更新有关系 初始化渲染 不执行\n\n    if ((effectTag & Snapshot) !== NoEffect) {\n      // 开发环境执行 忽略\n      setCurrentDebugFiberInDEV(nextEffect); // 计 effect 的数\n\n      recordEffect(); // 获取当前 fiber 节点\n\n      const current = nextEffect.alternate; // 当 nextEffect 上有 Snapshot 这个 effectTag 时\n      // 执行以下方法, 主要是类组件调用 getSnapshotBeforeUpdate 生命周期函数\n\n      commitBeforeMutationEffectOnFiber(current, nextEffect); // 开发环境执行 忽略\n\n      resetCurrentDebugFiberInDEV();\n    } // 调度 useEffect\n    // 初始化渲染 目前没有 不执行\n    // false\n\n\n    if ((effectTag & Passive) !== NoEffect) {\n      // If there are passive effects, schedule a callback to flush at\n      // the earliest opportunity.\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalPriority, () => {\n          // 触发useEffect\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n} // commit 阶段的第二个子阶段\n// 根据 effectTag 执行 DOM 操作\n\n\nfunction commitMutationEffects(root, renderPriorityLevel) {\n  // 循环 effect 链\n  while (nextEffect !== null) {\n    // 开发环境执行 忽略\n    setCurrentDebugFiberInDEV(nextEffect); // 获取 effectTag\n    // 初始渲染第一次循环为 App 组件\n    // 即将根组件及内部所有内容一次性添加到页面中\n\n    const effectTag = nextEffect.effectTag; // 如果有文本节点, 将 value 置为''\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    } // 更新 ref\n\n\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    } // 根据 effectTag 分别处理\n\n\n    let primaryEffectTag = effectTag & (Placement | Update | Deletion | Hydrating); // 匹配 effectTag\n    // 初始渲染 primaryEffectTag 为 2 匹配到 Placement\n\n    switch (primaryEffectTag) {\n      // 针对该节点及子节点进行插入操作\n      case Placement:\n        {\n          commitPlacement(nextEffect); // effectTag 从 3 变为 1\n          // 从 effect 标签中清除 \"placement\" 重置 effectTag 值\n          // 以便我们知道在调用诸如componentDidMount之类的任何生命周期之前已将其插入。\n\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n      // 插入并更新 DOM\n\n      case PlacementAndUpdate:\n        {\n          // 插入\n          commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is\n          // inserted, before any life-cycles like componentDidMount gets called.\n\n          nextEffect.effectTag &= ~Placement; // 更新\n\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n      // 服务器端渲染\n\n      case Hydrating:\n        {\n          nextEffect.effectTag &= ~Hydrating;\n          break;\n        }\n      // 服务器端渲染\n\n      case HydratingAndUpdate:\n        {\n          nextEffect.effectTag &= ~Hydrating; // Update\n\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n      // 更新 DOM\n\n      case Update:\n        {\n          const current = nextEffect.alternate;\n          commitWork(current, nextEffect);\n          break;\n        }\n      // 删除 DOM\n\n      case Deletion:\n        {\n          commitDeletion(root, nextEffect, renderPriorityLevel);\n          break;\n        }\n    } // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n\n\n    recordEffect();\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n} // commit 阶段的第三个子阶段\n\n\nfunction commitLayoutEffects(root, committedExpirationTime) {\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect); // 此时 effectTag 已经被重置为 1, 表示 DOM 操作已经完成\n\n    const effectTag = nextEffect.effectTag; // 调用生命周期函数和钩子函数\n    // 前提是类组件中调用了生命周期函数\n    // 或者函数组件中调用了 useEffect\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate; // 类组件处理生命周期函数\n      // 函数组件处理钩子函数\n\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedExpirationTime);\n    } // 赋值ref\n    // false\n\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    resetCurrentDebugFiberInDEV(); // 更新循环条件\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (pendingPassiveEffectsRenderPriority !== NoPriority) {\n    const priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority ? NormalPriority : pendingPassiveEffectsRenderPriority;\n    pendingPassiveEffectsRenderPriority = NoPriority;\n    return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\n  }\n}\nexport function enqueuePendingPassiveHookEffectMount(fiber, effect) {\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    pendingPassiveHookEffectsMount.push(effect, fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\nexport function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    pendingPassiveHookEffectsUnmount.push(effect, fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction invokePassiveEffectCreate(effect) {\n  const create = effect.create;\n  effect.destroy = create();\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n  invariant((executionContext & (RenderContext | CommitContext)) === NoContext, 'Cannot flush passive effects while already rendering.');\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  const prevInteractions = pushInteractions(root);\n\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    // It's important that ALL pending passive effect destroy functions are called\n    // before ANY passive effect create functions are called.\n    // Otherwise effects in sibling components might interfere with each other.\n    // e.g. a destroy function in one component may unintentionally override a ref\n    // value set by a create function in another component.\n    // Layout effects have the same constraint.\n    // First pass: Destroy stale passive effects.\n    let unmountEffects = pendingPassiveHookEffectsUnmount;\n    pendingPassiveHookEffectsUnmount = [];\n\n    for (let i = 0; i < unmountEffects.length; i += 2) {\n      const effect = unmountEffects[i];\n      const fiber = unmountEffects[i + 1];\n      const destroy = effect.destroy;\n      effect.destroy = undefined;\n\n      if (typeof destroy === 'function') {\n        if (__DEV__) {\n          setCurrentDebugFiberInDEV(fiber);\n          invokeGuardedCallback(null, destroy, null);\n\n          if (hasCaughtError()) {\n            invariant(fiber !== null, 'Should be working on an effect.');\n            const error = clearCaughtError();\n            captureCommitPhaseError(fiber, error);\n          }\n\n          resetCurrentDebugFiberInDEV();\n        } else {\n          try {\n            destroy();\n          } catch (error) {\n            invariant(fiber !== null, 'Should be working on an effect.');\n            captureCommitPhaseError(fiber, error);\n          }\n        }\n      }\n    } // Second pass: Create new passive effects.\n\n\n    let mountEffects = pendingPassiveHookEffectsMount;\n    pendingPassiveHookEffectsMount = [];\n\n    for (let i = 0; i < mountEffects.length; i += 2) {\n      const effect = mountEffects[i];\n      const fiber = mountEffects[i + 1];\n\n      if (__DEV__) {\n        setCurrentDebugFiberInDEV(fiber);\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\n\n        if (hasCaughtError()) {\n          invariant(fiber !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(fiber, error);\n        }\n\n        resetCurrentDebugFiberInDEV();\n      } else {\n        try {\n          const create = effect.create;\n          effect.destroy = create();\n        } catch (error) {\n          invariant(fiber !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(fiber, error);\n        }\n      }\n    }\n  } else {\n    // Note: This currently assumes there are no passive effects on the root fiber\n    // because the root is not part of its own effect list.\n    // This could change in the future.\n    let effect = root.current.firstEffect;\n\n    while (effect !== null) {\n      if (__DEV__) {\n        setCurrentDebugFiberInDEV(effect);\n        invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n\n        if (hasCaughtError()) {\n          invariant(effect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(effect, error);\n        }\n\n        resetCurrentDebugFiberInDEV();\n      } else {\n        try {\n          commitPassiveHookEffects(effect);\n        } catch (error) {\n          invariant(effect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(effect, error);\n        }\n      }\n\n      const nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC\n\n      effect.nextEffect = null;\n      effect = nextNextEffect;\n    }\n  }\n\n  if (enableSchedulerTracing) {\n    popInteractions(prevInteractions);\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n\n  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nexport function markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber, error) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(fiber, errorInfo, // TODO: This is always sync\n        Sync);\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n\n        if (root !== null) {\n          ensureRootIsScheduled(root);\n          schedulePendingInteractions(root, Sync);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n}\nexport function pingSuspendedRoot(root, thenable, suspendedTime) {\n  const pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, we'll always suspend so we can always\n    // restart. If we're suspended without any updates, it might be a retry.\n    // If it's early in the retry we can restart. We can't know for sure\n    // whether we'll eventually process an update during this render pass,\n    // but it's somewhat unlikely that we get to a ping before that, since\n    // getting to the root most update is usually very fast.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && workInProgressRootLatestProcessedExpirationTime === Sync && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root. Don't need to schedule a ping because\n      // we're already working on this tree.\n      prepareFreshStack(root, renderExpirationTime);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootHasPendingPing = true;\n    }\n\n    return;\n  }\n\n  if (!isRootSuspendedAtTime(root, suspendedTime)) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const lastPingedTime = root.lastPingedTime;\n\n  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  } // Mark the time at which this ping was scheduled.\n\n\n  root.lastPingedTime = suspendedTime;\n\n  if (!enableTrainModelFix && root.finishedExpirationTime === suspendedTime) {\n    // If there's a pending fallback waiting to commit, throw it away.\n    root.finishedExpirationTime = NoWork;\n    root.finishedWork = null;\n  }\n\n  ensureRootIsScheduled(root);\n  schedulePendingInteractions(root, suspendedTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryTime) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new expiration time.\n  if (retryTime === NoWork) {\n    const suspenseConfig = null; // Retries don't carry over the already committed update.\n\n    const currentTime = requestCurrentTimeForUpdate();\n    retryTime = computeExpirationForFiber(currentTime, boundaryFiber, suspenseConfig);\n  } // TODO: Special case idle priority?\n\n\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, retryTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber) {\n  const suspenseState = boundaryFiber.memoizedState;\n  let retryTime = NoWork;\n\n  if (suspenseState !== null) {\n    retryTime = suspenseState.retryTime;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\nexport function resolveRetryThenable(boundaryFiber, thenable) {\n  let retryTime = NoWork; // Default\n\n  let retryCache;\n\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState = boundaryFiber.memoizedState;\n\n        if (suspenseState !== null) {\n          retryTime = suspenseState.retryTime;\n        }\n\n        break;\n\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n\n      default:\n        invariant(false, 'Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction computeMsUntilSuspenseLoadingDelay(mostRecentEventTime, committedExpirationTime, suspenseConfig) {\n  const busyMinDurationMs = suspenseConfig.busyMinDurationMs | 0;\n\n  if (busyMinDurationMs <= 0) {\n    return 0;\n  }\n\n  const busyDelayMs = suspenseConfig.busyDelayMs | 0; // Compute the time until this render pass would expire.\n\n  const currentTimeMs = now();\n  const eventTimeMs = inferTimeFromExpirationTimeWithSuspenseConfig(mostRecentEventTime, suspenseConfig);\n  const timeElapsed = currentTimeMs - eventTimeMs;\n\n  if (timeElapsed <= busyDelayMs) {\n    // If we haven't yet waited longer than the initial delay, we don't\n    // have to wait any additional time.\n    return 0;\n  }\n\n  const msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed; // This is the value that is passed to `setTimeout`.\n\n  return msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  // NESTED_UPDATE_LIMIT => 50\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(false, 'Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      console.error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(fiberThatReceivedUpdate, updateExpirationTime) {\n  if (enableUserTimingAPI && workInProgressRoot !== null && updateExpirationTime > renderExpirationTime) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent = null;\n\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n\n    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n\n    if (deferPassiveEffectCleanupDuringUnmount && runAllPassiveEffectDestroysBeforeCreates) {\n      // If there are pending passive effects unmounts for this Fiber,\n      // we can assume that they would have prevented this update.\n      if (pendingPassiveHookEffectsUnmount.indexOf(fiber) >= 0) {\n        return;\n      }\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n\n    console.error(\"Can't perform a React state update on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.%s', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function', getStackByFiberInDevAndProd(fiber));\n  }\n}\n\nlet beginWork;\n\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, originalBeginWork, null, current, unitOfWork, expirationTime);\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\n\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (ReactCurrentDebugFiberIsRenderingInDEV && (executionContext & RenderContext) !== NoContext) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            const renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            const dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              const setStateComponentName = getComponentName(fiber.type) || 'Unknown';\n              console.error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://fb.me/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              console.error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n} // a 'shared' variable that changes when act() opens/closes in tests.\n\n\nexport const IsThisRendererActing = {\n  current: false\n};\nexport function warnIfNotScopedWithMatchingAct(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {\n      console.error(\"It looks like you're using the wrong act() around your test interactions.\\n\" + 'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' + '// for react-dom:\\n' + \"import {act} from 'react-dom/test-utils';\\n\" + '// ...\\n' + 'act(() => ...);\\n\\n' + '// for react-test-renderer:\\n' + \"import TestRenderer from 'react-test-renderer';\\n\" + 'const {act} = TestRenderer;\\n' + '// ...\\n' + 'act(() => ...);' + '%s', getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\n      console.error('An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (warnsIfNotActing === true && executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {\n      console.error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://fb.me/react-wrap-tests-with-act' + '%s', getComponentName(fiber.type), getStackByFiberInDevAndProd(fiber));\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.\n\nlet didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked\n// scheduler is the actual recommendation. The alternative could be a testing build,\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\n// to get their tests right.\n\nexport function warnIfUnmockedScheduler(fiber) {\n  if (__DEV__) {\n    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\n        didWarnAboutUnmockedScheduler = true;\n        console.error('In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://fb.me/react-mock-scheduler');\n      } else if (warnAboutUnmockedScheduler === true) {\n        didWarnAboutUnmockedScheduler = true;\n        console.error('Starting from React v17, the \"scheduler\" module will need to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \\n' + \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" + 'For more info, visit https://fb.me/react-mock-scheduler');\n      }\n    }\n  }\n}\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nexport function markSpawnedWork(expirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (spawnedWorkDuringRender === null) {\n    spawnedWorkDuringRender = [expirationTime];\n  } else {\n    spawnedWorkDuringRender.push(expirationTime);\n  }\n}\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions)); // Update the pending async work count for the current interactions.\n\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction schedulePendingInteractions(root, expirationTime) {\n  // This is called when work is scheduled on a root.\n  // It associates the current interactions with the newly-scheduled expiration.\n  // They will be restored when that expiration is later committed.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  scheduleInteractions(root, expirationTime, __interactionsRef.current);\n}\n\nfunction startWorkOnPendingInteractions(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  } // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n\n\n  const interactions = new Set();\n  root.pendingInteractionMap.forEach((scheduledInteractions, scheduledExpirationTime) => {\n    if (scheduledExpirationTime >= expirationTime) {\n      scheduledInteractions.forEach(interaction => interactions.add(interaction));\n    }\n  }); // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\n  // without having to recalculate it. We will also use it in commitWork() to\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\n  // way to access it when the onCommitRoot() hook is called.\n\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case– leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach((scheduledInteractions, scheduledExpirationTime) => {\n      // Only decrement the pending interaction count if we're done.\n      // If there's still work at the current priority,\n      // That indicates that we are waiting for suspense data.\n      if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n        pendingInteractionMap.delete(scheduledExpirationTime);\n        scheduledInteractions.forEach(interaction => {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // If the subscriber throws, rethrow it in a separate task\n              scheduleCallback(ImmediatePriority, () => {\n                throw error;\n              });\n            }\n          }\n        });\n      }\n    });\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js"],"names":["warnAboutDeprecatedLifecycles","deferPassiveEffectCleanupDuringUnmount","runAllPassiveEffectDestroysBeforeCreates","enableUserTimingAPI","enableSuspenseServerRenderer","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableProfilerTimer","enableSchedulerTracing","warnAboutUnmockedScheduler","flushSuspenseFallbacksInTests","disableSchedulerTimeoutBasedOnReactExpirationTime","enableTrainModelFix","ReactSharedInternals","invariant","scheduleCallback","cancelCallback","getCurrentPriorityLevel","runWithPriority","shouldYield","requestPaint","now","NoPriority","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","flushSyncCallbackQueue","scheduleSyncCallback","Scheduler","__interactionsRef","__subscriberRef","prepareForCommit","resetAfterCommit","scheduleTimeout","cancelTimeout","noTimeout","warnsIfNotActing","createWorkInProgress","assignFiberPropertiesInDEV","isRootSuspendedAtTime","markRootSuspendedAtTime","markRootFinishedAtTime","markRootUpdatedAtTime","markRootExpiredAtTime","NoMode","StrictMode","ProfileMode","BlockingMode","ConcurrentMode","HostRoot","ClassComponent","SuspenseComponent","SuspenseListComponent","FunctionComponent","ForwardRef","MemoComponent","SimpleMemoComponent","Block","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","Ref","ContentReset","Snapshot","Callback","Passive","Incomplete","HostEffectMask","Hydrating","HydratingAndUpdate","NoWork","Sync","Never","msToExpirationTime","expirationTimeToMs","computeInteractiveExpiration","computeAsyncExpiration","computeSuspenseExpiration","inferPriorityFromExpirationTime","LOW_PRIORITY_EXPIRATION","Batched","Idle","beginWork","originalBeginWork","completeWork","unwindWork","unwindInterruptedWork","throwException","createRootErrorUpdate","createClassErrorUpdate","commitBeforeMutationLifeCycles","commitBeforeMutationEffectOnFiber","commitLifeCycles","commitLayoutEffectOnFiber","commitPassiveHookEffects","commitPlacement","commitWork","commitDeletion","commitDetachRef","commitAttachRef","commitResetTextContent","enqueueUpdate","resetContextDependencies","resetHooksAfterThrow","ContextOnlyDispatcher","createCapturedValue","recordCommitTime","startProfilerTimer","stopProfilerTimerIfRunningAndRecordDelta","getComponentName","ReactStrictModeWarnings","isRendering","ReactCurrentDebugFiberIsRenderingInDEV","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","getStackByFiberInDevAndProd","recordEffect","recordScheduleUpdate","startWorkTimer","stopWorkTimer","stopFailedWorkTimer","startWorkLoopTimer","stopWorkLoopTimer","startCommitTimer","stopCommitTimer","startCommitSnapshotEffectsTimer","stopCommitSnapshotEffectsTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","invokeGuardedCallback","hasCaughtError","clearCaughtError","onCommitRoot","ceil","Math","ReactCurrentDispatcher","ReactCurrentOwner","IsSomeRendererActing","NoContext","BatchedContext","EventContext","DiscreteEventContext","LegacyUnbatchedContext","RenderContext","CommitContext","RootIncomplete","RootFatalErrored","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","executionContext","workInProgressRoot","workInProgress","renderExpirationTime","workInProgressRootExitStatus","workInProgressRootFatalError","workInProgressRootLatestProcessedExpirationTime","workInProgressRootLatestSuspenseTimeout","workInProgressRootCanSuspendUsingConfig","workInProgressRootNextUnprocessedUpdateTime","workInProgressRootHasPendingPing","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","nextEffect","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsRenderPriority","pendingPassiveEffectsExpirationTime","pendingPassiveHookEffectsMount","pendingPassiveHookEffectsUnmount","rootsWithPendingDiscreteUpdates","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","interruptedBy","spawnedWorkDuringRender","currentEventTime","requestCurrentTimeForUpdate","getCurrentTime","computeExpirationForFiber","currentTime","fiber","suspenseConfig","mode","priorityLevel","expirationTime","timeoutMs","scheduleUpdateOnFiber","checkForNestedUpdates","warnAboutRenderPhaseUpdatesInDEV","root","markUpdateTimeFromFiberToRoot","warnAboutUpdateOnUnmountedFiberInDEV","checkForInterruption","schedulePendingInteractions","performSyncWorkOnRoot","ensureRootIsScheduled","Map","lastDiscreteTime","get","undefined","set","scheduleWork","alternate","node","return","tag","stateNode","childExpirationTime","markUnprocessedUpdateTime","getNextRootExpirationTimeToWorkOn","lastExpiredTime","firstPendingTime","lastPingedTime","nextKnownPendingLevel","nextLevel","callbackExpirationTime","callbackPriority","callbackNode","bind","existingCallbackNode","existingCallbackPriority","existingCallbackExpirationTime","performConcurrentWorkOnRoot","timeout","didTimeout","originalCallbackNode","flushPassiveEffects","prepareFreshStack","startWorkOnPendingInteractions","prevExecutionContext","prevDispatcher","pushDispatcher","prevInteractions","pushInteractions","workLoopConcurrent","thrownValue","handleError","popDispatcher","popInteractions","fatalError","stopInterruptedWorkLoopTimer","stopFinishedWorkLoopTimer","finishedWork","current","finishedExpirationTime","finishConcurrentRender","exitStatus","lastSuspendedTime","getRemainingExpirationTime","hasNotProcessedNewUpdates","__DEV__","IsThisRendererActing","msUntilTimeout","nextTime","timeoutHandle","commitRoot","eventTimeMs","inferTimeFromExpirationTime","currentTimeMs","timeUntilExpirationMs","timeElapsed","jnd","computeMsUntilSuspenseLoadingDelay","workLoopSync","finishSyncRender","flushRoot","flushDiscreteUpdates","console","error","flushPendingDiscreteUpdates","deferredUpdates","fn","syncUpdates","a","b","c","roots","forEach","batchedUpdates","batchedEventUpdates","discreteUpdates","d","unbatchedUpdates","flushSync","flushControlled","interruptedWork","discardPendingWarnings","completeUnitOfWork","yetAnotherThrownValue","memoizedInteractions","markCommitTimeOfFallback","markRenderEventTimeAndConfig","renderDidSuspend","renderDidSuspendDelayIfPossible","renderDidError","renderHasNotSuspendedYet","earliestExpirationTimeMs","inferTimeFromExpirationTimeWithSuspenseConfig","performUnitOfWork","unitOfWork","next","memoizedProps","pendingProps","returnFiber","effectTag","resetChildExpirationTime","firstEffect","lastEffect","actualDuration","child","sibling","siblingFiber","updateExpirationTime","completedWork","newChildExpirationTime","treeBaseDuration","selfBaseDuration","shouldBubbleActualDurations","childUpdateExpirationTime","childChildExpirationTime","renderPriorityLevel","commitRootImpl","flushRenderPhaseStrictModeWarningsInDEV","remainingExpirationTimeBeforeCommit","containerInfo","commitBeforeMutationEffects","captureCommitPhaseError","commitMutationEffects","commitLayoutEffects","rootDidHavePassiveEffects","nextNextEffect","remainingExpirationTime","expirationTimes","i","length","scheduleInteractions","finishPendingInteractions","primaryEffectTag","committedExpirationTime","flushPassiveEffectsImpl","enqueuePendingPassiveHookEffectMount","effect","push","enqueuePendingPassiveHookEffectUnmount","invokePassiveEffectCreate","create","destroy","unmountEffects","mountEffects","isAlreadyFailedLegacyErrorBoundary","instance","has","markLegacyErrorBoundaryAsFailed","Set","add","prepareToThrowUncaughtError","onUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","sourceFiber","errorInfo","update","ctor","type","getDerivedStateFromError","componentDidCatch","pingSuspendedRoot","thenable","suspendedTime","pingCache","delete","retryTimedOutBoundary","boundaryFiber","retryTime","retryDehydratedSuspenseBoundary","suspenseState","memoizedState","resolveRetryThenable","retryCache","mostRecentEventTime","busyMinDurationMs","busyDelayMs","flushLegacyContextWarning","flushPendingUnsafeLifecycleWarnings","didCompleteRoot","fiberThatReceivedUpdate","didWarnStateUpdateForUnmountedComponent","indexOf","componentName","dummyFiber","originalWorkInProgressCopy","originalError","then","replayError","didWarnAboutUpdateInRender","didWarnAboutUpdateInRenderForAnotherComponent","renderingComponentName","dedupeKey","setStateComponentName","warnIfNotScopedWithMatchingAct","warnIfNotCurrentlyActingEffectsInDEV","warnIfNotCurrentlyActingUpdatesInDEV","warnIfNotCurrentlyActingUpdatesInDev","didWarnAboutUnmockedScheduler","warnIfUnmockedScheduler","unstable_flushAllWithoutAsserting","computeThreadID","interactionThreadID","markSpawnedWork","interactions","size","pendingInteractionMap","pendingInteractions","interaction","__count","subscriber","threadID","onWorkScheduled","scheduledInteractions","scheduledExpirationTime","onWorkStarted","earliestRemainingTimeAfterCommit","onWorkStopped","onInteractionScheduledWorkCompleted"],"mappings":"AAAA;;;;;;;;AAkBA,SACEA,6BADF,EAEEC,sCAFF,EAGEC,wCAHF,EAIEC,mBAJF,EAKEC,4BALF,EAMEC,+CANF,EAOEC,mBAPF,EAQEC,sBARF,EASEC,0BATF,EAUEC,6BAVF,EAWEC,iDAXF,EAYEC,mBAZF,QAaO,0BAbP;AAcA,OAAOC,oBAAP,MAAiC,6BAAjC;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AAEA,SACEC,gBADF,EAEEC,cAFF,EAGEC,uBAHF,EAIEC,eAJF,EAKEC,WALF,EAMEC,YANF,EAOEC,GAPF,EAQEC,UARF,EASEC,iBATF,EAUEC,oBAVF,EAWEC,cAXF,EAYEC,WAZF,EAaEC,YAbF,EAcEC,sBAdF,EAeEC,oBAfF,QAgBO,iCAhBP,C,CAkBA;;AACA,OAAO,KAAKC,SAAZ,MAA2B,WAA3B;AAEA,SAAQC,iBAAR,EAA2BC,eAA3B,QAAiD,mBAAjD;AAEA,SACEC,gBADF,EAEEC,gBAFF,EAGEC,eAHF,EAIEC,aAJF,EAKEC,SALF,EAMEC,gBANF,QAOO,wBAPP;AASA,SAAQC,oBAAR,EAA8BC,0BAA9B,QAA+D,cAA/D;AACA,SACEC,qBADF,EAEEC,uBAFF,EAGEC,sBAHF,EAIEC,qBAJF,EAKEC,qBALF,QAMO,kBANP;AAOA,SACEC,MADF,EAEEC,UAFF,EAGEC,WAHF,EAIEC,YAJF,EAKEC,cALF,QAMO,mBANP;AAOA,SACEC,QADF,EAEEC,cAFF,EAGEC,iBAHF,EAIEC,qBAJF,EAKEC,iBALF,EAMEC,UANF,EAOEC,aAPF,EAQEC,mBARF,EASEC,KATF,QAUO,sBAVP;AAWA,SACEC,QADF,EAEEC,aAFF,EAGEC,SAHF,EAIEC,MAJF,EAKEC,kBALF,EAMEC,QANF,EAOEC,GAPF,EAQEC,YARF,EASEC,QATF,EAUEC,QAVF,EAWEC,OAXF,EAYEC,UAZF,EAaEC,cAbF,EAcEC,SAdF,EAeEC,kBAfF,QAgBO,4BAhBP;AAiBA,SACEC,MADF,EAEEC,IAFF,EAGEC,KAHF,EAIEC,kBAJF,EAKEC,kBALF,EAMEC,4BANF,EAOEC,sBAPF,EAQEC,yBARF,EASEC,+BATF,EAUEC,uBAVF,EAWEC,OAXF,EAYEC,IAZF,QAaO,4BAbP;AAcA,SAAQC,SAAS,IAAIC,iBAArB,QAA6C,uBAA7C;AACA,SAAQC,YAAR,QAA2B,0BAA3B;AACA,SAAQC,UAAR,EAAoBC,qBAApB,QAAgD,wBAAhD;AACA,SACEC,cADF,EAEEC,qBAFF,EAGEC,sBAHF,QAIO,mBAJP;AAKA,SACEC,8BAA8B,IAAIC,iCADpC,EAEEC,gBAAgB,IAAIC,yBAFtB,EAGEC,wBAHF,EAIEC,eAJF,EAKEC,UALF,EAMEC,cANF,EAOEC,eAPF,EAQEC,eARF,EASEC,sBATF,QAUO,wBAVP;AAWA,SAAQC,aAAR,QAA4B,oBAA5B;AACA,SAAQC,wBAAR,QAAuC,wBAAvC;AACA,SAAQC,oBAAR,EAA8BC,qBAA9B,QAA0D,mBAA1D;AACA,SAAQC,mBAAR,QAAkC,sBAAlC;AAEA,SACEC,gBADF,EAEEC,kBAFF,EAGEC,wCAHF,QAIO,sBAJP,C,CAMA;;AACA,OAAOC,gBAAP,MAA6B,yBAA7B;AACA,OAAOC,uBAAP,MAAoC,2BAApC;AACA,SACEC,WAAW,IAAIC,sCADjB,EAEEC,iBAAiB,IAAIC,2BAFvB,EAGEC,eAAe,IAAIC,yBAHrB,EAIEC,2BAJF,QAKO,qBALP;AAMA,SACEC,YADF,EAEEC,oBAFF,EAGEC,cAHF,EAIEC,aAJF,EAKEC,mBALF,EAMEC,kBANF,EAOEC,iBAPF,EAQEC,gBARF,EASEC,eATF,EAUEC,+BAVF,EAWEC,8BAXF,EAYEC,2BAZF,EAaEC,0BAbF,EAcEC,0BAdF,EAeEC,yBAfF,QAgBO,uBAhBP;AAiBA,SACEC,qBADF,EAEEC,cAFF,EAGEC,gBAHF,QAIO,wBAJP;AAKA,SAAQC,YAAR,QAA2B,0BAA3B;AAEA,MAAMC,IAAI,GAAGC,IAAI,CAACD,IAAlB;AAEA,MAAM;AACJE,EAAAA,sBADI;AAEJC,EAAAA,iBAFI;AAGJC,EAAAA;AAHI,IAIFrI,oBAJJ;AAQA,MAAMsI,SAAS;AAAG;AAAyB,QAA3C;AACA,MAAMC,cAAc;AAAG;AAAoB,QAA3C;AACA,MAAMC,YAAY;AAAG;AAAsB,QAA3C;AACA,MAAMC,oBAAoB;AAAG;AAAc,QAA3C;AACA,MAAMC,sBAAsB;AAAG;AAAY,QAA3C;AACA,MAAMC,aAAa;AAAG;AAAqB,QAA3C;AACA,MAAMC,aAAa;AAAG;AAAqB,QAA3C;AAGA,MAAMC,cAAc,GAAG,CAAvB;AACA,MAAMC,gBAAgB,GAAG,CAAzB;AACA,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,aAAa,GAAG,CAAtB;AACA,MAAMC,sBAAsB,GAAG,CAA/B;AACA,MAAMC,aAAa,GAAG,CAAtB;AASA;AACA,IAAIC,gBAAkC,GAAGb,SAAzC,C,CACA;;AACA,IAAIc,kBAAoC,GAAG,IAA3C,C,CACA;;AACA,IAAIC,cAA4B,GAAG,IAAnC,C,CACA;;AACA,IAAIC,oBAAoC,GAAGxF,MAA3C,C,CACA;;AACA,IAAIyF,4BAA4C,GAAGV,cAAnD,C,CACA;;AACA,IAAIW,4BAAmC,GAAG,IAA1C,C,CACA;AACA;AACA;AACA;;AACA,IAAIC,+CAA+D,GAAG1F,IAAtE;AACA,IAAI2F,uCAAuD,GAAG3F,IAA9D;AACA,IAAI4F,uCAA8D,GAAG,IAArE,C,CACA;AACA;;AACA,IAAIC,2CAA2D,GAAG9F,MAAlE,C,CAEA;AACA;AACA;;AACA,IAAI+F,gCAAyC,GAAG,KAAhD,C,CACA;AACA;;AACA,IAAIC,4BAAoC,GAAG,CAA3C;AACA,MAAMC,oBAA4B,GAAG,GAArC;AAEA,IAAIC,UAAwB,GAAG,IAA/B;AACA,IAAIC,gBAAgB,GAAG,KAAvB;AACA,IAAIC,kBAAkB,GAAG,IAAzB;AACA,IAAIC,sCAAyD,GAAG,IAAhE;AAEA,IAAIC,0BAAmC,GAAG,KAA1C;AACA,IAAIC,6BAA+C,GAAG,IAAtD;AACA,IAAIC,mCAAuD,GAAG7J,UAA9D;AACA,IAAI8J,mCAAmD,GAAGzG,MAA1D;AACA,IAAI0G,8BAAyD,GAAG,EAAhE;AACA,IAAIC,gCAA2D,GAAG,EAAlE;AAEA,IAAIC,+BAGI,GAAG,IAHX,C,CAKA;;AACA,MAAMC,mBAAmB,GAAG,EAA5B;AACA,IAAIC,iBAAyB,GAAG,CAAhC;AACA,IAAIC,qBAAuC,GAAG,IAA9C;AAEA,MAAMC,2BAA2B,GAAG,EAApC;AACA,IAAIC,wBAAgC,GAAG,CAAvC;AAEA,IAAIC,aAA2B,GAAG,IAAlC,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,uBAAqD,GAAG,IAA5D,C,CAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA,IAAIC,gBAAgC,GAAGpH,MAAvC;AAEA,OAAO,SAASqH,2BAAT,GAAuC;AAC5C,MAAI,CAAChC,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SAA7D,EAAwE;AACtE;AACA,WAAOrE,kBAAkB,CAACzD,GAAG,EAAJ,CAAzB;AACD,GAJ2C,CAK5C;;;AACA,MAAI0K,gBAAgB,KAAKpH,MAAzB,EAAiC;AAC/B;AACA,WAAOoH,gBAAP;AACD,GAT2C,CAU5C;;;AACAA,EAAAA,gBAAgB,GAAGjH,kBAAkB,CAACzD,GAAG,EAAJ,CAArC;AACA,SAAO0K,gBAAP;AACD;AAED,OAAO,SAASE,cAAT,GAA0B;AAC/B,SAAOnH,kBAAkB,CAACzD,GAAG,EAAJ,CAAzB;AACD;AAED,OAAO,SAAS6K,yBAAT,CACLC,WADK,EAELC,KAFK,EAGLC,cAHK,EAIW;AAChB,QAAMC,IAAI,GAAGF,KAAK,CAACE,IAAnB;;AACA,MAAI,CAACA,IAAI,GAAGrJ,YAAR,MAA0BH,MAA9B,EAAsC;AACpC,WAAO8B,IAAP;AACD;;AAED,QAAM2H,aAAa,GAAGtL,uBAAuB,EAA7C;;AACA,MAAI,CAACqL,IAAI,GAAGpJ,cAAR,MAA4BJ,MAAhC,EAAwC;AACtC,WAAOyJ,aAAa,KAAKhL,iBAAlB,GAAsCqD,IAAtC,GAA6CS,OAApD;AACD;;AAED,MAAI,CAAC2E,gBAAgB,GAAGR,aAApB,MAAuCL,SAA3C,EAAsD;AACpD;AACA;AACA,WAAOgB,oBAAP;AACD;;AAED,MAAIqC,cAAJ;;AACA,MAAIH,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACAG,IAAAA,cAAc,GAAGtH,yBAAyB,CACxCiH,WADwC,EAExCE,cAAc,CAACI,SAAf,GAA2B,CAA3B,IAAgCrH,uBAFQ,CAA1C;AAID,GAND,MAMO;AACL;AACA,YAAQmH,aAAR;AACE,WAAKhL,iBAAL;AACEiL,QAAAA,cAAc,GAAG5H,IAAjB;AACA;;AACF,WAAKpD,oBAAL;AACE;AACAgL,QAAAA,cAAc,GAAGxH,4BAA4B,CAACmH,WAAD,CAA7C;AACA;;AACF,WAAK1K,cAAL;AACA,WAAKC,WAAL;AAAkB;AAChB;AACA8K,QAAAA,cAAc,GAAGvH,sBAAsB,CAACkH,WAAD,CAAvC;AACA;;AACF,WAAKxK,YAAL;AACE6K,QAAAA,cAAc,GAAGlH,IAAjB;AACA;;AACF;AACExE,QAAAA,SAAS,CAAC,KAAD,EAAQ,iCAAR,CAAT;AAjBJ;AAmBD,GA7Ce,CA+ChB;AACA;AACA;AACA;AACA;;;AACA,MAAImJ,kBAAkB,KAAK,IAAvB,IAA+BuC,cAAc,KAAKrC,oBAAtD,EAA4E;AAC1E;AACAqC,IAAAA,cAAc,IAAI,CAAlB;AACD;;AAED,SAAOA,cAAP;AACD;AAED;;;;AAGA,OAAO,SAASE,qBAAT,CACLN,KADK,EAELI,cAFK,EAGL;AACA;;;;;AAIA;;;;;;AAMAG,EAAAA,qBAAqB,GAXrB,CAYA;;AACAC,EAAAA,gCAAgC,CAACR,KAAD,CAAhC,CAbA,CAcA;;AACA,QAAMS,IAAI,GAAGC,6BAA6B,CAACV,KAAD,EAAQI,cAAR,CAA1C;;AACA,MAAIK,IAAI,KAAK,IAAb,EAAmB;AACjB;AACAE,IAAAA,oCAAoC,CAACX,KAAD,CAApC;AACA;AACD,GApBD,CAqBA;AACA;;;AACAY,EAAAA,oBAAoB,CAACZ,KAAD,EAAQI,cAAR,CAApB,CAvBA,CAyBA;;AACA5E,EAAAA,oBAAoB,GA1BpB,CA4BA;AACA;;AACA,QAAM2E,aAAa,GAAGtL,uBAAuB,EAA7C,CA9BA,CA+BA;;AACA,MAAIuL,cAAc,KAAK5H,IAAvB,EAA6B;AAC3B,SACE;AACA,KAACoF,gBAAgB,GAAGT,sBAApB,MAAgDJ,SAAhD,IACA;AACA,KAACa,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SAJ3D,EAKE;AACA;AACA;AACA8D,MAAAA,2BAA2B,CAACJ,IAAD,EAAOL,cAAP,CAA3B,CAHA,CAIA;;AACAU,MAAAA,qBAAqB,CAACL,IAAD,CAArB;AACD,KAXD,MAWO;AACLM,MAAAA,qBAAqB,CAACN,IAAD,CAArB;AACAI,MAAAA,2BAA2B,CAACJ,IAAD,EAAOL,cAAP,CAA3B;;AACA,UAAIxC,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC;AACA;AACA;AACA;AACA;AACAvH,QAAAA,sBAAsB;AACvB;AACF;AACF,GAxBD,MAwBO;AACLuL,IAAAA,qBAAqB,CAACN,IAAD,CAArB;AACAI,IAAAA,2BAA2B,CAACJ,IAAD,EAAOL,cAAP,CAA3B;AACD,GA3DD,CA4DA;;;AACA,MACE,CAACxC,gBAAgB,GAAGV,oBAApB,MAA8CH,SAA9C,MACA;AACA;AACCoD,EAAAA,aAAa,KAAK/K,oBAAlB,IACC+K,aAAa,KAAKhL,iBAJpB,CADF,EAME;AACA;AACA;AACA,QAAIgK,+BAA+B,KAAK,IAAxC,EAA8C;AAC5CA,MAAAA,+BAA+B,GAAG,IAAI6B,GAAJ,CAAQ,CAAC,CAACP,IAAD,EAAOL,cAAP,CAAD,CAAR,CAAlC;AACD,KAFD,MAEO;AACL,YAAMa,gBAAgB,GAAG9B,+BAA+B,CAAC+B,GAAhC,CAAoCT,IAApC,CAAzB;;AACA,UAAIQ,gBAAgB,KAAKE,SAArB,IAAkCF,gBAAgB,GAAGb,cAAzD,EAAyE;AACvEjB,QAAAA,+BAA+B,CAACiC,GAAhC,CAAoCX,IAApC,EAA0CL,cAA1C;AACD;AACF;AACF;AACF;AACD,OAAO,MAAMiB,YAAY,GAAGf,qBAArB,C,CAEP;AACA;AACA;AACA;;AACA,SAASI,6BAAT,CAAuCV,KAAvC,EAA8CI,cAA9C,EAA8D;AAC5D;AACA,MAAIJ,KAAK,CAACI,cAAN,GAAuBA,cAA3B,EAA2C;AACzCJ,IAAAA,KAAK,CAACI,cAAN,GAAuBA,cAAvB;AACD;;AACD,MAAIkB,SAAS,GAAGtB,KAAK,CAACsB,SAAtB;;AACA,MAAIA,SAAS,KAAK,IAAd,IAAsBA,SAAS,CAAClB,cAAV,GAA2BA,cAArD,EAAqE;AACnEkB,IAAAA,SAAS,CAAClB,cAAV,GAA2BA,cAA3B;AACD,GAR2D,CAS5D;;;AACA,MAAImB,IAAI,GAAGvB,KAAK,CAACwB,MAAjB;AACA,MAAIf,IAAI,GAAG,IAAX;;AACA,MAAIc,IAAI,KAAK,IAAT,IAAiBvB,KAAK,CAACyB,GAAN,KAAc1K,QAAnC,EAA6C;AAC3C0J,IAAAA,IAAI,GAAGT,KAAK,CAAC0B,SAAb;AACD,GAFD,MAEO;AACL,WAAOH,IAAI,KAAK,IAAhB,EAAsB;AACpBD,MAAAA,SAAS,GAAGC,IAAI,CAACD,SAAjB;;AACA,UAAIC,IAAI,CAACI,mBAAL,GAA2BvB,cAA/B,EAA+C;AAC7CmB,QAAAA,IAAI,CAACI,mBAAL,GAA2BvB,cAA3B;;AACA,YACEkB,SAAS,KAAK,IAAd,IACAA,SAAS,CAACK,mBAAV,GAAgCvB,cAFlC,EAGE;AACAkB,UAAAA,SAAS,CAACK,mBAAV,GAAgCvB,cAAhC;AACD;AACF,OARD,MAQO,IACLkB,SAAS,KAAK,IAAd,IACAA,SAAS,CAACK,mBAAV,GAAgCvB,cAF3B,EAGL;AACAkB,QAAAA,SAAS,CAACK,mBAAV,GAAgCvB,cAAhC;AACD;;AACD,UAAImB,IAAI,CAACC,MAAL,KAAgB,IAAhB,IAAwBD,IAAI,CAACE,GAAL,KAAa1K,QAAzC,EAAmD;AACjD0J,QAAAA,IAAI,GAAGc,IAAI,CAACG,SAAZ;AACA;AACD;;AACDH,MAAAA,IAAI,GAAGA,IAAI,CAACC,MAAZ;AACD;AACF;;AACD,MAAIf,IAAI,KAAK,IAAb,EAAmB;AACjB,QAAI5C,kBAAkB,KAAK4C,IAA3B,EAAiC;AAC/B;AACA;AACAmB,MAAAA,yBAAyB,CAACxB,cAAD,CAAzB;;AAEA,UAAIpC,4BAA4B,KAAKN,sBAArC,EAA6D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApH,QAAAA,uBAAuB,CAACmK,IAAD,EAAO1C,oBAAP,CAAvB;AACD;AACF,KAtBgB,CAuBjB;;;AACAvH,IAAAA,qBAAqB,CAACiK,IAAD,EAAOL,cAAP,CAArB;AACD;;AAED,SAAOK,IAAP;AACD;;AAED,SAASoB,iCAAT,CAA2CpB,IAA3C,EAA4E;AAC1E;AACA;AACA;AAEA,QAAMqB,eAAe,GAAGrB,IAAI,CAACqB,eAA7B;;AACA,MAAIA,eAAe,KAAKvJ,MAAxB,EAAgC;AAC9B,WAAOuJ,eAAP;AACD,GARyE,CAU1E;AACA;;;AACA,QAAMC,gBAAgB,GAAGtB,IAAI,CAACsB,gBAA9B;;AACA,MAAI,CAAC1L,qBAAqB,CAACoK,IAAD,EAAOsB,gBAAP,CAA1B,EAAoD;AAClD;AACA,WAAOA,gBAAP;AACD,GAhByE,CAkB1E;AACA;AACA;;;AACA,QAAMC,cAAc,GAAGvB,IAAI,CAACuB,cAA5B;AACA,QAAMC,qBAAqB,GAAGxB,IAAI,CAACwB,qBAAnC;AACA,QAAMC,SAAS,GACbF,cAAc,GAAGC,qBAAjB,GACID,cADJ,GAEIC,qBAHN;;AAIA,MACEzN,mBAAmB,IACnB0N,SAAS,IAAIhJ,IADb,IAEA6I,gBAAgB,KAAKG,SAHvB,EAIE;AACA;AACA,WAAO3J,MAAP;AACD;;AACD,SAAO2J,SAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASnB,qBAAT,CAA+BN,IAA/B,EAAgD;AAC9C,QAAMqB,eAAe,GAAGrB,IAAI,CAACqB,eAA7B;;AACA,MAAIA,eAAe,KAAKvJ,MAAxB,EAAgC;AAC9B;AACAkI,IAAAA,IAAI,CAAC0B,sBAAL,GAA8B3J,IAA9B;AACAiI,IAAAA,IAAI,CAAC2B,gBAAL,GAAwBjN,iBAAxB;AACAsL,IAAAA,IAAI,CAAC4B,YAAL,GAAoB5M,oBAAoB,CACtCqL,qBAAqB,CAACwB,IAAtB,CAA2B,IAA3B,EAAiC7B,IAAjC,CADsC,CAAxC;AAGA;AACD;;AAED,QAAML,cAAc,GAAGyB,iCAAiC,CAACpB,IAAD,CAAxD;AACA,QAAM8B,oBAAoB,GAAG9B,IAAI,CAAC4B,YAAlC;;AACA,MAAIjC,cAAc,KAAK7H,MAAvB,EAA+B;AAC7B;AACA,QAAIgK,oBAAoB,KAAK,IAA7B,EAAmC;AACjC9B,MAAAA,IAAI,CAAC4B,YAAL,GAAoB,IAApB;AACA5B,MAAAA,IAAI,CAAC0B,sBAAL,GAA8B5J,MAA9B;AACAkI,MAAAA,IAAI,CAAC2B,gBAAL,GAAwBlN,UAAxB;AACD;;AACD;AACD,GAtB6C,CAwB9C;AACA;;;AACA,QAAM6K,WAAW,GAAGH,2BAA2B,EAA/C;AACA,QAAMO,aAAa,GAAGpH,+BAA+B,CACnDgH,WADmD,EAEnDK,cAFmD,CAArD,CA3B8C,CAgC9C;AACA;;AACA,MAAImC,oBAAoB,KAAK,IAA7B,EAAmC;AACjC,UAAMC,wBAAwB,GAAG/B,IAAI,CAAC2B,gBAAtC;AACA,UAAMK,8BAA8B,GAAGhC,IAAI,CAAC0B,sBAA5C;;AACA,SACE;AACAM,IAAAA,8BAA8B,KAAKrC,cAAnC,IACA;AACAoC,IAAAA,wBAAwB,IAAIrC,aAJ9B,EAKE;AACA;AACA;AACD,KAXgC,CAYjC;AACA;AACA;;;AACAvL,IAAAA,cAAc,CAAC2N,oBAAD,CAAd;AACD;;AAED9B,EAAAA,IAAI,CAAC0B,sBAAL,GAA8B/B,cAA9B;AACAK,EAAAA,IAAI,CAAC2B,gBAAL,GAAwBjC,aAAxB;AAEA,MAAIkC,YAAJ;;AACA,MAAIjC,cAAc,KAAK5H,IAAvB,EAA6B;AAC3B;AACA6J,IAAAA,YAAY,GAAG5M,oBAAoB,CAACqL,qBAAqB,CAACwB,IAAtB,CAA2B,IAA3B,EAAiC7B,IAAjC,CAAD,CAAnC;AACD,GAHD,MAGO,IAAIlM,iDAAJ,EAAuD;AAC5D8N,IAAAA,YAAY,GAAG1N,gBAAgB,CAC7BwL,aAD6B,EAE7BuC,2BAA2B,CAACJ,IAA5B,CAAiC,IAAjC,EAAuC7B,IAAvC,CAF6B,CAA/B;AAID,GALM,MAKA;AACL4B,IAAAA,YAAY,GAAG1N,gBAAgB,CAC7BwL,aAD6B,EAE7BuC,2BAA2B,CAACJ,IAA5B,CAAiC,IAAjC,EAAuC7B,IAAvC,CAF6B,EAG7B;AACA;AACA;AAACkC,MAAAA,OAAO,EAAEhK,kBAAkB,CAACyH,cAAD,CAAlB,GAAqCnL,GAAG;AAAlD,KAL6B,CAA/B;AAOD;;AAEDwL,EAAAA,IAAI,CAAC4B,YAAL,GAAoBA,YAApB;AACD,C,CAED;AACA;;;AACA,SAASK,2BAAT,CAAqCjC,IAArC,EAA2CmC,UAA3C,EAAuD;AACrD;AACA;AACAjD,EAAAA,gBAAgB,GAAGpH,MAAnB;;AAEA,MAAIqK,UAAJ,EAAgB;AACd;AACA;AACA,UAAM7C,WAAW,GAAGH,2BAA2B,EAA/C;AACAnJ,IAAAA,qBAAqB,CAACgK,IAAD,EAAOV,WAAP,CAArB,CAJc,CAKd;;AACAgB,IAAAA,qBAAqB,CAACN,IAAD,CAArB;AACA,WAAO,IAAP;AACD,GAboD,CAerD;AACA;;;AACA,QAAML,cAAc,GAAGyB,iCAAiC,CAACpB,IAAD,CAAxD;;AACA,MAAIL,cAAc,KAAK7H,MAAvB,EAA+B;AAC7B,UAAMsK,oBAAoB,GAAGpC,IAAI,CAAC4B,YAAlC;AACA3N,IAAAA,SAAS,CACP,CAACkJ,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SADlD,EAEP,gCAFO,CAAT;AAKA+F,IAAAA,mBAAmB,GAPU,CAS7B;AACA;;AACA,QACErC,IAAI,KAAK5C,kBAAT,IACAuC,cAAc,KAAKrC,oBAFrB,EAGE;AACAgF,MAAAA,iBAAiB,CAACtC,IAAD,EAAOL,cAAP,CAAjB;AACA4C,MAAAA,8BAA8B,CAACvC,IAAD,EAAOL,cAAP,CAA9B;AACD,KAjB4B,CAmB7B;AACA;;;AACA,QAAItC,cAAc,KAAK,IAAvB,EAA6B;AAC3B,YAAMmF,oBAAoB,GAAGrF,gBAA7B;AACAA,MAAAA,gBAAgB,IAAIR,aAApB;AACA,YAAM8F,cAAc,GAAGC,cAAc,CAAC1C,IAAD,CAArC;AACA,YAAM2C,gBAAgB,GAAGC,gBAAgB,CAAC5C,IAAD,CAAzC;AACA7E,MAAAA,kBAAkB,CAACkC,cAAD,CAAlB;;AACA,SAAG;AACD,YAAI;AACFwF,UAAAA,kBAAkB;AAClB;AACD,SAHD,CAGE,OAAOC,WAAP,EAAoB;AACpBC,UAAAA,WAAW,CAAC/C,IAAD,EAAO8C,WAAP,CAAX;AACD;AACF,OAPD,QAOS,IAPT;;AAQAhJ,MAAAA,wBAAwB;AACxBqD,MAAAA,gBAAgB,GAAGqF,oBAAnB;AACAQ,MAAAA,aAAa,CAACP,cAAD,CAAb;;AACA,UAAI9O,sBAAJ,EAA4B;AAC1BsP,QAAAA,eAAe,CAAGN,gBAAH,CAAf;AACD;;AAED,UAAIpF,4BAA4B,KAAKT,gBAArC,EAAuD;AACrD,cAAMoG,UAAU,GAAG1F,4BAAnB;AACA2F,QAAAA,4BAA4B;AAC5Bb,QAAAA,iBAAiB,CAACtC,IAAD,EAAOL,cAAP,CAAjB;AACA9J,QAAAA,uBAAuB,CAACmK,IAAD,EAAOL,cAAP,CAAvB;AACAW,QAAAA,qBAAqB,CAACN,IAAD,CAArB;AACA,cAAMkD,UAAN;AACD;;AAED,UAAI7F,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACA8F,QAAAA,4BAA4B;AAC7B,OAHD,MAGO;AACL;AACA;AACAC,QAAAA,yBAAyB;AAEzB,cAAMC,YAAmB,GAAKrD,IAAI,CAACqD,YAAL,GAC5BrD,IAAI,CAACsD,OAAL,CAAazC,SADf;AAEAb,QAAAA,IAAI,CAACuD,sBAAL,GAA8B5D,cAA9B;AACA6D,QAAAA,sBAAsB,CACpBxD,IADoB,EAEpBqD,YAFoB,EAGpB9F,4BAHoB,EAIpBoC,cAJoB,CAAtB;AAMD;;AAEDW,MAAAA,qBAAqB,CAACN,IAAD,CAArB;;AACA,UAAIA,IAAI,CAAC4B,YAAL,KAAsBQ,oBAA1B,EAAgD;AAC9C;AACA;AACA,eAAOH,2BAA2B,CAACJ,IAA5B,CAAiC,IAAjC,EAAuC7B,IAAvC,CAAP;AACD;AACF;AACF;;AACD,SAAO,IAAP;AACD;;AAED,SAASwD,sBAAT,CACExD,IADF,EAEEqD,YAFF,EAGEI,UAHF,EAIE9D,cAJF,EAKE;AACA;AACAvC,EAAAA,kBAAkB,GAAG,IAArB;;AAEA,UAAQqG,UAAR;AACE,SAAK5G,cAAL;AACA,SAAKC,gBAAL;AAAuB;AACrB7I,QAAAA,SAAS,CAAC,KAAD,EAAQ,gDAAR,CAAT;AACD;AACD;AACA;AACA;;AACA,SAAK8I,WAAL;AAAkB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA/G,QAAAA,qBAAqB,CACnBgK,IADmB,EAEnBL,cAAc,GAAGlH,IAAjB,GAAwBA,IAAxB,GAA+BkH,cAFZ,CAArB,CARgB,CAYhB;AACA;;AACA;AACD;;AACD,SAAK3C,aAAL;AAAoB;AAClBnH,QAAAA,uBAAuB,CAACmK,IAAD,EAAOL,cAAP,CAAvB;AACA,cAAM+D,iBAAiB,GAAG1D,IAAI,CAAC0D,iBAA/B;;AACA,YAAI/D,cAAc,KAAK+D,iBAAvB,EAA0C;AACxC1D,UAAAA,IAAI,CAACwB,qBAAL,GAA6BmC,0BAA0B,CAACN,YAAD,CAAvD;AACD,SALiB,CAOlB;AACA;AAEA;AACA;AACA;;;AACA,cAAMO,yBAAyB,GAC7BnG,+CAA+C,KAAK1F,IADtD;;AAEA,YACE6L,yBAAyB,IACzB;AACA,UACEC,OAAO,IACPhQ,6BADA,IAEAiQ,oBAAoB,CAACR,OAHvB,CAHF,EAQE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAIS,cAAc,GAChBjG,4BAA4B,GAAGC,oBAA/B,GAAsDvJ,GAAG,EAD3D,CAPA,CASA;;AACA,cAAIuP,cAAc,GAAG,EAArB,EAAyB;AACvB,gBAAIlG,gCAAJ,EAAsC;AACpC,oBAAM0D,cAAc,GAAGvB,IAAI,CAACuB,cAA5B;;AACA,kBAAIA,cAAc,KAAKzJ,MAAnB,IAA6ByJ,cAAc,IAAI5B,cAAnD,EAAmE;AACjE;AACA;AACAK,gBAAAA,IAAI,CAACuB,cAAL,GAAsB5B,cAAtB;AACA2C,gBAAAA,iBAAiB,CAACtC,IAAD,EAAOL,cAAP,CAAjB;AACA;AACD;AACF;;AAED,kBAAMqE,QAAQ,GAAG5C,iCAAiC,CAACpB,IAAD,CAAlD;;AACA,gBAAIgE,QAAQ,KAAKlM,MAAb,IAAuBkM,QAAQ,KAAKrE,cAAxC,EAAwD;AACtD;AACA;AACD;;AACD,gBACE+D,iBAAiB,KAAK5L,MAAtB,IACA4L,iBAAiB,KAAK/D,cAFxB,EAGE;AACA;AACA;AACA;AACAK,cAAAA,IAAI,CAACuB,cAAL,GAAsBmC,iBAAtB;AACA;AACD,aA1BsB,CA4BvB;AACA;AACA;;;AACA1D,YAAAA,IAAI,CAACiE,aAAL,GAAqB3O,eAAe,CAClC4O,UAAU,CAACrC,IAAX,CAAgB,IAAhB,EAAsB7B,IAAtB,CADkC,EAElC+D,cAFkC,CAApC;AAIA;AACD;AACF,SAtEiB,CAuElB;;;AACAG,QAAAA,UAAU,CAAClE,IAAD,CAAV;AACA;AACD;;AACD,SAAK/C,sBAAL;AAA6B;AAC3BpH,QAAAA,uBAAuB,CAACmK,IAAD,EAAOL,cAAP,CAAvB;AACA,cAAM+D,iBAAiB,GAAG1D,IAAI,CAAC0D,iBAA/B;;AACA,YAAI/D,cAAc,KAAK+D,iBAAvB,EAA0C;AACxC1D,UAAAA,IAAI,CAACwB,qBAAL,GAA6BmC,0BAA0B,CAACN,YAAD,CAAvD;AACD;;AAED,aACE;AACA,UACEQ,OAAO,IACPhQ,6BADA,IAEAiQ,oBAAoB,CAACR,OAHvB,CAFF,EAOE;AACA;AACA;AACA,cAAIzF,gCAAJ,EAAsC;AACpC,kBAAM0D,cAAc,GAAGvB,IAAI,CAACuB,cAA5B;;AACA,gBAAIA,cAAc,KAAKzJ,MAAnB,IAA6ByJ,cAAc,IAAI5B,cAAnD,EAAmE;AACjE;AACA;AACAK,cAAAA,IAAI,CAACuB,cAAL,GAAsB5B,cAAtB;AACA2C,cAAAA,iBAAiB,CAACtC,IAAD,EAAOL,cAAP,CAAjB;AACA;AACD;AACF;;AAED,gBAAMqE,QAAQ,GAAG5C,iCAAiC,CAACpB,IAAD,CAAlD;;AACA,cAAIgE,QAAQ,KAAKlM,MAAb,IAAuBkM,QAAQ,KAAKrE,cAAxC,EAAwD;AACtD;AACA;AACD;;AACD,cACE+D,iBAAiB,KAAK5L,MAAtB,IACA4L,iBAAiB,KAAK/D,cAFxB,EAGE;AACA;AACA;AACA;AACAK,YAAAA,IAAI,CAACuB,cAAL,GAAsBmC,iBAAtB;AACA;AACD;;AAED,cAAIK,cAAJ;;AACA,cAAIrG,uCAAuC,KAAK3F,IAAhD,EAAsD;AACpD;AACA;AACAgM,YAAAA,cAAc,GACZ7L,kBAAkB,CAACwF,uCAAD,CAAlB,GAA8DlJ,GAAG,EADnE;AAED,WALD,MAKO,IAAIiJ,+CAA+C,KAAK1F,IAAxD,EAA8D;AACnE;AACA;AACA;AACAgM,YAAAA,cAAc,GAAG,CAAjB;AACD,WALM,MAKA;AACL;AACA;AACA,kBAAMI,WAAmB,GAAGC,2BAA2B,CACrD3G,+CADqD,CAAvD;AAGA,kBAAM4G,aAAa,GAAG7P,GAAG,EAAzB;AACA,kBAAM8P,qBAAqB,GACzBpM,kBAAkB,CAACyH,cAAD,CAAlB,GAAqC0E,aADvC;AAEA,gBAAIE,WAAW,GAAGF,aAAa,GAAGF,WAAlC;;AACA,gBAAII,WAAW,GAAG,CAAlB,EAAqB;AACnB;AACAA,cAAAA,WAAW,GAAG,CAAd;AACD;;AAEDR,YAAAA,cAAc,GAAGS,GAAG,CAACD,WAAD,CAAH,GAAmBA,WAApC,CAfK,CAiBL;AACA;AACA;;AACA,gBAAID,qBAAqB,GAAGP,cAA5B,EAA4C;AAC1CA,cAAAA,cAAc,GAAGO,qBAAjB;AACD;AACF,WAhED,CAkEA;;;AACA,cAAIP,cAAc,GAAG,EAArB,EAAyB;AACvB;AACA;AACA;AACA/D,YAAAA,IAAI,CAACiE,aAAL,GAAqB3O,eAAe,CAClC4O,UAAU,CAACrC,IAAX,CAAgB,IAAhB,EAAsB7B,IAAtB,CADkC,EAElC+D,cAFkC,CAApC;AAIA;AACD;AACF,SA3F0B,CA4F3B;;;AACAG,QAAAA,UAAU,CAAClE,IAAD,CAAV;AACA;AACD;;AACD,SAAK9C,aAAL;AAAoB;AAClB;AACA,aACE;AACA,UACE2G,OAAO,IACPhQ,6BADA,IAEAiQ,oBAAoB,CAACR,OAHvB,KAKA7F,+CAA+C,KAAK1F,IALpD,IAMA4F,uCAAuC,KAAK,IAR9C,EASE;AACA;AACA;AACA;AACA;AACA,gBAAMoG,cAAc,GAAGU,kCAAkC,CACvDhH,+CADuD,EAEvDkC,cAFuD,EAGvDhC,uCAHuD,CAAzD;;AAKA,cAAIoG,cAAc,GAAG,EAArB,EAAyB;AACvBlO,YAAAA,uBAAuB,CAACmK,IAAD,EAAOL,cAAP,CAAvB;AACAK,YAAAA,IAAI,CAACiE,aAAL,GAAqB3O,eAAe,CAClC4O,UAAU,CAACrC,IAAX,CAAgB,IAAhB,EAAsB7B,IAAtB,CADkC,EAElC+D,cAFkC,CAApC;AAIA;AACD;AACF;;AACDG,QAAAA,UAAU,CAAClE,IAAD,CAAV;AACA;AACD;;AACD;AAAS;AACP/L,QAAAA,SAAS,CAAC,KAAD,EAAQ,2BAAR,CAAT;AACD;AAtOH;AAwOD,C,CAED;;;AACA,SAASoM,qBAAT,CAA+BL,IAA/B,EAAqC;AACnC;AAEA;AACA;AACA;AACA,QAAMqB,eAAe,GAAGrB,IAAI,CAACqB,eAA7B,CANmC,CAOnC;AACA;AACA;;AACA,QAAM1B,cAAc,GAAG0B,eAAe,KAAKvJ,MAApB,GAA6BuJ,eAA7B,GAA+CtJ,IAAtE;AAEA9D,EAAAA,SAAS,CACP,CAACkJ,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SADlD,EAEP,gCAFO,CAAT,CAZmC,CAiBnC;;AACA+F,EAAAA,mBAAmB,GAlBgB,CAoBnC;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIrC,IAAI,KAAK5C,kBAAT,IAA+BuC,cAAc,KAAKrC,oBAAtD,EAA4E;AAC1E;AACAgF,IAAAA,iBAAiB,CAACtC,IAAD,EAAOL,cAAP,CAAjB,CAF0E,CAG1E;;AACA4C,IAAAA,8BAA8B,CAACvC,IAAD,EAAOL,cAAP,CAA9B;AACD,GA/BkC,CAgCnC;;;AACA,MAAItC,cAAc,KAAK,IAAvB,EAA6B;AAC3B,UAAMmF,oBAAoB,GAAGrF,gBAA7B;AACAA,IAAAA,gBAAgB,IAAIR,aAApB;AACA,UAAM8F,cAAc,GAAGC,cAAc,CAAC1C,IAAD,CAArC;AACA,UAAM2C,gBAAgB,GAAGC,gBAAgB,CAAC5C,IAAD,CAAzC;AACA7E,IAAAA,kBAAkB,CAACkC,cAAD,CAAlB;;AACA,OAAG;AACD,UAAI;AACF;AACAqH,QAAAA,YAAY;AACZ;AACD,OAJD,CAIE,OAAO5B,WAAP,EAAoB;AACpBC,QAAAA,WAAW,CAAC/C,IAAD,EAAO8C,WAAP,CAAX;AACD;AACF,KARD,QAQS,IART;;AAUAhJ,IAAAA,wBAAwB;AACxBqD,IAAAA,gBAAgB,GAAGqF,oBAAnB;AACAQ,IAAAA,aAAa,CAACP,cAAD,CAAb;;AACA,QAAI9O,sBAAJ,EAA4B;AAC1BsP,MAAAA,eAAe,CAAGN,gBAAH,CAAf;AACD,KArB0B,CAsB3B;;;AACA,QAAIpF,4BAA4B,KAAKT,gBAArC,EAAuD;AACrD,YAAMoG,UAAU,GAAG1F,4BAAnB;AACA2F,MAAAA,4BAA4B;AAC5Bb,MAAAA,iBAAiB,CAACtC,IAAD,EAAOL,cAAP,CAAjB;AACA9J,MAAAA,uBAAuB,CAACmK,IAAD,EAAOL,cAAP,CAAvB;AACAW,MAAAA,qBAAqB,CAACN,IAAD,CAArB;AACA,YAAMkD,UAAN;AACD;;AAED,QAAI7F,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACA;AACApJ,MAAAA,SAAS,CACP,KADO,EAEP,wEACE,qCAHK,CAAT;AAKD,KARD,MAQO;AACL;AACA;AACAmP,MAAAA,yBAAyB,GAHpB,CAIL;AACA;;AACApD,MAAAA,IAAI,CAACqD,YAAL,GAAqBrD,IAAI,CAACsD,OAAL,CAAazC,SAAlC;AACAb,MAAAA,IAAI,CAACuD,sBAAL,GAA8B5D,cAA9B,CAPK,CAQL;AACA;;AACAgF,MAAAA,gBAAgB,CAAC3E,IAAD,CAAhB;AACD,KAnD0B,CAqD3B;AACA;;;AACAM,IAAAA,qBAAqB,CAACN,IAAD,CAArB;AACD;;AAED,SAAO,IAAP;AACD;;AAED,SAAS2E,gBAAT,CAA0B3E,IAA1B,EAAgC;AAC9B;AACA;AACA5C,EAAAA,kBAAkB,GAAG,IAArB,CAH8B,CAI9B;;AACA8G,EAAAA,UAAU,CAAClE,IAAD,CAAV;AACD;;AAED,OAAO,SAAS4E,SAAT,CAAmB5E,IAAnB,EAAoCL,cAApC,EAAoE;AACzE3J,EAAAA,qBAAqB,CAACgK,IAAD,EAAOL,cAAP,CAArB;AACAW,EAAAA,qBAAqB,CAACN,IAAD,CAArB;;AACA,MAAI,CAAC7C,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SAA7D,EAAwE;AACtEvH,IAAAA,sBAAsB;AACvB;AACF;AAED,OAAO,SAAS8P,oBAAT,GAAgC;AACrC;AACA;AACA;AACA;AACA,MACE,CAAC1H,gBAAgB,IAAIZ,cAAc,GAAGI,aAAjB,GAAiCC,aAArC,CAAjB,MACAN,SAFF,EAGE;AACA,QAAIuH,OAAJ,EAAa;AACX,UAAI,CAAC1G,gBAAgB,GAAGR,aAApB,MAAuCL,SAA3C,EAAsD;AACpDwI,QAAAA,OAAO,CAACC,KAAR,CACE,uEACE,oBAFJ;AAID;AACF,KARD,CASA;AACA;AACA;;;AACA;AACD;;AACDC,EAAAA,2BAA2B,GAtBU,CAuBrC;AACA;;AACA3C,EAAAA,mBAAmB;AACpB;AAED,OAAO,SAAS4C,eAAT,CAA4BC,EAA5B,EAA4C;AACjD;AACA,SAAO7Q,eAAe,CAACO,cAAD,EAAiBsQ,EAAjB,CAAtB;AACD;AAED,OAAO,SAASC,WAAT,CACLD,EADK,EAELE,CAFK,EAGLC,CAHK,EAILC,CAJK,EAKF;AACH,SAAOjR,eAAe,CAACK,iBAAD,EAAoBwQ,EAAE,CAACrD,IAAH,CAAQ,IAAR,EAAcuD,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB,CAApB,CAAtB;AACD;;AAED,SAASN,2BAAT,GAAuC;AACrC,MAAItG,+BAA+B,KAAK,IAAxC,EAA8C;AAC5C;AACA;AACA,UAAM6G,KAAK,GAAG7G,+BAAd;AACAA,IAAAA,+BAA+B,GAAG,IAAlC;AACA6G,IAAAA,KAAK,CAACC,OAAN,CAAc,CAAC7F,cAAD,EAAiBK,IAAjB,KAA0B;AACtChK,MAAAA,qBAAqB,CAACgK,IAAD,EAAOL,cAAP,CAArB;AACAW,MAAAA,qBAAqB,CAACN,IAAD,CAArB;AACD,KAHD,EAL4C,CAS5C;;AACAjL,IAAAA,sBAAsB;AACvB;AACF;;AAED,OAAO,SAAS0Q,cAAT,CAA8BP,EAA9B,EAA4CE,CAA5C,EAAqD;AAC1D,QAAM5C,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAIZ,cAApB;;AACA,MAAI;AACF,WAAO2I,EAAE,CAACE,CAAD,CAAT;AACD,GAFD,SAEU;AACRjI,IAAAA,gBAAgB,GAAGqF,oBAAnB;;AACA,QAAIrF,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC;AACAvH,MAAAA,sBAAsB;AACvB;AACF;AACF;AAED,OAAO,SAAS2Q,mBAAT,CAAmCR,EAAnC,EAAiDE,CAAjD,EAA0D;AAC/D,QAAM5C,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAIX,YAApB;;AACA,MAAI;AACF,WAAO0I,EAAE,CAACE,CAAD,CAAT;AACD,GAFD,SAEU;AACRjI,IAAAA,gBAAgB,GAAGqF,oBAAnB;;AACA,QAAIrF,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC;AACAvH,MAAAA,sBAAsB;AACvB;AACF;AACF;AAED,OAAO,SAAS4Q,eAAT,CACLT,EADK,EAELE,CAFK,EAGLC,CAHK,EAILC,CAJK,EAKLM,CALK,EAMF;AACH,QAAMpD,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAIV,oBAApB;;AACA,MAAI;AACF;AACA,WAAOpI,eAAe,CAACM,oBAAD,EAAuBuQ,EAAE,CAACrD,IAAH,CAAQ,IAAR,EAAcuD,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB,EAAuBM,CAAvB,CAAvB,CAAtB;AACD,GAHD,SAGU;AACRzI,IAAAA,gBAAgB,GAAGqF,oBAAnB;;AACA,QAAIrF,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC;AACAvH,MAAAA,sBAAsB;AACvB;AACF;AACF;AAED,OAAO,SAAS8Q,gBAAT,CAAgCX,EAAhC,EAAiDE,CAAjD,EAA0D;AAC/D,QAAM5C,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAI,CAACZ,cAArB;AACAY,EAAAA,gBAAgB,IAAIT,sBAApB;;AACA,MAAI;AACF,WAAOwI,EAAE,CAACE,CAAD,CAAT;AACD,GAFD,SAEU;AACRjI,IAAAA,gBAAgB,GAAGqF,oBAAnB;;AACA,QAAIrF,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC;AACAvH,MAAAA,sBAAsB;AACvB;AACF;AACF;AAED,OAAO,SAAS+Q,SAAT,CAAyBZ,EAAzB,EAAuCE,CAAvC,EAAgD;AACrD,MAAI,CAACjI,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SAA7D,EAAwE;AACtErI,IAAAA,SAAS,CACP,KADO,EAEP,uEACE,yCAHK,CAAT;AAKD;;AACD,QAAMuO,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAIZ,cAApB;;AACA,MAAI;AACF,WAAOlI,eAAe,CAACK,iBAAD,EAAoBwQ,EAAE,CAACrD,IAAH,CAAQ,IAAR,EAAcuD,CAAd,CAApB,CAAtB;AACD,GAFD,SAEU;AACRjI,IAAAA,gBAAgB,GAAGqF,oBAAnB,CADQ,CAER;AACA;AACA;;AACAzN,IAAAA,sBAAsB;AACvB;AACF;AAED,OAAO,SAASgR,eAAT,CAAyBb,EAAzB,EAAgD;AACrD,QAAM1C,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAIZ,cAApB;;AACA,MAAI;AACFlI,IAAAA,eAAe,CAACK,iBAAD,EAAoBwQ,EAApB,CAAf;AACD,GAFD,SAEU;AACR/H,IAAAA,gBAAgB,GAAGqF,oBAAnB;;AACA,QAAIrF,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC;AACAvH,MAAAA,sBAAsB;AACvB;AACF;AACF;AAED;;;;AAGA,SAASuN,iBAAT,CAA2BtC,IAA3B,EAAiCL,cAAjC,EAAiD;AAC/C;AACA;AACAK,EAAAA,IAAI,CAACqD,YAAL,GAAoB,IAApB,CAH+C,CAI/C;;AACArD,EAAAA,IAAI,CAACuD,sBAAL,GAA8BzL,MAA9B;AAEA,QAAMmM,aAAa,GAAGjE,IAAI,CAACiE,aAA3B,CAP+C,CAQ/C;;AACA,MAAIA,aAAa,KAAKzO,SAAtB,EAAiC;AAC/B;AACA;AACAwK,IAAAA,IAAI,CAACiE,aAAL,GAAqBzO,SAArB,CAH+B,CAI/B;;AACAD,IAAAA,aAAa,CAAC0O,aAAD,CAAb;AACD,GAf8C,CAiB/C;AACA;;;AACA,MAAI5G,cAAc,KAAK,IAAvB,EAA6B;AAC3B,QAAI2I,eAAe,GAAG3I,cAAc,CAAC0D,MAArC;;AACA,WAAOiF,eAAe,KAAK,IAA3B,EAAiC;AAC/BlN,MAAAA,qBAAqB,CAACkN,eAAD,CAArB;AACAA,MAAAA,eAAe,GAAGA,eAAe,CAACjF,MAAlC;AACD;AACF,GAzB8C,CA0B/C;;;AACA3D,EAAAA,kBAAkB,GAAG4C,IAArB,CA3B+C,CA4B/C;;AACA3C,EAAAA,cAAc,GAAG3H,oBAAoB,CAACsK,IAAI,CAACsD,OAAN,EAAe,IAAf,CAArC;AACAhG,EAAAA,oBAAoB,GAAGqC,cAAvB;AACApC,EAAAA,4BAA4B,GAAGV,cAA/B;AACAW,EAAAA,4BAA4B,GAAG,IAA/B;AACAC,EAAAA,+CAA+C,GAAG1F,IAAlD;AACA2F,EAAAA,uCAAuC,GAAG3F,IAA1C;AACA4F,EAAAA,uCAAuC,GAAG,IAA1C;AACAC,EAAAA,2CAA2C,GAAG9F,MAA9C;AACA+F,EAAAA,gCAAgC,GAAG,KAAnC,CArC+C,CAsC/C;;AACA,MAAIlK,sBAAJ,EAA4B;AAC1BsL,IAAAA,uBAAuB,GAAG,IAA1B;AACD;;AAED,MAAI4E,OAAJ,EAAa;AACXvJ,IAAAA,uBAAuB,CAAC2L,sBAAxB;AACD;AACF;;AAED,SAASlD,WAAT,CAAqB/C,IAArB,EAA2B8C,WAA3B,EAAwC;AACtC,KAAG;AACD,QAAI;AACF;AACAhJ,MAAAA,wBAAwB;AACxBC,MAAAA,oBAAoB;AACpBW,MAAAA,2BAA2B;;AAE3B,UAAI2C,cAAc,KAAK,IAAnB,IAA2BA,cAAc,CAAC0D,MAAf,KAA0B,IAAzD,EAA+D;AAC7D;AACA;AACA;AACA;AACAxD,QAAAA,4BAA4B,GAAGT,gBAA/B;AACAU,QAAAA,4BAA4B,GAAGsF,WAA/B,CAN6D,CAO7D;AACA;AACA;AACA;AACA;AACA;;AACAzF,QAAAA,cAAc,GAAG,IAAjB;AACA,eAAO,IAAP;AACD;;AAED,UAAI3J,mBAAmB,IAAI2J,cAAc,CAACoC,IAAf,GAAsBtJ,WAAjD,EAA8D;AAC5D;AACA;AACA;AACAiE,QAAAA,wCAAwC,CAACiD,cAAD,EAAiB,IAAjB,CAAxC;AACD;;AAEDtE,MAAAA,cAAc,CACZiH,IADY,EAEZ3C,cAAc,CAAC0D,MAFH,EAGZ1D,cAHY,EAIZyF,WAJY,EAKZxF,oBALY,CAAd;AAOAD,MAAAA,cAAc,GAAG6I,kBAAkB,CAAC7I,cAAD,CAAnC;AACD,KAtCD,CAsCE,OAAO8I,qBAAP,EAA8B;AAC9B;AACArD,MAAAA,WAAW,GAAGqD,qBAAd;AACA;AACD,KA3CA,CA4CD;;;AACA;AACD,GA9CD,QA8CS,IA9CT;AA+CD;;AAED,SAASzD,cAAT,CAAwB1C,IAAxB,EAA8B;AAC5B,QAAMyC,cAAc,GAAGtG,sBAAsB,CAACmH,OAA9C;AACAnH,EAAAA,sBAAsB,CAACmH,OAAvB,GAAiCtJ,qBAAjC;;AACA,MAAIyI,cAAc,KAAK,IAAvB,EAA6B;AAC3B;AACA;AACA;AACA,WAAOzI,qBAAP;AACD,GALD,MAKO;AACL,WAAOyI,cAAP;AACD;AACF;;AAED,SAASO,aAAT,CAAuBP,cAAvB,EAAuC;AACrCtG,EAAAA,sBAAsB,CAACmH,OAAvB,GAAiCb,cAAjC;AACD;;AAED,SAASG,gBAAT,CAA0B5C,IAA1B,EAAgC;AAC9B,MAAIrM,sBAAJ,EAA4B;AAC1B,UAAMgP,gBAAyC,GAAGzN,iBAAiB,CAACoO,OAApE;AACApO,IAAAA,iBAAiB,CAACoO,OAAlB,GAA4BtD,IAAI,CAACoG,oBAAjC;AACA,WAAOzD,gBAAP;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASM,eAAT,CAAyBN,gBAAzB,EAA2C;AACzC,MAAIhP,sBAAJ,EAA4B;AAC1BuB,IAAAA,iBAAiB,CAACoO,OAAlB,GAA4BX,gBAA5B;AACD;AACF;;AAED,OAAO,SAAS0D,wBAAT,GAAoC;AACzCvI,EAAAA,4BAA4B,GAAGtJ,GAAG,EAAlC;AACD;AAED,OAAO,SAAS8R,4BAAT,CACL3G,cADK,EAELH,cAFK,EAGC;AACN,MACEG,cAAc,GAAGlC,+CAAjB,IACAkC,cAAc,GAAGlH,IAFnB,EAGE;AACAgF,IAAAA,+CAA+C,GAAGkC,cAAlD;AACD;;AACD,MAAIH,cAAc,KAAK,IAAvB,EAA6B;AAC3B,QACEG,cAAc,GAAGjC,uCAAjB,IACAiC,cAAc,GAAGlH,IAFnB,EAGE;AACAiF,MAAAA,uCAAuC,GAAGiC,cAA1C,CADA,CAEA;;AACAhC,MAAAA,uCAAuC,GAAG6B,cAA1C;AACD;AACF;AACF;AAED,OAAO,SAAS2B,yBAAT,CACLxB,cADK,EAEC;AACN,MAAIA,cAAc,GAAG/B,2CAArB,EAAkE;AAChEA,IAAAA,2CAA2C,GAAG+B,cAA9C;AACD;AACF;AAED,OAAO,SAAS4G,gBAAT,GAAkC;AACvC,MAAIhJ,4BAA4B,KAAKV,cAArC,EAAqD;AACnDU,IAAAA,4BAA4B,GAAGP,aAA/B;AACD;AACF;AAED,OAAO,SAASwJ,+BAAT,GAAiD;AACtD,MACEjJ,4BAA4B,KAAKV,cAAjC,IACAU,4BAA4B,KAAKP,aAFnC,EAGE;AACAO,IAAAA,4BAA4B,GAAGN,sBAA/B;AACD,GANqD,CAQtD;;;AACA,MACEW,2CAA2C,KAAK9F,MAAhD,IACAsF,kBAAkB,KAAK,IAFzB,EAGE;AACA;AACA;AACA;AACA;AACAvH,IAAAA,uBAAuB,CAACuH,kBAAD,EAAqBE,oBAArB,CAAvB;AACAvH,IAAAA,qBAAqB,CACnBqH,kBADmB,EAEnBQ,2CAFmB,CAArB;AAID;AACF;AAED,OAAO,SAAS6I,cAAT,GAA0B;AAC/B,MAAIlJ,4BAA4B,KAAKL,aAArC,EAAoD;AAClDK,IAAAA,4BAA4B,GAAGR,WAA/B;AACD;AACF,C,CAED;AACA;;AACA,OAAO,SAAS2J,wBAAT,GAA6C;AAClD;AACA;AACA,SAAOnJ,4BAA4B,KAAKV,cAAxC;AACD;;AAED,SAASuH,2BAAT,CAAqCzE,cAArC,EAA6E;AAC3E;AACA;AACA,QAAMgH,wBAAwB,GAAGzO,kBAAkB,CAACyH,cAAD,CAAnD;AACA,SAAOgH,wBAAwB,GAAGpO,uBAAlC;AACD;;AAED,SAASqO,6CAAT,CACEjH,cADF,EAEEH,cAFF,EAGU;AACR;AACA;AACA;AACA,QAAMmH,wBAAwB,GAAGzO,kBAAkB,CAACyH,cAAD,CAAnD;AACA,SACEgH,wBAAwB,IACvBnH,cAAc,CAACI,SAAf,GAA2B,CAA3B,IAAgCrH,uBADT,CAD1B;AAID,C,CAED;;AACA;;;AACA,SAASmM,YAAT,GAAwB;AACtB;AACA;AACA;AACA,SAAOrH,cAAc,KAAK,IAA1B,EAAgC;AAC9BA,IAAAA,cAAc,GAAGwJ,iBAAiB,CAACxJ,cAAD,CAAlC;AACD;AACF;AAED;;;AACA,SAASwF,kBAAT,GAA8B;AAC5B;AACA,SAAOxF,cAAc,KAAK,IAAnB,IAA2B,CAAC/I,WAAW,EAA9C,EAAkD;AAChD+I,IAAAA,cAAc,GAAGwJ,iBAAiB,CAACxJ,cAAD,CAAlC;AACD;AACF,C,CACD;;;AACA,SAASwJ,iBAAT,CAA2BC,UAA3B,EAA4D;AAC1D;AACA;AACA,QAAMxD,OAAO,GAAGwD,UAAU,CAACjG,SAA3B;AACA7F,EAAAA,cAAc,CAAC8L,UAAD,CAAd,CAJ0D,CAK1D;;AACAlM,EAAAA,yBAAyB,CAACkM,UAAD,CAAzB,CAN0D,CAO1D;;AACA,MAAIC,IAAJ,CAR0D,CAS1D;AACA;;AACA,MAAIrT,mBAAmB,IAAI,CAACoT,UAAU,CAACrH,IAAX,GAAkBtJ,WAAnB,MAAoCF,MAA/D,EAAuE;AACrEkE,IAAAA,kBAAkB,CAAC2M,UAAD,CAAlB;AACAC,IAAAA,IAAI,GAAGrO,SAAS,CAAC4K,OAAD,EAAUwD,UAAV,EAAsBxJ,oBAAtB,CAAhB;AACAlD,IAAAA,wCAAwC,CAAC0M,UAAD,EAAa,IAAb,CAAxC;AACD,GAJD,MAIO;AACL;AACA;AACAC,IAAAA,IAAI,GAAGrO,SAAS,CAAC4K,OAAD,EAAUwD,UAAV,EAAsBxJ,oBAAtB,CAAhB;AACD,GAnByD,CAoB1D;;;AACA5C,EAAAA,2BAA2B,GArB+B,CAsB1D;AACA;;AACAoM,EAAAA,UAAU,CAACE,aAAX,GAA2BF,UAAU,CAACG,YAAtC,CAxB0D,CAyB1D;AACA;;AACA,MAAIF,IAAI,KAAK,IAAb,EAAmB;AACjB;AACAA,IAAAA,IAAI,GAAGb,kBAAkB,CAACY,UAAD,CAAzB;AACD;;AAED1K,EAAAA,iBAAiB,CAACkH,OAAlB,GAA4B,IAA5B;AACA,SAAOyD,IAAP;AACD;AAED;;;;;;;AAKA,SAASb,kBAAT,CAA4BY,UAA5B,EAA6D;AAC3D;AACAzJ,EAAAA,cAAc,GAAGyJ,UAAjB;;AACA,KAAG;AACD;AACA;AACA,UAAMxD,OAAO,GAAGjG,cAAc,CAACwD,SAA/B,CAHC,CAID;;AACA,UAAMqG,WAAW,GAAG7J,cAAc,CAAC0D,MAAnC,CALC,CAMD;AACA;AACA;AACA;AACA;;AACA,QAAI,CAAC1D,cAAc,CAAC8J,SAAf,GAA2BzP,UAA5B,MAA4CX,QAAhD,EAA0D;AACxD;AACA6D,MAAAA,yBAAyB,CAACyC,cAAD,CAAzB;AACA,UAAI0J,IAAJ,CAHwD,CAIxD;AACA;AACA;;AACA,UACE,CAACrT,mBAAD,IACA,CAAC2J,cAAc,CAACoC,IAAf,GAAsBtJ,WAAvB,MAAwCF,MAF1C,EAGE;AACA;AACA;AACA8Q,QAAAA,IAAI,GAAGnO,YAAY,CAAC0K,OAAD,EAAUjG,cAAV,EAA0BC,oBAA1B,CAAnB;AACD,OAPD,MAOO;AACL;AACAnD,QAAAA,kBAAkB,CAACkD,cAAD,CAAlB,CAFK,CAGL;;AACA0J,QAAAA,IAAI,GAAGnO,YAAY,CAAC0K,OAAD,EAAUjG,cAAV,EAA0BC,oBAA1B,CAAnB,CAJK,CAKL;;AACAlD,QAAAA,wCAAwC,CAACiD,cAAD,EAAiB,KAAjB,CAAxC;AACD;;AACDpC,MAAAA,aAAa,CAACoC,cAAD,CAAb;AACA3C,MAAAA,2BAA2B;AAC3B0M,MAAAA,wBAAwB,CAAC/J,cAAD,CAAxB,CAxBwD,CAyBxD;AACA;;AACA,UAAI0J,IAAI,KAAK,IAAb,EAAmB;AACjB;AACA;AACA,eAAOA,IAAP;AACD,OA/BuD,CAiCxD;AACA;AACA;;;AACA,WACE;AACAG,MAAAA,WAAW,KAAK,IAAhB,IACA;AACA,OAACA,WAAW,CAACC,SAAZ,GAAwBzP,UAAzB,MAAyCX,QAJ3C,EAKE;AACA;AAEA;AACA,YAAImQ,WAAW,CAACG,WAAZ,KAA4B,IAAhC,EAAsC;AACpC;AACAH,UAAAA,WAAW,CAACG,WAAZ,GAA0BhK,cAAc,CAACgK,WAAzC;AACD;;AAED,YAAIhK,cAAc,CAACiK,UAAf,KAA8B,IAAlC,EAAwC;AACtC,cAAIJ,WAAW,CAACI,UAAZ,KAA2B,IAA/B,EAAqC;AACnC;AACAJ,YAAAA,WAAW,CAACI,UAAZ,CAAuBtJ,UAAvB,GAAoCX,cAAc,CAACgK,WAAnD;AACD,WAJqC,CAKtC;;;AACAH,UAAAA,WAAW,CAACI,UAAZ,GAAyBjK,cAAc,CAACiK,UAAxC;AACD,SAhBD,CAkBA;AACA;AACA;;;AACA,cAAMH,SAAS,GAAG9J,cAAc,CAAC8J,SAAjC,CArBA,CAuBA;AACA;AACA;AACA;AACA;;AACA,YAAIA,SAAS,GAAGnQ,aAAhB,EAA+B;AAC7B;AACA,cAAIkQ,WAAW,CAACI,UAAZ,KAA2B,IAA/B,EAAqC;AACnCJ,YAAAA,WAAW,CAACI,UAAZ,CAAuBtJ,UAAvB,GAAoCX,cAApC;AACD,WAFD,MAEO;AACL;AACA6J,YAAAA,WAAW,CAACG,WAAZ,GAA0BhK,cAA1B;AACD,WAP4B,CAQ7B;;;AACA6J,UAAAA,WAAW,CAACI,UAAZ,GAAyBjK,cAAzB;AACD;AACF;AACF,KAjFD,MAiFO;AACL;AACA;AACA;AACA;AACA,YAAM0J,IAAI,GAAGlO,UAAU,CAACwE,cAAD,EAAiBC,oBAAjB,CAAvB,CALK,CAOL;;AAEA,UACE5J,mBAAmB,IACnB,CAAC2J,cAAc,CAACoC,IAAf,GAAsBtJ,WAAvB,MAAwCF,MAF1C,EAGE;AACA;AACAmE,QAAAA,wCAAwC,CAACiD,cAAD,EAAiB,KAAjB,CAAxC,CAFA,CAIA;;AACA,YAAIkK,cAAc,GAAGlK,cAAc,CAACkK,cAApC;AACA,YAAIC,KAAK,GAAGnK,cAAc,CAACmK,KAA3B;;AACA,eAAOA,KAAK,KAAK,IAAjB,EAAuB;AACrBD,UAAAA,cAAc,IAAIC,KAAK,CAACD,cAAxB;AACAC,UAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AACDpK,QAAAA,cAAc,CAACkK,cAAf,GAAgCA,cAAhC;AACD;;AAED,UAAIR,IAAI,KAAK,IAAb,EAAmB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA7L,QAAAA,mBAAmB,CAACmC,cAAD,CAAnB;AACA0J,QAAAA,IAAI,CAACI,SAAL,IAAkBxP,cAAlB;AACA,eAAOoP,IAAP;AACD;;AACD9L,MAAAA,aAAa,CAACoC,cAAD,CAAb;;AAEA,UAAI6J,WAAW,KAAK,IAApB,EAA0B;AACxB;AACAA,QAAAA,WAAW,CAACG,WAAZ,GAA0BH,WAAW,CAACI,UAAZ,GAAyB,IAAnD;AACAJ,QAAAA,WAAW,CAACC,SAAZ,IAAyBzP,UAAzB;AACD;AACF,KAxIA,CAyID;;;AACA,UAAMgQ,YAAY,GAAGrK,cAAc,CAACoK,OAApC,CA1IC,CA2ID;;AACA,QAAIC,YAAY,KAAK,IAArB,EAA2B;AACzB;AACA,aAAOA,YAAP;AACD,KA/IA,CAgJD;;;AACArK,IAAAA,cAAc,GAAG6J,WAAjB;AACD,GAlJD,QAkJS7J,cAAc,KAAK,IAlJ5B,EAH2D,CAuJ3D;AACA;;;AACA,MAAIE,4BAA4B,KAAKV,cAArC,EAAqD;AACnDU,IAAAA,4BAA4B,GAAGL,aAA/B;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASyG,0BAAT,CAAoCpE,KAApC,EAAkD;AAChD,QAAMoI,oBAAoB,GAAGpI,KAAK,CAACI,cAAnC;AACA,QAAMuB,mBAAmB,GAAG3B,KAAK,CAAC2B,mBAAlC;AACA,SAAOyG,oBAAoB,GAAGzG,mBAAvB,GACHyG,oBADG,GAEHzG,mBAFJ;AAGD;;AAED,SAASkG,wBAAT,CAAkCQ,aAAlC,EAAwD;AACtD,MACEtK,oBAAoB,KAAKtF,KAAzB,IACA4P,aAAa,CAAC1G,mBAAd,KAAsClJ,KAFxC,EAGE;AACA;AACA;AACA;AACD;;AAED,MAAI6P,sBAAsB,GAAG/P,MAA7B,CAVsD,CAYtD;;AACA,MAAIpE,mBAAmB,IAAI,CAACkU,aAAa,CAACnI,IAAd,GAAqBtJ,WAAtB,MAAuCF,MAAlE,EAA0E;AACxE;AACA;AACA,QAAIsR,cAAc,GAAGK,aAAa,CAACL,cAAnC;AACA,QAAIO,gBAAgB,GAAGF,aAAa,CAACG,gBAArC,CAJwE,CAMxE;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,2BAA2B,GAC/BJ,aAAa,CAAC/G,SAAd,KAA4B,IAA5B,IACA+G,aAAa,CAACJ,KAAd,KAAwBI,aAAa,CAAC/G,SAAd,CAAwB2G,KAFlD;AAIA,QAAIA,KAAK,GAAGI,aAAa,CAACJ,KAA1B;;AACA,WAAOA,KAAK,KAAK,IAAjB,EAAuB;AACrB,YAAMS,yBAAyB,GAAGT,KAAK,CAAC7H,cAAxC;AACA,YAAMuI,wBAAwB,GAAGV,KAAK,CAACtG,mBAAvC;;AACA,UAAI+G,yBAAyB,GAAGJ,sBAAhC,EAAwD;AACtDA,QAAAA,sBAAsB,GAAGI,yBAAzB;AACD;;AACD,UAAIC,wBAAwB,GAAGL,sBAA/B,EAAuD;AACrDA,QAAAA,sBAAsB,GAAGK,wBAAzB;AACD;;AACD,UAAIF,2BAAJ,EAAiC;AAC/BT,QAAAA,cAAc,IAAIC,KAAK,CAACD,cAAxB;AACD;;AACDO,MAAAA,gBAAgB,IAAIN,KAAK,CAACM,gBAA1B;AACAN,MAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;;AACDG,IAAAA,aAAa,CAACL,cAAd,GAA+BA,cAA/B;AACAK,IAAAA,aAAa,CAACE,gBAAd,GAAiCA,gBAAjC;AACD,GAnCD,MAmCO;AACL,QAAIN,KAAK,GAAGI,aAAa,CAACJ,KAA1B;;AACA,WAAOA,KAAK,KAAK,IAAjB,EAAuB;AACrB,YAAMS,yBAAyB,GAAGT,KAAK,CAAC7H,cAAxC;AACA,YAAMuI,wBAAwB,GAAGV,KAAK,CAACtG,mBAAvC;;AACA,UAAI+G,yBAAyB,GAAGJ,sBAAhC,EAAwD;AACtDA,QAAAA,sBAAsB,GAAGI,yBAAzB;AACD;;AACD,UAAIC,wBAAwB,GAAGL,sBAA/B,EAAuD;AACrDA,QAAAA,sBAAsB,GAAGK,wBAAzB;AACD;;AACDV,MAAAA,KAAK,GAAGA,KAAK,CAACC,OAAd;AACD;AACF;;AAEDG,EAAAA,aAAa,CAAC1G,mBAAd,GAAoC2G,sBAApC;AACD;;AAED,SAAS3D,UAAT,CAAoBlE,IAApB,EAA0B;AACxB;AACA,QAAMmI,mBAAmB,GAAG/T,uBAAuB,EAAnD,CAFwB,CAGxB;AACA;;AACAC,EAAAA,eAAe,CACbK,iBADa,EAEb0T,cAAc,CAACvG,IAAf,CAAoB,IAApB,EAA0B7B,IAA1B,EAAgCmI,mBAAhC,CAFa,CAAf;AAIA,SAAO,IAAP;AACD;;AAED,SAASC,cAAT,CAAwBpI,IAAxB,EAA8BmI,mBAA9B,EAAmD;AACjD,KAAG;AACD;AACA;AACA;AACA9F,IAAAA,mBAAmB;AACpB,GALD,QAKShE,6BAA6B,KAAK,IAL3C,EADiD,CAOjD;;;AACAgK,EAAAA,uCAAuC;AAEvCpU,EAAAA,SAAS,CACP,CAACkJ,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SADlD,EAEP,gCAFO,CAAT,CAViD,CAcjD;;AACA,QAAM+G,YAAY,GAAGrD,IAAI,CAACqD,YAA1B,CAfiD,CAiBjD;;AACA,QAAM1D,cAAc,GAAGK,IAAI,CAACuD,sBAA5B,CAlBiD,CAoBjD;;AACA,MAAIF,YAAY,KAAK,IAArB,EAA2B;AACzB;AACA,WAAO,IAAP;AACD,GAxBgD,CAyBjD;;;AACArD,EAAAA,IAAI,CAACqD,YAAL,GAAoB,IAApB;AACArD,EAAAA,IAAI,CAACuD,sBAAL,GAA8BzL,MAA9B;AAEA7D,EAAAA,SAAS,CACPoP,YAAY,KAAKrD,IAAI,CAACsD,OADf,EAEP,2EACE,uCAHK,CAAT,CA7BiD,CAmCjD;AACA;;AACAtD,EAAAA,IAAI,CAAC4B,YAAL,GAAoB,IAApB;AACA5B,EAAAA,IAAI,CAAC0B,sBAAL,GAA8B5J,MAA9B;AACAkI,EAAAA,IAAI,CAAC2B,gBAAL,GAAwBlN,UAAxB;AACAuL,EAAAA,IAAI,CAACwB,qBAAL,GAA6B1J,MAA7B;AAEAuD,EAAAA,gBAAgB,GA1CiC,CA4CjD;AACA;;AACA,QAAMiN,mCAAmC,GAAG3E,0BAA0B,CACpEN,YADoE,CAAtE,CA9CiD,CAiDjD;;AACAvN,EAAAA,sBAAsB,CACpBkK,IADoB,EAEpBL,cAFoB,EAGpB2I,mCAHoB,CAAtB,CAlDiD,CAuDjD;;AACA,MAAItI,IAAI,KAAK5C,kBAAb,EAAiC;AAC/B;AACAA,IAAAA,kBAAkB,GAAG,IAArB;AACAC,IAAAA,cAAc,GAAG,IAAjB;AACAC,IAAAA,oBAAoB,GAAGxF,MAAvB;AACD,GALD,MAKO,CACL;AACA;AACD,GAhEgD,CAkEjD;AACA;AACA;AACA;AACA;;;AACA,MAAIuP,WAAJ,CAvEiD,CAwEjD;AACA;AACA;;AACA,MAAIhE,YAAY,CAAC8D,SAAb,GAAyBnQ,aAA7B,EAA4C;AAC1C,QAAIqM,YAAY,CAACiE,UAAb,KAA4B,IAAhC,EAAsC;AACpCjE,MAAAA,YAAY,CAACiE,UAAb,CAAwBtJ,UAAxB,GAAqCqF,YAArC;AACAgE,MAAAA,WAAW,GAAGhE,YAAY,CAACgE,WAA3B;AACD,KAHD,MAGO;AACLA,MAAAA,WAAW,GAAGhE,YAAd;AACD;AACF,GAPD,MAOO;AACL;AACA;AACAgE,IAAAA,WAAW,GAAGhE,YAAY,CAACgE,WAA3B;AACD,GAtFgD,CAwFjD;AACA;AAEA;;;AACA,MAAIA,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA,UAAM7E,oBAAoB,GAAGrF,gBAA7B,CAFwB,CAGxB;;AACAA,IAAAA,gBAAgB,IAAIP,aAApB;AACA,UAAM+F,gBAAgB,GAAGC,gBAAgB,CAAC5C,IAAD,CAAzC,CALwB,CAOxB;;AACA5D,IAAAA,iBAAiB,CAACkH,OAAlB,GAA4B,IAA5B,CARwB,CAUxB;AACA;AACA;AAEA;AACA;AACA;;AACA/H,IAAAA,+BAA+B;AAC/BnG,IAAAA,gBAAgB,CAAC4K,IAAI,CAACuI,aAAN,CAAhB;AACAvK,IAAAA,UAAU,GAAGqJ,WAAb,CAnBwB,CAoBxB;AACA;;AACA,OAAG;AACD,UAAIxD,OAAJ,EAAa;AACXhI,QAAAA,qBAAqB,CAAC,IAAD,EAAO2M,2BAAP,EAAoC,IAApC,CAArB;;AACA,YAAI1M,cAAc,EAAlB,EAAsB;AACpB7H,UAAAA,SAAS,CAAC+J,UAAU,KAAK,IAAhB,EAAsB,iCAAtB,CAAT;AACA,gBAAM+G,KAAK,GAAGhJ,gBAAgB,EAA9B;AACA0M,UAAAA,uBAAuB,CAACzK,UAAD,EAAa+G,KAAb,CAAvB;AACA/G,UAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF,OARD,MAQO;AACL,YAAI;AACFwK,UAAAA,2BAA2B;AAC5B,SAFD,CAEE,OAAOzD,KAAP,EAAc;AACd9Q,UAAAA,SAAS,CAAC+J,UAAU,KAAK,IAAhB,EAAsB,iCAAtB,CAAT;AACAyK,UAAAA,uBAAuB,CAACzK,UAAD,EAAa+G,KAAb,CAAvB;AACA/G,UAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;AACF,KAlBD,QAkBSA,UAAU,KAAK,IAlBxB;;AAmBAxC,IAAAA,8BAA8B;;AAE9B,QAAI9H,mBAAJ,EAAyB;AACvB;AACA;AACAwG,MAAAA,gBAAgB;AACjB,KA/CuB,CAiDxB;;;AACAuB,IAAAA,2BAA2B,GAlDH,CAmDxB;;AACAuC,IAAAA,UAAU,GAAGqJ,WAAb;;AACA,OAAG;AACD,UAAIxD,OAAJ,EAAa;AACXhI,QAAAA,qBAAqB,CACnB,IADmB,EAEnB6M,qBAFmB,EAGnB,IAHmB,EAInB1I,IAJmB,EAKnBmI,mBALmB,CAArB;;AAOA,YAAIrM,cAAc,EAAlB,EAAsB;AACpB7H,UAAAA,SAAS,CAAC+J,UAAU,KAAK,IAAhB,EAAsB,iCAAtB,CAAT;AACA,gBAAM+G,KAAK,GAAGhJ,gBAAgB,EAA9B;AACA0M,UAAAA,uBAAuB,CAACzK,UAAD,EAAa+G,KAAb,CAAvB;AACA/G,UAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF,OAdD,MAcO;AACL,YAAI;AACF0K,UAAAA,qBAAqB,CAAC1I,IAAD,EAAOmI,mBAAP,CAArB;AACD,SAFD,CAEE,OAAOpD,KAAP,EAAc;AACd9Q,UAAAA,SAAS,CAAC+J,UAAU,KAAK,IAAhB,EAAsB,iCAAtB,CAAT;AACAyK,UAAAA,uBAAuB,CAACzK,UAAD,EAAa+G,KAAb,CAAvB;AACA/G,UAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;AACF,KAxBD,QAwBSA,UAAU,KAAK,IAxBxB;;AAyBAtC,IAAAA,0BAA0B;AAC1BrG,IAAAA,gBAAgB,CAAC2K,IAAI,CAACuI,aAAN,CAAhB,CA/EwB,CAiFxB;AACA;AACA;AACA;;AACAvI,IAAAA,IAAI,CAACsD,OAAL,GAAeD,YAAf,CArFwB,CAuFxB;AACA;AACA;;AACA1H,IAAAA,0BAA0B,GA1FF,CA2FxB;;AACAqC,IAAAA,UAAU,GAAGqJ,WAAb;;AACA,OAAG;AACD,UAAIxD,OAAJ,EAAa;AACXhI,QAAAA,qBAAqB,CACnB,IADmB,EAEnB8M,mBAFmB,EAGnB,IAHmB,EAInB3I,IAJmB,EAKnBL,cALmB,CAArB;;AAOA,YAAI7D,cAAc,EAAlB,EAAsB;AACpB7H,UAAAA,SAAS,CAAC+J,UAAU,KAAK,IAAhB,EAAsB,iCAAtB,CAAT;AACA,gBAAM+G,KAAK,GAAGhJ,gBAAgB,EAA9B;AACA0M,UAAAA,uBAAuB,CAACzK,UAAD,EAAa+G,KAAb,CAAvB;AACA/G,UAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF,OAdD,MAcO;AACL,YAAI;AACF2K,UAAAA,mBAAmB,CAAC3I,IAAD,EAAOL,cAAP,CAAnB;AACD,SAFD,CAEE,OAAOoF,KAAP,EAAc;AACd9Q,UAAAA,SAAS,CAAC+J,UAAU,KAAK,IAAhB,EAAsB,iCAAtB,CAAT;AACAyK,UAAAA,uBAAuB,CAACzK,UAAD,EAAa+G,KAAb,CAAvB;AACA/G,UAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;AACF,KAxBD,QAwBSA,UAAU,KAAK,IAxBxB;;AAyBApC,IAAAA,yBAAyB,GAtHD,CAwHxB;;AACAoC,IAAAA,UAAU,GAAG,IAAb,CAzHwB,CA2HxB;AACA;;AACAzJ,IAAAA,YAAY;;AAEZ,QAAIZ,sBAAJ,EAA4B;AAC1BsP,MAAAA,eAAe,CAAGN,gBAAH,CAAf;AACD;;AACDxF,IAAAA,gBAAgB,GAAGqF,oBAAnB;AACD,GAnID,MAmIO;AACL;AACAxC,IAAAA,IAAI,CAACsD,OAAL,GAAeD,YAAf,CAFK,CAGL;AACA;AACA;;AACA9H,IAAAA,+BAA+B;AAC/BC,IAAAA,8BAA8B;;AAC9B,QAAI9H,mBAAJ,EAAyB;AACvBwG,MAAAA,gBAAgB;AACjB;;AACDuB,IAAAA,2BAA2B;AAC3BC,IAAAA,0BAA0B;AAC1BC,IAAAA,0BAA0B;AAC1BC,IAAAA,yBAAyB;AAC1B;;AAEDN,EAAAA,eAAe;AAEf,QAAMsN,yBAAyB,GAAGxK,0BAAlC;;AAEA,MAAIA,0BAAJ,EAAgC;AAC9B;AACA;AACAA,IAAAA,0BAA0B,GAAG,KAA7B;AACAC,IAAAA,6BAA6B,GAAG2B,IAAhC;AACAzB,IAAAA,mCAAmC,GAAGoB,cAAtC;AACArB,IAAAA,mCAAmC,GAAG6J,mBAAtC;AACD,GAPD,MAOO;AACL;AACA;AACA;AACAnK,IAAAA,UAAU,GAAGqJ,WAAb;;AACA,WAAOrJ,UAAU,KAAK,IAAtB,EAA4B;AAC1B,YAAM6K,cAAc,GAAG7K,UAAU,CAACA,UAAlC;AACAA,MAAAA,UAAU,CAACA,UAAX,GAAwB,IAAxB;AACAA,MAAAA,UAAU,GAAG6K,cAAb;AACD;AACF,GArQgD,CAuQjD;;;AACA,QAAMC,uBAAuB,GAAG9I,IAAI,CAACsB,gBAArC;;AACA,MAAIwH,uBAAuB,KAAKhR,MAAhC,EAAwC;AACtC,QAAInE,sBAAJ,EAA4B;AAC1B,UAAIsL,uBAAuB,KAAK,IAAhC,EAAsC;AACpC,cAAM8J,eAAe,GAAG9J,uBAAxB;AACAA,QAAAA,uBAAuB,GAAG,IAA1B;;AACA,aAAK,IAAI+J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,eAAe,CAACE,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/CE,UAAAA,oBAAoB,CAClBlJ,IADkB,EAElB+I,eAAe,CAACC,CAAD,CAFG,EAGlBhJ,IAAI,CAACoG,oBAHa,CAApB;AAKD;AACF;;AACDhG,MAAAA,2BAA2B,CAACJ,IAAD,EAAO8I,uBAAP,CAA3B;AACD;AACF,GAfD,MAeO;AACL;AACA;AACA3K,IAAAA,sCAAsC,GAAG,IAAzC;AACD;;AAED,MAAIxK,sBAAJ,EAA4B;AAC1B,QAAI,CAACiV,yBAAL,EAAgC;AAC9B;AACA;AACA;AACA;AACAO,MAAAA,yBAAyB,CAACnJ,IAAD,EAAOL,cAAP,CAAzB;AACD;AACF;;AAED,MAAImJ,uBAAuB,KAAK/Q,IAAhC,EAAsC;AACpC;AACA;AACA,QAAIiI,IAAI,KAAKnB,qBAAb,EAAoC;AAClCD,MAAAA,iBAAiB;AAClB,KAFD,MAEO;AACLA,MAAAA,iBAAiB,GAAG,CAApB;AACAC,MAAAA,qBAAqB,GAAGmB,IAAxB;AACD;AACF,GATD,MASO;AACLpB,IAAAA,iBAAiB,GAAG,CAApB;AACD;;AAED5C,EAAAA,YAAY,CAACqH,YAAY,CAACpC,SAAd,EAAyBtB,cAAzB,CAAZ,CArTiD,CAuTjD;AACA;;AACAW,EAAAA,qBAAqB,CAACN,IAAD,CAArB;;AAEA,MAAI/B,gBAAJ,EAAsB;AACpBA,IAAAA,gBAAgB,GAAG,KAAnB;AACA,UAAM8G,KAAK,GAAG7G,kBAAd;AACAA,IAAAA,kBAAkB,GAAG,IAArB;AACA,UAAM6G,KAAN;AACD;;AAED,MAAI,CAAC5H,gBAAgB,GAAGT,sBAApB,MAAgDJ,SAApD,EAA+D;AAC7D;AACA;AACA;AACA;AACA,WAAO,IAAP;AACD,GAxUgD,CA0UjD;;;AACAvH,EAAAA,sBAAsB;AACtB,SAAO,IAAP;AACD,C,CAED;AACA;;;AACA,SAASyT,2BAAT,GAAuC;AACrC;AACA,SAAOxK,UAAU,KAAK,IAAtB,EAA4B;AAC1B;AACA;AAEA;AACA;AACA,UAAMmJ,SAAS,GAAGnJ,UAAU,CAACmJ,SAA7B,CAN0B,CAO1B;AACA;AACA;AAEA;AACA;;AACA,QAAI,CAACA,SAAS,GAAG5P,QAAb,MAA2BR,QAA/B,EAAyC;AACvC;AACA6D,MAAAA,yBAAyB,CAACoD,UAAD,CAAzB,CAFuC,CAGvC;;AACAlD,MAAAA,YAAY,GAJ2B,CAKvC;;AACA,YAAMwI,OAAO,GAAGtF,UAAU,CAAC6C,SAA3B,CANuC,CAOvC;AACA;;AACA1H,MAAAA,iCAAiC,CAACmK,OAAD,EAAUtF,UAAV,CAAjC,CATuC,CAUvC;;AACAtD,MAAAA,2BAA2B;AAC5B,KAzByB,CA0B1B;AACA;AACA;;;AACA,QAAI,CAACyM,SAAS,GAAG1P,OAAb,MAA0BV,QAA9B,EAAwC;AACtC;AACA;AACA,UAAI,CAACqH,0BAAL,EAAiC;AAC/BA,QAAAA,0BAA0B,GAAG,IAA7B;AACAlK,QAAAA,gBAAgB,CAACU,cAAD,EAAiB,MAAM;AACrC;AACAyN,UAAAA,mBAAmB;AACnB,iBAAO,IAAP;AACD,SAJe,CAAhB;AAKD;AACF;;AACDrE,IAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF,C,CAED;AACA;;;AACA,SAAS0K,qBAAT,CAA+B1I,IAA/B,EAAgDmI,mBAAhD,EAAqE;AACnE;AACA,SAAOnK,UAAU,KAAK,IAAtB,EAA4B;AAC1B;AACApD,IAAAA,yBAAyB,CAACoD,UAAD,CAAzB,CAF0B,CAG1B;AACA;AACA;;AACA,UAAMmJ,SAAS,GAAGnJ,UAAU,CAACmJ,SAA7B,CAN0B,CAQ1B;;AACA,QAAIA,SAAS,GAAG7P,YAAhB,EAA8B;AAC5BsC,MAAAA,sBAAsB,CAACoE,UAAD,CAAtB;AACD,KAXyB,CAY1B;;;AACA,QAAImJ,SAAS,GAAG9P,GAAhB,EAAqB;AACnB,YAAMiM,OAAO,GAAGtF,UAAU,CAAC6C,SAA3B;;AACA,UAAIyC,OAAO,KAAK,IAAhB,EAAsB;AACpB5J,QAAAA,eAAe,CAAC4J,OAAD,CAAf;AACD;AACF,KAlByB,CAoB1B;;;AACA,QAAI8F,gBAAgB,GAClBjC,SAAS,IAAIlQ,SAAS,GAAGC,MAAZ,GAAqBE,QAArB,GAAgCQ,SAApC,CADX,CArB0B,CAuB1B;AACA;;AACA,YAAQwR,gBAAR;AACE;AACA,WAAKnS,SAAL;AAAgB;AACdsC,UAAAA,eAAe,CAACyE,UAAD,CAAf,CADc,CAEd;AACA;AACA;;AACAA,UAAAA,UAAU,CAACmJ,SAAX,IAAwB,CAAClQ,SAAzB;AACA;AACD;AACD;;AACA,WAAKE,kBAAL;AAAyB;AACvB;AACAoC,UAAAA,eAAe,CAACyE,UAAD,CAAf,CAFuB,CAGvB;AACA;;AACAA,UAAAA,UAAU,CAACmJ,SAAX,IAAwB,CAAClQ,SAAzB,CALuB,CAOvB;;AACA,gBAAMqM,OAAO,GAAGtF,UAAU,CAAC6C,SAA3B;AACArH,UAAAA,UAAU,CAAC8J,OAAD,EAAUtF,UAAV,CAAV;AACA;AACD;AACD;;AACA,WAAKpG,SAAL;AAAgB;AACdoG,UAAAA,UAAU,CAACmJ,SAAX,IAAwB,CAACvP,SAAzB;AACA;AACD;AACD;;AACA,WAAKC,kBAAL;AAAyB;AACvBmG,UAAAA,UAAU,CAACmJ,SAAX,IAAwB,CAACvP,SAAzB,CADuB,CAGvB;;AACA,gBAAM0L,OAAO,GAAGtF,UAAU,CAAC6C,SAA3B;AACArH,UAAAA,UAAU,CAAC8J,OAAD,EAAUtF,UAAV,CAAV;AACA;AACD;AACD;;AACA,WAAK9G,MAAL;AAAa;AACX,gBAAMoM,OAAO,GAAGtF,UAAU,CAAC6C,SAA3B;AACArH,UAAAA,UAAU,CAAC8J,OAAD,EAAUtF,UAAV,CAAV;AACA;AACD;AACD;;AACA,WAAK5G,QAAL;AAAe;AACbqC,UAAAA,cAAc,CAACuG,IAAD,EAAOhC,UAAP,EAAmBmK,mBAAnB,CAAd;AACA;AACD;AA/CH,KAzB0B,CA2E1B;;;AACArN,IAAAA,YAAY;AAEZJ,IAAAA,2BAA2B;AAC3BsD,IAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF,C,CAED;;;AACA,SAAS2K,mBAAT,CACE3I,IADF,EAEEqJ,uBAFF,EAGE;AACA,SAAOrL,UAAU,KAAK,IAAtB,EAA4B;AAC1BpD,IAAAA,yBAAyB,CAACoD,UAAD,CAAzB,CAD0B,CAE1B;;AACA,UAAMmJ,SAAS,GAAGnJ,UAAU,CAACmJ,SAA7B,CAH0B,CAI1B;AACA;AACA;;AACA,QAAIA,SAAS,IAAIjQ,MAAM,GAAGM,QAAb,CAAb,EAAqC;AACnCsD,MAAAA,YAAY;AACZ,YAAMwI,OAAO,GAAGtF,UAAU,CAAC6C,SAA3B,CAFmC,CAGnC;AACA;;AACAxH,MAAAA,yBAAyB,CACvB2G,IADuB,EAEvBsD,OAFuB,EAGvBtF,UAHuB,EAIvBqL,uBAJuB,CAAzB;AAMD,KAlByB,CAmB1B;AACA;;;AACA,QAAIlC,SAAS,GAAG9P,GAAhB,EAAqB;AACnByD,MAAAA,YAAY;AACZnB,MAAAA,eAAe,CAACqE,UAAD,CAAf;AACD;;AAEDtD,IAAAA,2BAA2B,GA1BD,CA2B1B;;AACAsD,IAAAA,UAAU,GAAGA,UAAU,CAACA,UAAxB;AACD;AACF;;AAED,OAAO,SAASqE,mBAAT,GAA+B;AACpC,MAAI/D,mCAAmC,KAAK7J,UAA5C,EAAwD;AACtD,UAAMiL,aAAa,GACjBpB,mCAAmC,GAAG1J,cAAtC,GACIA,cADJ,GAEI0J,mCAHN;AAIAA,IAAAA,mCAAmC,GAAG7J,UAAtC;AACA,WAAOJ,eAAe,CAACqL,aAAD,EAAgB4J,uBAAhB,CAAtB;AACD;AACF;AAED,OAAO,SAASC,oCAAT,CACLhK,KADK,EAELiK,MAFK,EAGC;AACN,MAAIlW,wCAAJ,EAA8C;AAC5CkL,IAAAA,8BAA8B,CAACiL,IAA/B,CAAoCD,MAApC,EAA4CjK,KAA5C;;AACA,QAAI,CAACnB,0BAAL,EAAiC;AAC/BA,MAAAA,0BAA0B,GAAG,IAA7B;AACAlK,MAAAA,gBAAgB,CAACU,cAAD,EAAiB,MAAM;AACrCyN,QAAAA,mBAAmB;AACnB,eAAO,IAAP;AACD,OAHe,CAAhB;AAID;AACF;AACF;AAED,OAAO,SAASqH,sCAAT,CACLnK,KADK,EAELiK,MAFK,EAGC;AACN,MAAIlW,wCAAJ,EAA8C;AAC5CmL,IAAAA,gCAAgC,CAACgL,IAAjC,CAAsCD,MAAtC,EAA8CjK,KAA9C;;AACA,QAAI,CAACnB,0BAAL,EAAiC;AAC/BA,MAAAA,0BAA0B,GAAG,IAA7B;AACAlK,MAAAA,gBAAgB,CAACU,cAAD,EAAiB,MAAM;AACrCyN,QAAAA,mBAAmB;AACnB,eAAO,IAAP;AACD,OAHe,CAAhB;AAID;AACF;AACF;;AAED,SAASsH,yBAAT,CAAmCH,MAAnC,EAA6D;AAC3D,QAAMI,MAAM,GAAGJ,MAAM,CAACI,MAAtB;AACAJ,EAAAA,MAAM,CAACK,OAAP,GAAiBD,MAAM,EAAvB;AACD;;AAED,SAASN,uBAAT,GAAmC;AACjC,MAAIjL,6BAA6B,KAAK,IAAtC,EAA4C;AAC1C,WAAO,KAAP;AACD;;AACD,QAAM2B,IAAI,GAAG3B,6BAAb;AACA,QAAMsB,cAAc,GAAGpB,mCAAvB;AACAF,EAAAA,6BAA6B,GAAG,IAAhC;AACAE,EAAAA,mCAAmC,GAAGzG,MAAtC;AAEA7D,EAAAA,SAAS,CACP,CAACkJ,gBAAgB,IAAIR,aAAa,GAAGC,aAApB,CAAjB,MAAyDN,SADlD,EAEP,uDAFO,CAAT;AAIA,QAAMkG,oBAAoB,GAAGrF,gBAA7B;AACAA,EAAAA,gBAAgB,IAAIP,aAApB;AACA,QAAM+F,gBAAgB,GAAGC,gBAAgB,CAAC5C,IAAD,CAAzC;;AAEA,MAAI1M,wCAAJ,EAA8C;AAC5C;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,QAAIwW,cAAc,GAAGrL,gCAArB;AACAA,IAAAA,gCAAgC,GAAG,EAAnC;;AACA,SAAK,IAAIuK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGc,cAAc,CAACb,MAAnC,EAA2CD,CAAC,IAAI,CAAhD,EAAmD;AACjD,YAAMQ,MAAM,GAAKM,cAAc,CAACd,CAAD,CAA/B;AACA,YAAMzJ,KAAK,GAAKuK,cAAc,CAACd,CAAC,GAAG,CAAL,CAA9B;AACA,YAAMa,OAAO,GAAGL,MAAM,CAACK,OAAvB;AACAL,MAAAA,MAAM,CAACK,OAAP,GAAiBnJ,SAAjB;;AACA,UAAI,OAAOmJ,OAAP,KAAmB,UAAvB,EAAmC;AACjC,YAAIhG,OAAJ,EAAa;AACXjJ,UAAAA,yBAAyB,CAAC2E,KAAD,CAAzB;AACA1D,UAAAA,qBAAqB,CAAC,IAAD,EAAOgO,OAAP,EAAgB,IAAhB,CAArB;;AACA,cAAI/N,cAAc,EAAlB,EAAsB;AACpB7H,YAAAA,SAAS,CAACsL,KAAK,KAAK,IAAX,EAAiB,iCAAjB,CAAT;AACA,kBAAMwF,KAAK,GAAGhJ,gBAAgB,EAA9B;AACA0M,YAAAA,uBAAuB,CAAClJ,KAAD,EAAQwF,KAAR,CAAvB;AACD;;AACDrK,UAAAA,2BAA2B;AAC5B,SATD,MASO;AACL,cAAI;AACFmP,YAAAA,OAAO;AACR,WAFD,CAEE,OAAO9E,KAAP,EAAc;AACd9Q,YAAAA,SAAS,CAACsL,KAAK,KAAK,IAAX,EAAiB,iCAAjB,CAAT;AACAkJ,YAAAA,uBAAuB,CAAClJ,KAAD,EAAQwF,KAAR,CAAvB;AACD;AACF;AACF;AACF,KAnC2C,CAqC5C;;;AACA,QAAIgF,YAAY,GAAGvL,8BAAnB;AACAA,IAAAA,8BAA8B,GAAG,EAAjC;;AACA,SAAK,IAAIwK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,YAAY,CAACd,MAAjC,EAAyCD,CAAC,IAAI,CAA9C,EAAiD;AAC/C,YAAMQ,MAAM,GAAKO,YAAY,CAACf,CAAD,CAA7B;AACA,YAAMzJ,KAAK,GAAKwK,YAAY,CAACf,CAAC,GAAG,CAAL,CAA5B;;AACA,UAAInF,OAAJ,EAAa;AACXjJ,QAAAA,yBAAyB,CAAC2E,KAAD,CAAzB;AACA1D,QAAAA,qBAAqB,CAAC,IAAD,EAAO8N,yBAAP,EAAkC,IAAlC,EAAwCH,MAAxC,CAArB;;AACA,YAAI1N,cAAc,EAAlB,EAAsB;AACpB7H,UAAAA,SAAS,CAACsL,KAAK,KAAK,IAAX,EAAiB,iCAAjB,CAAT;AACA,gBAAMwF,KAAK,GAAGhJ,gBAAgB,EAA9B;AACA0M,UAAAA,uBAAuB,CAAClJ,KAAD,EAAQwF,KAAR,CAAvB;AACD;;AACDrK,QAAAA,2BAA2B;AAC5B,OATD,MASO;AACL,YAAI;AACF,gBAAMkP,MAAM,GAAGJ,MAAM,CAACI,MAAtB;AACAJ,UAAAA,MAAM,CAACK,OAAP,GAAiBD,MAAM,EAAvB;AACD,SAHD,CAGE,OAAO7E,KAAP,EAAc;AACd9Q,UAAAA,SAAS,CAACsL,KAAK,KAAK,IAAX,EAAiB,iCAAjB,CAAT;AACAkJ,UAAAA,uBAAuB,CAAClJ,KAAD,EAAQwF,KAAR,CAAvB;AACD;AACF;AACF;AACF,GA9DD,MA8DO;AACL;AACA;AACA;AACA,QAAIyE,MAAM,GAAGxJ,IAAI,CAACsD,OAAL,CAAa+D,WAA1B;;AACA,WAAOmC,MAAM,KAAK,IAAlB,EAAwB;AACtB,UAAI3F,OAAJ,EAAa;AACXjJ,QAAAA,yBAAyB,CAAC4O,MAAD,CAAzB;AACA3N,QAAAA,qBAAqB,CAAC,IAAD,EAAOvC,wBAAP,EAAiC,IAAjC,EAAuCkQ,MAAvC,CAArB;;AACA,YAAI1N,cAAc,EAAlB,EAAsB;AACpB7H,UAAAA,SAAS,CAACuV,MAAM,KAAK,IAAZ,EAAkB,iCAAlB,CAAT;AACA,gBAAMzE,KAAK,GAAGhJ,gBAAgB,EAA9B;AACA0M,UAAAA,uBAAuB,CAACe,MAAD,EAASzE,KAAT,CAAvB;AACD;;AACDrK,QAAAA,2BAA2B;AAC5B,OATD,MASO;AACL,YAAI;AACFpB,UAAAA,wBAAwB,CAACkQ,MAAD,CAAxB;AACD,SAFD,CAEE,OAAOzE,KAAP,EAAc;AACd9Q,UAAAA,SAAS,CAACuV,MAAM,KAAK,IAAZ,EAAkB,iCAAlB,CAAT;AACAf,UAAAA,uBAAuB,CAACe,MAAD,EAASzE,KAAT,CAAvB;AACD;AACF;;AACD,YAAM8D,cAAc,GAAGW,MAAM,CAACxL,UAA9B,CAlBsB,CAmBtB;;AACAwL,MAAAA,MAAM,CAACxL,UAAP,GAAoB,IAApB;AACAwL,MAAAA,MAAM,GAAGX,cAAT;AACD;AACF;;AAED,MAAIlV,sBAAJ,EAA4B;AAC1BsP,IAAAA,eAAe,CAAGN,gBAAH,CAAf;AACAwG,IAAAA,yBAAyB,CAACnJ,IAAD,EAAOL,cAAP,CAAzB;AACD;;AAEDxC,EAAAA,gBAAgB,GAAGqF,oBAAnB;AAEAzN,EAAAA,sBAAsB,GApHW,CAsHjC;AACA;;AACAgK,EAAAA,wBAAwB,GACtBV,6BAA6B,KAAK,IAAlC,GAAyC,CAAzC,GAA6CU,wBAAwB,GAAG,CAD1E;AAGA,SAAO,IAAP;AACD;;AAED,OAAO,SAASiL,kCAAT,CAA4CC,QAA5C,EAAsE;AAC3E,SACE9L,sCAAsC,KAAK,IAA3C,IACAA,sCAAsC,CAAC+L,GAAvC,CAA2CD,QAA3C,CAFF;AAID;AAED,OAAO,SAASE,+BAAT,CAAyCF,QAAzC,EAA0D;AAC/D,MAAI9L,sCAAsC,KAAK,IAA/C,EAAqD;AACnDA,IAAAA,sCAAsC,GAAG,IAAIiM,GAAJ,CAAQ,CAACH,QAAD,CAAR,CAAzC;AACD,GAFD,MAEO;AACL9L,IAAAA,sCAAsC,CAACkM,GAAvC,CAA2CJ,QAA3C;AACD;AACF;;AAED,SAASK,2BAAT,CAAqCvF,KAArC,EAAmD;AACjD,MAAI,CAAC9G,gBAAL,EAAuB;AACrBA,IAAAA,gBAAgB,GAAG,IAAnB;AACAC,IAAAA,kBAAkB,GAAG6G,KAArB;AACD;AACF;;AACD,OAAO,MAAMwF,eAAe,GAAGD,2BAAxB;;AAEP,SAASE,6BAAT,CACEC,SADF,EAEEC,WAFF,EAGE3F,KAHF,EAIE;AACA,QAAM4F,SAAS,GAAG1Q,mBAAmB,CAAC8K,KAAD,EAAQ2F,WAAR,CAArC;AACA,QAAME,MAAM,GAAG5R,qBAAqB,CAACyR,SAAD,EAAYE,SAAZ,EAAuB5S,IAAvB,CAApC;AACA8B,EAAAA,aAAa,CAAC4Q,SAAD,EAAYG,MAAZ,CAAb;AACA,QAAM5K,IAAI,GAAGC,6BAA6B,CAACwK,SAAD,EAAY1S,IAAZ,CAA1C;;AACA,MAAIiI,IAAI,KAAK,IAAb,EAAmB;AACjBM,IAAAA,qBAAqB,CAACN,IAAD,CAArB;AACAI,IAAAA,2BAA2B,CAACJ,IAAD,EAAOjI,IAAP,CAA3B;AACD;AACF;;AAED,OAAO,SAAS0Q,uBAAT,CAAiCiC,WAAjC,EAAqD3F,KAArD,EAAmE;AACxE,MAAI2F,WAAW,CAAC1J,GAAZ,KAAoB1K,QAAxB,EAAkC;AAChC;AACA;AACAkU,IAAAA,6BAA6B,CAACE,WAAD,EAAcA,WAAd,EAA2B3F,KAA3B,CAA7B;AACA;AACD;;AAED,MAAIxF,KAAK,GAAGmL,WAAW,CAAC3J,MAAxB;;AACA,SAAOxB,KAAK,KAAK,IAAjB,EAAuB;AACrB,QAAIA,KAAK,CAACyB,GAAN,KAAc1K,QAAlB,EAA4B;AAC1BkU,MAAAA,6BAA6B,CAACjL,KAAD,EAAQmL,WAAR,EAAqB3F,KAArB,CAA7B;AACA;AACD,KAHD,MAGO,IAAIxF,KAAK,CAACyB,GAAN,KAAczK,cAAlB,EAAkC;AACvC,YAAMsU,IAAI,GAAGtL,KAAK,CAACuL,IAAnB;AACA,YAAMb,QAAQ,GAAG1K,KAAK,CAAC0B,SAAvB;;AACA,UACE,OAAO4J,IAAI,CAACE,wBAAZ,KAAyC,UAAzC,IACC,OAAOd,QAAQ,CAACe,iBAAhB,KAAsC,UAAtC,IACC,CAAChB,kCAAkC,CAACC,QAAD,CAHvC,EAIE;AACA,cAAMU,SAAS,GAAG1Q,mBAAmB,CAAC8K,KAAD,EAAQ2F,WAAR,CAArC;AACA,cAAME,MAAM,GAAG3R,sBAAsB,CACnCsG,KADmC,EAEnCoL,SAFmC,EAGnC;AACA5S,QAAAA,IAJmC,CAArC;AAMA8B,QAAAA,aAAa,CAAC0F,KAAD,EAAQqL,MAAR,CAAb;AACA,cAAM5K,IAAI,GAAGC,6BAA6B,CAACV,KAAD,EAAQxH,IAAR,CAA1C;;AACA,YAAIiI,IAAI,KAAK,IAAb,EAAmB;AACjBM,UAAAA,qBAAqB,CAACN,IAAD,CAArB;AACAI,UAAAA,2BAA2B,CAACJ,IAAD,EAAOjI,IAAP,CAA3B;AACD;;AACD;AACD;AACF;;AACDwH,IAAAA,KAAK,GAAGA,KAAK,CAACwB,MAAd;AACD;AACF;AAED,OAAO,SAASkK,iBAAT,CACLjL,IADK,EAELkL,QAFK,EAGLC,aAHK,EAIL;AACA,QAAMC,SAAS,GAAGpL,IAAI,CAACoL,SAAvB;;AACA,MAAIA,SAAS,KAAK,IAAlB,EAAwB;AACtB;AACA;AACAA,IAAAA,SAAS,CAACC,MAAV,CAAiBH,QAAjB;AACD;;AAED,MAAI9N,kBAAkB,KAAK4C,IAAvB,IAA+B1C,oBAAoB,KAAK6N,aAA5D,EAA2E;AACzE;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QACE5N,4BAA4B,KAAKN,sBAAjC,IACCM,4BAA4B,KAAKP,aAAjC,IACCS,+CAA+C,KAAK1F,IADrD,IAECvD,GAAG,KAAKsJ,4BAAR,GAAuCC,oBAJ3C,EAKE;AACA;AACA;AACAuE,MAAAA,iBAAiB,CAACtC,IAAD,EAAO1C,oBAAP,CAAjB;AACD,KATD,MASO;AACL;AACA;AACAO,MAAAA,gCAAgC,GAAG,IAAnC;AACD;;AACD;AACD;;AAED,MAAI,CAACjI,qBAAqB,CAACoK,IAAD,EAAOmL,aAAP,CAA1B,EAAiD;AAC/C;AACA;AACD;;AAED,QAAM5J,cAAc,GAAGvB,IAAI,CAACuB,cAA5B;;AACA,MAAIA,cAAc,KAAKzJ,MAAnB,IAA6ByJ,cAAc,GAAG4J,aAAlD,EAAiE;AAC/D;AACA;AACD,GAhDD,CAkDA;;;AACAnL,EAAAA,IAAI,CAACuB,cAAL,GAAsB4J,aAAtB;;AAEA,MAAI,CAACpX,mBAAD,IAAwBiM,IAAI,CAACuD,sBAAL,KAAgC4H,aAA5D,EAA2E;AACzE;AACAnL,IAAAA,IAAI,CAACuD,sBAAL,GAA8BzL,MAA9B;AACAkI,IAAAA,IAAI,CAACqD,YAAL,GAAoB,IAApB;AACD;;AAED/C,EAAAA,qBAAqB,CAACN,IAAD,CAArB;AACAI,EAAAA,2BAA2B,CAACJ,IAAD,EAAOmL,aAAP,CAA3B;AACD;;AAED,SAASG,qBAAT,CACEC,aADF,EAEEC,SAFF,EAGE;AACA;AACA;AACA;AACA;AACA,MAAIA,SAAS,KAAK1T,MAAlB,EAA0B;AACxB,UAAM0H,cAAc,GAAG,IAAvB,CADwB,CACK;;AAC7B,UAAMF,WAAW,GAAGH,2BAA2B,EAA/C;AACAqM,IAAAA,SAAS,GAAGnM,yBAAyB,CACnCC,WADmC,EAEnCiM,aAFmC,EAGnC/L,cAHmC,CAArC;AAKD,GAbD,CAcA;;;AACA,QAAMQ,IAAI,GAAGC,6BAA6B,CAACsL,aAAD,EAAgBC,SAAhB,CAA1C;;AACA,MAAIxL,IAAI,KAAK,IAAb,EAAmB;AACjBM,IAAAA,qBAAqB,CAACN,IAAD,CAArB;AACAI,IAAAA,2BAA2B,CAACJ,IAAD,EAAOwL,SAAP,CAA3B;AACD;AACF;;AAED,OAAO,SAASC,+BAAT,CAAyCF,aAAzC,EAA+D;AACpE,QAAMG,aAAmC,GAAGH,aAAa,CAACI,aAA1D;AACA,MAAIH,SAAS,GAAG1T,MAAhB;;AACA,MAAI4T,aAAa,KAAK,IAAtB,EAA4B;AAC1BF,IAAAA,SAAS,GAAGE,aAAa,CAACF,SAA1B;AACD;;AACDF,EAAAA,qBAAqB,CAACC,aAAD,EAAgBC,SAAhB,CAArB;AACD;AAED,OAAO,SAASI,oBAAT,CAA8BL,aAA9B,EAAoDL,QAApD,EAAwE;AAC7E,MAAIM,SAAS,GAAG1T,MAAhB,CAD6E,CACrD;;AACxB,MAAI+T,UAAJ;;AACA,MAAIrY,4BAAJ,EAAkC;AAChC,YAAQ+X,aAAa,CAACvK,GAAtB;AACE,WAAKxK,iBAAL;AACEqV,QAAAA,UAAU,GAAGN,aAAa,CAACtK,SAA3B;AACA,cAAMyK,aAAmC,GAAGH,aAAa,CAACI,aAA1D;;AACA,YAAID,aAAa,KAAK,IAAtB,EAA4B;AAC1BF,UAAAA,SAAS,GAAGE,aAAa,CAACF,SAA1B;AACD;;AACD;;AACF,WAAK/U,qBAAL;AACEoV,QAAAA,UAAU,GAAGN,aAAa,CAACtK,SAA3B;AACA;;AACF;AACEhN,QAAAA,SAAS,CACP,KADO,EAEP,4CACE,kCAHK,CAAT;AAZJ;AAkBD,GAnBD,MAmBO;AACL4X,IAAAA,UAAU,GAAGN,aAAa,CAACtK,SAA3B;AACD;;AAED,MAAI4K,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACA;AACAA,IAAAA,UAAU,CAACR,MAAX,CAAkBH,QAAlB;AACD;;AAEDI,EAAAA,qBAAqB,CAACC,aAAD,EAAgBC,SAAhB,CAArB;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAShH,GAAT,CAAaD,WAAb,EAAkC;AAChC,SAAOA,WAAW,GAAG,GAAd,GACH,GADG,GAEHA,WAAW,GAAG,GAAd,GACA,GADA,GAEAA,WAAW,GAAG,IAAd,GACA,IADA,GAEAA,WAAW,GAAG,IAAd,GACA,IADA,GAEAA,WAAW,GAAG,IAAd,GACA,IADA,GAEAA,WAAW,GAAG,IAAd,GACA,IADA,GAEAtI,IAAI,CAACsI,WAAW,GAAG,IAAf,CAAJ,GAA2B,IAZ/B;AAaD;;AAED,SAASE,kCAAT,CACEqH,mBADF,EAEEzC,uBAFF,EAGE7J,cAHF,EAIE;AACA,QAAMuM,iBAAiB,GAAIvM,cAAc,CAACuM,iBAAhB,GAA0C,CAApE;;AACA,MAAIA,iBAAiB,IAAI,CAAzB,EAA4B;AAC1B,WAAO,CAAP;AACD;;AACD,QAAMC,WAAW,GAAIxM,cAAc,CAACwM,WAAhB,GAAoC,CAAxD,CALA,CAOA;;AACA,QAAM3H,aAAqB,GAAG7P,GAAG,EAAjC;AACA,QAAM2P,WAAmB,GAAGyC,6CAA6C,CACvEkF,mBADuE,EAEvEtM,cAFuE,CAAzE;AAIA,QAAM+E,WAAW,GAAGF,aAAa,GAAGF,WAApC;;AACA,MAAII,WAAW,IAAIyH,WAAnB,EAAgC;AAC9B;AACA;AACA,WAAO,CAAP;AACD;;AACD,QAAMjI,cAAc,GAAGiI,WAAW,GAAGD,iBAAd,GAAkCxH,WAAzD,CAnBA,CAoBA;;AACA,SAAOR,cAAP;AACD;;AAED,SAASjE,qBAAT,GAAiC;AAC/B;AACA,MAAIlB,iBAAiB,GAAGD,mBAAxB,EAA6C;AAC3CC,IAAAA,iBAAiB,GAAG,CAApB;AACAC,IAAAA,qBAAqB,GAAG,IAAxB;AACA5K,IAAAA,SAAS,CACP,KADO,EAEP,qEACE,0DADF,GAEE,mEAFF,GAGE,yBALK,CAAT;AAOD;;AAED,MAAI4P,OAAJ,EAAa;AACX,QAAI9E,wBAAwB,GAAGD,2BAA/B,EAA4D;AAC1DC,MAAAA,wBAAwB,GAAG,CAA3B;AACA+F,MAAAA,OAAO,CAACC,KAAR,CACE,qEACE,gEADF,GAEE,iEAFF,GAGE,eAJJ;AAMD;AACF;AACF;;AAED,SAASsD,uCAAT,GAAmD;AACjD,MAAIxE,OAAJ,EAAa;AACXvJ,IAAAA,uBAAuB,CAAC2R,yBAAxB;;AAEA,QAAI7Y,6BAAJ,EAAmC;AACjCkH,MAAAA,uBAAuB,CAAC4R,mCAAxB;AACD;AACF;AACF;;AAED,SAAS9I,yBAAT,GAAqC;AACnC,QAAM+I,eAAe,GAAG,IAAxB;AACA/Q,EAAAA,iBAAiB,CAAC4D,aAAD,EAAgBmN,eAAhB,CAAjB;AACAnN,EAAAA,aAAa,GAAG,IAAhB;AACD;;AAED,SAASmE,4BAAT,GAAwC;AACtC;AACA,QAAMgJ,eAAe,GAAG,KAAxB;AACA/Q,EAAAA,iBAAiB,CAAC4D,aAAD,EAAgBmN,eAAhB,CAAjB;AACAnN,EAAAA,aAAa,GAAG,IAAhB;AACD;;AAED,SAASmB,oBAAT,CACEiM,uBADF,EAEEzE,oBAFF,EAGE;AACA,MACEpU,mBAAmB,IACnB6J,kBAAkB,KAAK,IADvB,IAEAuK,oBAAoB,GAAGrK,oBAHzB,EAIE;AACA0B,IAAAA,aAAa,GAAGoN,uBAAhB;AACD;AACF;;AAED,IAAIC,uCAA2D,GAAG,IAAlE;;AACA,SAASnM,oCAAT,CAA8CX,KAA9C,EAAqD;AACnD,MAAIsE,OAAJ,EAAa;AACX,UAAM7C,GAAG,GAAGzB,KAAK,CAACyB,GAAlB;;AACA,QACEA,GAAG,KAAK1K,QAAR,IACA0K,GAAG,KAAKzK,cADR,IAEAyK,GAAG,KAAKtK,iBAFR,IAGAsK,GAAG,KAAKrK,UAHR,IAIAqK,GAAG,KAAKpK,aAJR,IAKAoK,GAAG,KAAKnK,mBALR,IAMAmK,GAAG,KAAKlK,KAPV,EAQE;AACA;AACA;AACD;;AAED,QACEzD,sCAAsC,IACtCC,wCAFF,EAGE;AACA;AACA;AACA,UAAImL,gCAAgC,CAAC6N,OAAjC,CAAyC/M,KAAzC,KAAmD,CAAvD,EAA0D;AACxD;AACD;AACF,KAxBU,CA0BX;AACA;;;AACA,UAAMgN,aAAa,GAAGlS,gBAAgB,CAACkF,KAAK,CAACuL,IAAP,CAAhB,IAAgC,gBAAtD;;AACA,QAAIuB,uCAAuC,KAAK,IAAhD,EAAsD;AACpD,UAAIA,uCAAuC,CAACnC,GAAxC,CAA4CqC,aAA5C,CAAJ,EAAgE;AAC9D;AACD;;AACDF,MAAAA,uCAAuC,CAAChC,GAAxC,CAA4CkC,aAA5C;AACD,KALD,MAKO;AACLF,MAAAA,uCAAuC,GAAG,IAAIjC,GAAJ,CAAQ,CAACmC,aAAD,CAAR,CAA1C;AACD;;AACDzH,IAAAA,OAAO,CAACC,KAAR,CACE,wEACE,qEADF,GAEE,+DAHJ,EAIE/D,GAAG,KAAKzK,cAAR,GACI,iCADJ,GAEI,8BANN,EAOEsE,2BAA2B,CAAC0E,KAAD,CAP7B;AASD;AACF;;AAED,IAAI7G,SAAJ;;AACA,IAAImL,OAAO,IAAIpQ,+CAAf,EAAgE;AAC9D,MAAI+Y,UAAU,GAAG,IAAjB;;AACA9T,EAAAA,SAAS,GAAG,CAAC4K,OAAD,EAAUwD,UAAV,EAAsBnH,cAAtB,KAAyC;AACnD;AACA;AACA;AAEA;AACA;AACA,UAAM8M,0BAA0B,GAAG9W,0BAA0B,CAC3D6W,UAD2D,EAE3D1F,UAF2D,CAA7D;;AAIA,QAAI;AACF,aAAOnO,iBAAiB,CAAC2K,OAAD,EAAUwD,UAAV,EAAsBnH,cAAtB,CAAxB;AACD,KAFD,CAEE,OAAO+M,aAAP,EAAsB;AACtB,UACEA,aAAa,KAAK,IAAlB,IACA,OAAOA,aAAP,KAAyB,QADzB,IAEA,OAAOA,aAAa,CAACC,IAArB,KAA8B,UAHhC,EAIE;AACA;AACA,cAAMD,aAAN;AACD,OARqB,CAUtB;AACA;;;AACA5S,MAAAA,wBAAwB;AACxBC,MAAAA,oBAAoB,GAbE,CActB;AACA;AAEA;;AACAjB,MAAAA,qBAAqB,CAACgO,UAAD,CAArB,CAlBsB,CAoBtB;;AACAnR,MAAAA,0BAA0B,CAACmR,UAAD,EAAa2F,0BAAb,CAA1B;;AAEA,UAAI/Y,mBAAmB,IAAIoT,UAAU,CAACrH,IAAX,GAAkBtJ,WAA7C,EAA0D;AACxD;AACAgE,QAAAA,kBAAkB,CAAC2M,UAAD,CAAlB;AACD,OA1BqB,CA4BtB;;;AACAjL,MAAAA,qBAAqB,CACnB,IADmB,EAEnBlD,iBAFmB,EAGnB,IAHmB,EAInB2K,OAJmB,EAKnBwD,UALmB,EAMnBnH,cANmB,CAArB;;AASA,UAAI7D,cAAc,EAAlB,EAAsB;AACpB,cAAM8Q,WAAW,GAAG7Q,gBAAgB,EAApC,CADoB,CAEpB;AACA;;AACA,cAAM6Q,WAAN;AACD,OALD,MAKO;AACL;AACA,cAAMF,aAAN;AACD;AACF;AACF,GA7DD;AA8DD,CAhED,MAgEO;AACLhU,EAAAA,SAAS,GAAGC,iBAAZ;AACD;;AAED,IAAIkU,0BAA0B,GAAG,KAAjC;AACA,IAAIC,6CAAJ;;AACA,IAAIjJ,OAAJ,EAAa;AACXiJ,EAAAA,6CAA6C,GAAG,IAAI1C,GAAJ,EAAhD;AACD;;AAED,SAASrK,gCAAT,CAA0CR,KAA1C,EAAiD;AAC/C,MAAIsE,OAAJ,EAAa;AACX,QACErJ,sCAAsC,IACtC,CAAC2C,gBAAgB,GAAGR,aAApB,MAAuCL,SAFzC,EAGE;AACA,cAAQiD,KAAK,CAACyB,GAAd;AACE,aAAKtK,iBAAL;AACA,aAAKC,UAAL;AACA,aAAKE,mBAAL;AAA0B;AACxB,kBAAMkW,sBAAsB,GACzB1P,cAAc,IAAIhD,gBAAgB,CAACgD,cAAc,CAACyN,IAAhB,CAAnC,IACA,SAFF,CADwB,CAIxB;;AACA,kBAAMkC,SAAS,GAAGD,sBAAlB;;AACA,gBAAI,CAACD,6CAA6C,CAAC5C,GAA9C,CAAkD8C,SAAlD,CAAL,EAAmE;AACjEF,cAAAA,6CAA6C,CAACzC,GAA9C,CAAkD2C,SAAlD;AACA,oBAAMC,qBAAqB,GACzB5S,gBAAgB,CAACkF,KAAK,CAACuL,IAAP,CAAhB,IAAgC,SADlC;AAEAhG,cAAAA,OAAO,CAACC,KAAR,CACE,wDACE,6EADF,GAEE,yEAHJ,EAIEkI,qBAJF,EAKEF,sBALF,EAMEA,sBANF;AAQD;;AACD;AACD;;AACD,aAAKxW,cAAL;AAAqB;AACnB,gBAAI,CAACsW,0BAAL,EAAiC;AAC/B/H,cAAAA,OAAO,CAACC,KAAR,CACE,gEACE,oDADF,GAEE,8BAHJ;AAKA8H,cAAAA,0BAA0B,GAAG,IAA7B;AACD;;AACD;AACD;AAlCH;AAoCD;AACF;AACF,C,CAED;;;AACA,OAAO,MAAM/I,oBAAoB,GAAG;AAACR,EAAAA,OAAO,EAAG;AAAX,CAA7B;AAEP,OAAO,SAAS4J,8BAAT,CAAwC3N,KAAxC,EAA4D;AACjE,MAAIsE,OAAJ,EAAa;AACX,QACEpO,gBAAgB,KAAK,IAArB,IACA4G,oBAAoB,CAACiH,OAArB,KAAiC,IADjC,IAEAQ,oBAAoB,CAACR,OAArB,KAAiC,IAHnC,EAIE;AACAwB,MAAAA,OAAO,CAACC,KAAR,CACE,gFACE,kFADF,GAEE,qBAFF,GAGE,6CAHF,GAIE,UAJF,GAKE,qBALF,GAME,+BANF,GAOE,mDAPF,GAQE,+BARF,GASE,UATF,GAUE,iBAVF,GAWE,IAZJ,EAaElK,2BAA2B,CAAC0E,KAAD,CAb7B;AAeD;AACF;AACF;AAED,OAAO,SAAS4N,oCAAT,CAA8C5N,KAA9C,EAAkE;AACvE,MAAIsE,OAAJ,EAAa;AACX,QACEpO,gBAAgB,KAAK,IAArB,IACA,CAAC8J,KAAK,CAACE,IAAN,GAAavJ,UAAd,MAA8BD,MAD9B,IAEAoG,oBAAoB,CAACiH,OAArB,KAAiC,KAFjC,IAGAQ,oBAAoB,CAACR,OAArB,KAAiC,KAJnC,EAKE;AACAwB,MAAAA,OAAO,CAACC,KAAR,CACE,wEACE,+DADF,GAEE,4BAFF,GAGE,eAHF,GAIE,yCAJF,GAKE,OALF,GAME,gCANF,GAOE,mEAPF,GAQE,iBARF,GASE,wDATF,GAUE,IAXJ,EAYE1K,gBAAgB,CAACkF,KAAK,CAACuL,IAAP,CAZlB,EAaEjQ,2BAA2B,CAAC0E,KAAD,CAb7B;AAeD;AACF;AACF;;AAED,SAAS6N,oCAAT,CAA8C7N,KAA9C,EAAkE;AAChE,MAAIsE,OAAJ,EAAa;AACX,QACEpO,gBAAgB,KAAK,IAArB,IACA0H,gBAAgB,KAAKb,SADrB,IAEAD,oBAAoB,CAACiH,OAArB,KAAiC,KAFjC,IAGAQ,oBAAoB,CAACR,OAArB,KAAiC,KAJnC,EAKE;AACAwB,MAAAA,OAAO,CAACC,KAAR,CACE,mEACE,+DADF,GAEE,4BAFF,GAGE,eAHF,GAIE,yCAJF,GAKE,OALF,GAME,gCANF,GAOE,mEAPF,GAQE,iBARF,GASE,wDATF,GAUE,IAXJ,EAYE1K,gBAAgB,CAACkF,KAAK,CAACuL,IAAP,CAZlB,EAaEjQ,2BAA2B,CAAC0E,KAAD,CAb7B;AAeD;AACF;AACF;;AAED,OAAO,MAAM8N,oCAAoC,GAAGD,oCAA7C,C,CAEP;;AACA,IAAIE,6BAA6B,GAAG,KAApC,C,CACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,uBAAT,CAAiChO,KAAjC,EAA+C;AACpD,MAAIsE,OAAJ,EAAa;AACX,QACEyJ,6BAA6B,KAAK,KAAlC,IACArY,SAAS,CAACuY,iCAAV,KAAgD9M,SAFlD,EAGE;AACA,UAAInB,KAAK,CAACE,IAAN,GAAarJ,YAAb,IAA6BmJ,KAAK,CAACE,IAAN,GAAapJ,cAA9C,EAA8D;AAC5DiX,QAAAA,6BAA6B,GAAG,IAAhC;AACAxI,QAAAA,OAAO,CAACC,KAAR,CACE,4EACE,+DADF,GAEE,4BAFF,GAGE,uEAHF,GAIE,yDALJ;AAOD,OATD,MASO,IAAInR,0BAA0B,KAAK,IAAnC,EAAyC;AAC9C0Z,QAAAA,6BAA6B,GAAG,IAAhC;AACAxI,QAAAA,OAAO,CAACC,KAAR,CACE,4EACE,+DADF,GAEE,4BAFF,GAGE,uEAHF,GAIE,yDALJ;AAOD;AACF;AACF;AACF;;AAED,SAAS0I,eAAT,CAAyBzN,IAAzB,EAA+BL,cAA/B,EAA+C;AAC7C;AACA,SAAOA,cAAc,GAAG,IAAjB,GAAwBK,IAAI,CAAC0N,mBAApC;AACD;;AAED,OAAO,SAASC,eAAT,CAAyBhO,cAAzB,EAAyD;AAC9D,MAAI,CAAChM,sBAAL,EAA6B;AAC3B;AACD;;AACD,MAAIsL,uBAAuB,KAAK,IAAhC,EAAsC;AACpCA,IAAAA,uBAAuB,GAAG,CAACU,cAAD,CAA1B;AACD,GAFD,MAEO;AACLV,IAAAA,uBAAuB,CAACwK,IAAxB,CAA6B9J,cAA7B;AACD;AACF;;AAED,SAASuJ,oBAAT,CAA8BlJ,IAA9B,EAAoCL,cAApC,EAAoDiO,YAApD,EAAkE;AAChE,MAAI,CAACja,sBAAL,EAA6B;AAC3B;AACD;;AACD,MAAIia,YAAY,CAACC,IAAb,GAAoB,CAAxB,EAA2B;AACzB,UAAMC,qBAAqB,GAAG9N,IAAI,CAAC8N,qBAAnC;AACA,UAAMC,mBAAmB,GAAGD,qBAAqB,CAACrN,GAAtB,CAA0Bd,cAA1B,CAA5B;;AACA,QAAIoO,mBAAmB,IAAI,IAA3B,EAAiC;AAC/BH,MAAAA,YAAY,CAACpI,OAAb,CAAsBwI,WAAD,IAAiB;AACpC,YAAI,CAACD,mBAAmB,CAAC7D,GAApB,CAAwB8D,WAAxB,CAAL,EAA2C;AACzC;AACAA,UAAAA,WAAW,CAACC,OAAZ;AACD;;AAEDF,QAAAA,mBAAmB,CAAC1D,GAApB,CAAwB2D,WAAxB;AACD,OAPD;AAQD,KATD,MASO;AACLF,MAAAA,qBAAqB,CAACnN,GAAtB,CAA0BhB,cAA1B,EAA0C,IAAIyK,GAAJ,CAAQwD,YAAR,CAA1C,EADK,CAGL;;AACAA,MAAAA,YAAY,CAACpI,OAAb,CAAsBwI,WAAD,IAAiB;AACpCA,QAAAA,WAAW,CAACC,OAAZ;AACD,OAFD;AAGD;;AAED,UAAMC,UAAU,GAAG/Y,eAAe,CAACmO,OAAnC;;AACA,QAAI4K,UAAU,KAAK,IAAnB,EAAyB;AACvB,YAAMC,QAAQ,GAAGV,eAAe,CAACzN,IAAD,EAAOL,cAAP,CAAhC;AACAuO,MAAAA,UAAU,CAACE,eAAX,CAA2BR,YAA3B,EAAyCO,QAAzC;AACD;AACF;AACF;;AAED,SAAS/N,2BAAT,CAAqCJ,IAArC,EAA2CL,cAA3C,EAA2D;AACzD;AACA;AACA;AACA,MAAI,CAAChM,sBAAL,EAA6B;AAC3B;AACD;;AACDuV,EAAAA,oBAAoB,CAAClJ,IAAD,EAAOL,cAAP,EAAuBzK,iBAAiB,CAACoO,OAAzC,CAApB;AACD;;AAED,SAASf,8BAAT,CAAwCvC,IAAxC,EAA8CL,cAA9C,EAA8D;AAC5D;AACA,MAAI,CAAChM,sBAAL,EAA6B;AAC3B;AACD,GAJ2D,CAM5D;AACA;AACA;;;AACA,QAAMia,YAA8B,GAAG,IAAIxD,GAAJ,EAAvC;AACApK,EAAAA,IAAI,CAAC8N,qBAAL,CAA2BtI,OAA3B,CACE,CAAC6I,qBAAD,EAAwBC,uBAAxB,KAAoD;AAClD,QAAIA,uBAAuB,IAAI3O,cAA/B,EAA+C;AAC7C0O,MAAAA,qBAAqB,CAAC7I,OAAtB,CAA+BwI,WAAD,IAC5BJ,YAAY,CAACvD,GAAb,CAAiB2D,WAAjB,CADF;AAGD;AACF,GAPH,EAV4D,CAoB5D;AACA;AACA;AACA;AACA;;AACAhO,EAAAA,IAAI,CAACoG,oBAAL,GAA4BwH,YAA5B;;AAEA,MAAIA,YAAY,CAACC,IAAb,GAAoB,CAAxB,EAA2B;AACzB,UAAMK,UAAU,GAAG/Y,eAAe,CAACmO,OAAnC;;AACA,QAAI4K,UAAU,KAAK,IAAnB,EAAyB;AACvB,YAAMC,QAAQ,GAAGV,eAAe,CAACzN,IAAD,EAAOL,cAAP,CAAhC;;AACA,UAAI;AACFuO,QAAAA,UAAU,CAACK,aAAX,CAAyBX,YAAzB,EAAuCO,QAAvC;AACD,OAFD,CAEE,OAAOpJ,KAAP,EAAc;AACd;AACA7Q,QAAAA,gBAAgB,CAACQ,iBAAD,EAAoB,MAAM;AACxC,gBAAMqQ,KAAN;AACD,SAFe,CAAhB;AAGD;AACF;AACF;AACF;;AAED,SAASoE,yBAAT,CAAmCnJ,IAAnC,EAAyCqJ,uBAAzC,EAAkE;AAChE,MAAI,CAAC1V,sBAAL,EAA6B;AAC3B;AACD;;AAED,QAAM6a,gCAAgC,GAAGxO,IAAI,CAACsB,gBAA9C;AAEA,MAAI4M,UAAJ;;AAEA,MAAI;AACFA,IAAAA,UAAU,GAAG/Y,eAAe,CAACmO,OAA7B;;AACA,QAAI4K,UAAU,KAAK,IAAf,IAAuBlO,IAAI,CAACoG,oBAAL,CAA0ByH,IAA1B,GAAiC,CAA5D,EAA+D;AAC7D,YAAMM,QAAQ,GAAGV,eAAe,CAACzN,IAAD,EAAOqJ,uBAAP,CAAhC;AACA6E,MAAAA,UAAU,CAACO,aAAX,CAAyBzO,IAAI,CAACoG,oBAA9B,EAAoD+H,QAApD;AACD;AACF,GAND,CAME,OAAOpJ,KAAP,EAAc;AACd;AACA7Q,IAAAA,gBAAgB,CAACQ,iBAAD,EAAoB,MAAM;AACxC,YAAMqQ,KAAN;AACD,KAFe,CAAhB;AAGD,GAXD,SAWU;AACR;AACA;AACA;AACA,UAAM+I,qBAAqB,GAAG9N,IAAI,CAAC8N,qBAAnC;AACAA,IAAAA,qBAAqB,CAACtI,OAAtB,CACE,CAAC6I,qBAAD,EAAwBC,uBAAxB,KAAoD;AAClD;AACA;AACA;AACA,UAAIA,uBAAuB,GAAGE,gCAA9B,EAAgE;AAC9DV,QAAAA,qBAAqB,CAACzC,MAAtB,CAA6BiD,uBAA7B;AAEAD,QAAAA,qBAAqB,CAAC7I,OAAtB,CAA+BwI,WAAD,IAAiB;AAC7CA,UAAAA,WAAW,CAACC,OAAZ;;AAEA,cAAIC,UAAU,KAAK,IAAf,IAAuBF,WAAW,CAACC,OAAZ,KAAwB,CAAnD,EAAsD;AACpD,gBAAI;AACFC,cAAAA,UAAU,CAACQ,mCAAX,CAA+CV,WAA/C;AACD,aAFD,CAEE,OAAOjJ,KAAP,EAAc;AACd;AACA7Q,cAAAA,gBAAgB,CAACQ,iBAAD,EAAoB,MAAM;AACxC,sBAAMqQ,KAAN;AACD,eAFe,CAAhB;AAGD;AACF;AACF,SAbD;AAcD;AACF,KAvBH;AAyBD;AACF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\nimport type {Interaction} from 'scheduler/src/Tracing';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {Effect as HookEffect} from './ReactFiberHooks';\n\nimport {\n  warnAboutDeprecatedLifecycles,\n  deferPassiveEffectCleanupDuringUnmount,\n  runAllPassiveEffectDestroysBeforeCreates,\n  enableUserTimingAPI,\n  enableSuspenseServerRenderer,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  enableProfilerTimer,\n  enableSchedulerTracing,\n  warnAboutUnmockedScheduler,\n  flushSuspenseFallbacksInTests,\n  disableSchedulerTimeoutBasedOnReactExpirationTime,\n  enableTrainModelFix,\n} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport invariant from 'shared/invariant';\n\nimport {\n  scheduleCallback,\n  cancelCallback,\n  getCurrentPriorityLevel,\n  runWithPriority,\n  shouldYield,\n  requestPaint,\n  now,\n  NoPriority,\n  ImmediatePriority,\n  UserBlockingPriority,\n  NormalPriority,\n  LowPriority,\n  IdlePriority,\n  flushSyncCallbackQueue,\n  scheduleSyncCallback,\n} from './SchedulerWithReactIntegration';\n\n// The scheduler is imported here *only* to detect whether it's been mocked\nimport * as Scheduler from 'scheduler';\n\nimport {__interactionsRef, __subscriberRef} from 'scheduler/tracing';\n\nimport {\n  prepareForCommit,\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n  warnsIfNotActing,\n} from './ReactFiberHostConfig';\n\nimport {createWorkInProgress, assignFiberPropertiesInDEV} from './ReactFiber';\nimport {\n  isRootSuspendedAtTime,\n  markRootSuspendedAtTime,\n  markRootFinishedAtTime,\n  markRootUpdatedAtTime,\n  markRootExpiredAtTime,\n} from './ReactFiberRoot';\nimport {\n  NoMode,\n  StrictMode,\n  ProfileMode,\n  BlockingMode,\n  ConcurrentMode,\n} from './ReactTypeOfMode';\nimport {\n  HostRoot,\n  ClassComponent,\n  SuspenseComponent,\n  SuspenseListComponent,\n  FunctionComponent,\n  ForwardRef,\n  MemoComponent,\n  SimpleMemoComponent,\n  Block,\n} from 'shared/ReactWorkTags';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Update,\n  PlacementAndUpdate,\n  Deletion,\n  Ref,\n  ContentReset,\n  Snapshot,\n  Callback,\n  Passive,\n  Incomplete,\n  HostEffectMask,\n  Hydrating,\n  HydratingAndUpdate,\n} from 'shared/ReactSideEffectTags';\nimport {\n  NoWork,\n  Sync,\n  Never,\n  msToExpirationTime,\n  expirationTimeToMs,\n  computeInteractiveExpiration,\n  computeAsyncExpiration,\n  computeSuspenseExpiration,\n  inferPriorityFromExpirationTime,\n  LOW_PRIORITY_EXPIRATION,\n  Batched,\n  Idle,\n} from './ReactFiberExpirationTime';\nimport {beginWork as originalBeginWork} from './ReactFiberBeginWork';\nimport {completeWork} from './ReactFiberCompleteWork';\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork';\nimport {\n  throwException,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberThrow';\nimport {\n  commitBeforeMutationLifeCycles as commitBeforeMutationEffectOnFiber,\n  commitLifeCycles as commitLayoutEffectOnFiber,\n  commitPassiveHookEffects,\n  commitPlacement,\n  commitWork,\n  commitDeletion,\n  commitDetachRef,\n  commitAttachRef,\n  commitResetTextContent,\n} from './ReactFiberCommitWork';\nimport {enqueueUpdate} from './ReactUpdateQueue';\nimport {resetContextDependencies} from './ReactFiberNewContext';\nimport {resetHooksAfterThrow, ContextOnlyDispatcher} from './ReactFiberHooks';\nimport {createCapturedValue} from './ReactCapturedValue';\n\nimport {\n  recordCommitTime,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n} from './ReactProfilerTimer';\n\n// DEV stuff\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n  getStackByFiberInDevAndProd,\n} from './ReactCurrentFiber';\nimport {\n  recordEffect,\n  recordScheduleUpdate,\n  startWorkTimer,\n  stopWorkTimer,\n  stopFailedWorkTimer,\n  startWorkLoopTimer,\n  stopWorkLoopTimer,\n  startCommitTimer,\n  stopCommitTimer,\n  startCommitSnapshotEffectsTimer,\n  stopCommitSnapshotEffectsTimer,\n  startCommitHostEffectsTimer,\n  stopCommitHostEffectsTimer,\n  startCommitLifeCyclesTimer,\n  stopCommitLifeCyclesTimer,\n} from './ReactDebugFiberPerf';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {onCommitRoot} from './ReactFiberDevToolsHook';\n\nconst ceil = Math.ceil;\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentOwner,\n  IsSomeRendererActing,\n} = ReactSharedInternals;\n\ntype ExecutionContext = number;\n\nconst NoContext = /*                    */ 0b000000;\nconst BatchedContext = /*               */ 0b000001;\nconst EventContext = /*                 */ 0b000010;\nconst DiscreteEventContext = /*         */ 0b000100;\nconst LegacyUnbatchedContext = /*       */ 0b001000;\nconst RenderContext = /*                */ 0b010000;\nconst CommitContext = /*                */ 0b100000;\n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst RootIncomplete = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\n\nexport type Thenable = {\n  then(resolve: () => mixed, reject?: () => mixed): Thenable | void,\n  // Special flag to opt out of tracing interactions across a Suspense boundary.\n  __reactDoNotTraceInteractions?: boolean,\n  ...\n};\n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n// The root we're working on\nlet workInProgressRoot: FiberRoot | null = null;\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n// The expiration time we're rendering\nlet renderExpirationTime: ExpirationTime = NoWork;\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\n// A fatal error, if one is thrown\nlet workInProgressRootFatalError: mixed = null;\n// Most recent event time among processed updates during this render.\n// This is conceptually a time stamp but expressed in terms of an ExpirationTime\n// because we deal mostly with expiration times in the hot path, so this avoids\n// the conversion happening in the hot path.\nlet workInProgressRootLatestProcessedExpirationTime: ExpirationTime = Sync;\nlet workInProgressRootLatestSuspenseTimeout: ExpirationTime = Sync;\nlet workInProgressRootCanSuspendUsingConfig: null | SuspenseConfig = null;\n// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nlet workInProgressRootNextUnprocessedUpdateTime: ExpirationTime = NoWork;\n\n// If we're pinged while rendering we don't always restart immediately.\n// This flag determines if it might be worthwhile to restart if an opportunity\n// happens latere.\nlet workInProgressRootHasPendingPing: boolean = false;\n// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nlet globalMostRecentFallbackTime: number = 0;\nconst FALLBACK_THROTTLE_MS: number = 500;\n\nlet nextEffect: Fiber | null = null;\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\nlet rootDoesHavePassiveEffects: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoPriority;\nlet pendingPassiveEffectsExpirationTime: ExpirationTime = NoWork;\nlet pendingPassiveHookEffectsMount: Array<HookEffect | Fiber> = [];\nlet pendingPassiveHookEffectsUnmount: Array<HookEffect | Fiber> = [];\n\nlet rootsWithPendingDiscreteUpdates: Map<\n  FiberRoot,\n  ExpirationTime,\n> | null = null;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount: number = 0;\n\nlet interruptedBy: Fiber | null = null;\n\n// Marks the need to reschedule pending interactions at these expiration times\n// during the commit phase. This enables them to be traced across components\n// that spawn new work during render. E.g. hidden boundaries, suspended SSR\n// hydration or SuspenseList.\nlet spawnedWorkDuringRender: null | Array<ExpirationTime> = null;\n\n// Expiration times are computed by adding to the current time (the start\n// time). However, if two updates are scheduled within the same event, we\n// should treat their start times as simultaneous, even if the actual clock\n// time has advanced between the first and second call.\n\n// In other words, because expiration times determine how updates are batched,\n// we want all updates of like priority that occur within the same event to\n// receive the same expiration time. Otherwise we get tearing.\nlet currentEventTime: ExpirationTime = NoWork;\n\nexport function requestCurrentTimeForUpdate() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return msToExpirationTime(now());\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoWork) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = msToExpirationTime(now());\n  return currentEventTime;\n}\n\nexport function getCurrentTime() {\n  return msToExpirationTime(now());\n}\n\nexport function computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BlockingMode) === NoMode) {\n    return Sync;\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime;\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\n/**\n * 判断任务是否为同步 调用同步任务入口\n */\nexport function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  /**\n   * fiber: 初始化渲染时为 rootFiber, 即 <div id=\"root\"></div> 对应的 Fiber 对象\n   * expirationTime: 任务过期时间 => 1073741823\n   */\n  /**\n   * 判断是否是无限循环的 update 如果是就报错\n   * 在 componentWillUpdate 或者 componentDidUpdate 生命周期函数中重复调用\n   * setState 方法时, 可能会发生这种情况, React 限制了嵌套更新的数量以防止无限循环\n   * 限制的嵌套更新数量为 50, 可通过 NESTED_UPDATE_LIMIT 全局变量获取\n   */\n  checkForNestedUpdates();\n  // 开发环境下执行的代码 忽略\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\n  // 遍历更新子节点的过期时间 返回 FiberRoot\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n  if (root === null) {\n    // 开发环境下执行 忽略\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n  // 判断是否有高优先级任务打断当前正在执行的任务\n  // 内部判断条件不成立 内部代码没有得到执行\n  checkForInterruption(fiber, expirationTime);\n\n  // 报告调度更新, 测试环境执行, 忽略\n  recordScheduleUpdate();\n\n  // 获取当前调度任务的优先级 数值类型 从90开始 数值越大 优先级越高\n  // 97 普通优先级任务\n  const priorityLevel = getCurrentPriorityLevel();\n  // 判断任务是否是同步任务 Sync的值为: 1073741823\n  if (expirationTime === Sync) {\n    if (\n      // 检查是否处于非批量更新模式\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\n      // 检查是否没有处于正在进行渲染的任务\n      (executionContext & (RenderContext | CommitContext)) === NoContext\n    ) {\n      // 在根上注册待处理的交互, 以避免丢失跟踪的交互数据\n      // 初始渲染时内部条件判断不成立, 内部代码没有得到执行\n      schedulePendingInteractions(root, expirationTime);\n      // 同步任务入口点\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of legacy mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  }\n  // 初始渲染不执行\n  if (\n    (executionContext & DiscreteEventContext) !== NoContext &&\n    // Only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (priorityLevel === UserBlockingPriority ||\n      priorityLevel === ImmediatePriority)\n  ) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\nexport const scheduleWork = scheduleUpdateOnFiber;\n\n// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  let node = fiber.return;\n  let root = null;\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    while (node !== null) {\n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    }\n    // Mark that the root has a pending update.\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\nfunction getNextRootExpirationTimeToWorkOn(root: FiberRoot): ExpirationTime {\n  // Determines the next expiration time that the root should render, taking\n  // into account levels that may be suspended, or levels that may have\n  // received a ping.\n\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime !== NoWork) {\n    return lastExpiredTime;\n  }\n\n  // \"Pending\" refers to any update that hasn't committed yet, including if it\n  // suspended. The \"suspended\" range is therefore a subset.\n  const firstPendingTime = root.firstPendingTime;\n  if (!isRootSuspendedAtTime(root, firstPendingTime)) {\n    // The highest priority pending time is not suspended. Let's work on that.\n    return firstPendingTime;\n  }\n\n  // If the first pending time is suspended, check if there's a lower priority\n  // pending level that we know about. Or check if we received a ping. Work\n  // on whichever is higher priority.\n  const lastPingedTime = root.lastPingedTime;\n  const nextKnownPendingLevel = root.nextKnownPendingLevel;\n  const nextLevel =\n    lastPingedTime > nextKnownPendingLevel\n      ? lastPingedTime\n      : nextKnownPendingLevel;\n  if (\n    enableTrainModelFix &&\n    nextLevel <= Idle &&\n    firstPendingTime !== nextLevel\n  ) {\n    // Don't work on Idle/Never priority unless everything else is committed.\n    return NoWork;\n  }\n  return nextLevel;\n}\n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\nfunction ensureRootIsScheduled(root: FiberRoot) {\n  const lastExpiredTime = root.lastExpiredTime;\n  if (lastExpiredTime !== NoWork) {\n    // Special case: Expired work should flush synchronously.\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(\n      performSyncWorkOnRoot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n    return;\n  }\n\n  // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n  const currentTime = requestCurrentTimeForUpdate();\n  const priorityLevel = inferPriorityFromExpirationTime(\n    currentTime,\n    expirationTime,\n  );\n\n  // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n    if (\n      // Callback must have the exact same expiration time.\n      existingCallbackExpirationTime === expirationTime &&\n      // Callback must have greater or equal priority.\n      existingCallbackPriority >= priorityLevel\n    ) {\n      // Existing callback is sufficient.\n      return;\n    }\n    // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n\n  let callbackNode;\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  } else {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n      // Compute a task timeout based on the expiration time. This also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationTimeToMs(expirationTime) - now()},\n    );\n  }\n\n  root.callbackNode = callbackNode;\n}\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTimeForUpdate();\n    markRootExpiredAtTime(root, currentTime);\n    // This will schedule a synchronous callback.\n    ensureRootIsScheduled(root);\n    return null;\n  }\n\n  // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n    invariant(\n      (executionContext & (RenderContext | CommitContext)) === NoContext,\n      'Should not already be working.',\n    );\n\n    flushPassiveEffects();\n\n    // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n    if (\n      root !== workInProgressRoot ||\n      expirationTime !== renderExpirationTime\n    ) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    }\n\n    // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n      do {\n        try {\n          workLoopConcurrent();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n      if (enableSchedulerTracing) {\n        popInteractions(((prevInteractions: any): Set<Interaction>));\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n\n        const finishedWork: Fiber = ((root.finishedWork =\n          root.current.alternate): any);\n        root.finishedExpirationTime = expirationTime;\n        finishConcurrentRender(\n          root,\n          finishedWork,\n          workInProgressRootExitStatus,\n          expirationTime,\n        );\n      }\n\n      ensureRootIsScheduled(root);\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    }\n  }\n  return null;\n}\n\nfunction finishConcurrentRender(\n  root,\n  finishedWork,\n  exitStatus,\n  expirationTime,\n) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored: {\n      invariant(false, 'Root did not complete. This is a bug in React.');\n    }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n    case RootErrored: {\n      // If this was an async render, the error may have happened due to\n      // a mutation in a concurrent event. Try rendering one more time,\n      // synchronously, to see if the error goes away. If there are\n      // lower priority updates, let's include those, too, in case they\n      // fix the inconsistency. Render at Idle to include all updates.\n      // If it was Idle or Never or some not-yet-invented time, render\n      // at that time.\n      markRootExpiredAtTime(\n        root,\n        expirationTime > Idle ? Idle : expirationTime,\n      );\n      // We assume that this second render pass will be synchronous\n      // and therefore not hit this path again.\n      break;\n    }\n    case RootSuspended: {\n      markRootSuspendedAtTime(root, expirationTime);\n      const lastSuspendedTime = root.lastSuspendedTime;\n      if (expirationTime === lastSuspendedTime) {\n        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n      }\n\n      // We have an acceptable loading state. We need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      // If we have processed new updates during this render, we may now\n      // have a new loading state ready. We want to ensure that we commit\n      // that as soon as possible.\n      const hasNotProcessedNewUpdates =\n        workInProgressRootLatestProcessedExpirationTime === Sync;\n      if (\n        hasNotProcessedNewUpdates &&\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        )\n      ) {\n        // If we have not processed any new updates during this pass, then\n        // this is either a retry of an existing fallback state or a\n        // hidden tree. Hidden trees shouldn't be batched with other work\n        // and after that's fixed it can only be a retry. We're going to\n        // throttle committing retries so that we don't show too many\n        // loading states too quickly.\n        let msUntilTimeout =\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          if (workInProgressRootHasPendingPing) {\n            const lastPingedTime = root.lastPingedTime;\n            if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n              // This render was pinged but we didn't get to restart\n              // earlier so try restarting now instead.\n              root.lastPingedTime = expirationTime;\n              prepareFreshStack(root, expirationTime);\n              break;\n            }\n          }\n\n          const nextTime = getNextRootExpirationTimeToWorkOn(root);\n          if (nextTime !== NoWork && nextTime !== expirationTime) {\n            // There's additional work on this root.\n            break;\n          }\n          if (\n            lastSuspendedTime !== NoWork &&\n            lastSuspendedTime !== expirationTime\n          ) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            root.lastPingedTime = lastSuspendedTime;\n            break;\n          }\n\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      markRootSuspendedAtTime(root, expirationTime);\n      const lastSuspendedTime = root.lastSuspendedTime;\n      if (expirationTime === lastSuspendedTime) {\n        root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n      }\n\n      if (\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        )\n      ) {\n        // We're suspended in a state that should be avoided. We'll try to\n        // avoid committing it for as long as the timeouts let us.\n        if (workInProgressRootHasPendingPing) {\n          const lastPingedTime = root.lastPingedTime;\n          if (lastPingedTime === NoWork || lastPingedTime >= expirationTime) {\n            // This render was pinged but we didn't get to restart earlier\n            // so try restarting now instead.\n            root.lastPingedTime = expirationTime;\n            prepareFreshStack(root, expirationTime);\n            break;\n          }\n        }\n\n        const nextTime = getNextRootExpirationTimeToWorkOn(root);\n        if (nextTime !== NoWork && nextTime !== expirationTime) {\n          // There's additional work on this root.\n          break;\n        }\n        if (\n          lastSuspendedTime !== NoWork &&\n          lastSuspendedTime !== expirationTime\n        ) {\n          // We should prefer to render the fallback of at the last\n          // suspended level. Ping the last suspended level to try\n          // rendering it again.\n          root.lastPingedTime = lastSuspendedTime;\n          break;\n        }\n\n        let msUntilTimeout;\n        if (workInProgressRootLatestSuspenseTimeout !== Sync) {\n          // We have processed a suspense config whose expiration time we\n          // can use as the timeout.\n          msUntilTimeout =\n            expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();\n        } else if (workInProgressRootLatestProcessedExpirationTime === Sync) {\n          // This should never normally happen because only new updates\n          // cause delayed states, so we should have processed something.\n          // However, this could also happen in an offscreen tree.\n          msUntilTimeout = 0;\n        } else {\n          // If we don't have a suspense config, we're going to use a\n          // heuristic to determine how long we can suspend.\n          const eventTimeMs: number = inferTimeFromExpirationTime(\n            workInProgressRootLatestProcessedExpirationTime,\n          );\n          const currentTimeMs = now();\n          const timeUntilExpirationMs =\n            expirationTimeToMs(expirationTime) - currentTimeMs;\n          let timeElapsed = currentTimeMs - eventTimeMs;\n          if (timeElapsed < 0) {\n            // We get this wrong some time since we estimate the time.\n            timeElapsed = 0;\n          }\n\n          msUntilTimeout = jnd(timeElapsed) - timeElapsed;\n\n          // Clamp the timeout to the expiration time. TODO: Once the\n          // event time is exact instead of inferred from expiration time\n          // we don't need this.\n          if (timeUntilExpirationMs < msUntilTimeout) {\n            msUntilTimeout = timeUntilExpirationMs;\n          }\n        }\n\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      if (\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        ) &&\n        workInProgressRootLatestProcessedExpirationTime !== Sync &&\n        workInProgressRootCanSuspendUsingConfig !== null\n      ) {\n        // If we have exceeded the minimum loading delay, which probably\n        // means we have shown a spinner already, we might have to suspend\n        // a bit longer to ensure that the spinner is shown for\n        // enough time.\n        const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(\n          workInProgressRootLatestProcessedExpirationTime,\n          expirationTime,\n          workInProgressRootCanSuspendUsingConfig,\n        );\n        if (msUntilTimeout > 10) {\n          markRootSuspendedAtTime(root, expirationTime);\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      commitRoot(root);\n      break;\n    }\n    default: {\n      invariant(false, 'Unknown root exit status.');\n    }\n  }\n}\n\n// 进入 render 阶段, 构建 workInProgress Fiber 树\nfunction performSyncWorkOnRoot(root) {\n  // 参数 root 为 fiberRoot 对象\n\n  // 检查是否有过期的任务\n  // 如果没有过期的任务 值为 0\n  // 初始化渲染没有过期的任务待执行\n  const lastExpiredTime = root.lastExpiredTime;\n  // NoWork 值为 0\n  // 如果有过期的任务 将过期时间设置为 lastExpiredTime 否则将过期时间设置为 Sync\n  // 初始渲染过期时间被设置成了 Sync\n  const expirationTime = lastExpiredTime !== NoWork ? lastExpiredTime : Sync;\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Should not already be working.',\n  );\n\n  // 处理 useEffect\n  flushPassiveEffects();\n\n  // 如果 root 和 workInProgressRoot 不相等\n  // 说明 workInProgressRoot 不存在, 说明还没有构建 workInProgress Fiber 树\n  // workInProgressRoot 为全局变量 默认值为 null, 初始渲染时值为 null\n  // expirationTime => 1073741823\n  // renderExpirationTime => 0\n  // true\n  if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n    // 构建 workInProgressFiber 树及 rootFiber\n    prepareFreshStack(root, expirationTime);\n    // 初始渲染不执行 内部条件判断不成立\n    startWorkOnPendingInteractions(root, expirationTime);\n  }\n  // workInProgress 如果不为 null\n  if (workInProgress !== null) {\n    const prevExecutionContext = executionContext;\n    executionContext |= RenderContext;\n    const prevDispatcher = pushDispatcher(root);\n    const prevInteractions = pushInteractions(root);\n    startWorkLoopTimer(workInProgress);\n    do {\n      try {\n        // 以同步的方式开始构建 Fiber 对象\n        workLoopSync();\n        break;\n      } catch (thrownValue) {\n        handleError(root, thrownValue);\n      }\n    } while (true);\n\n    resetContextDependencies();\n    executionContext = prevExecutionContext;\n    popDispatcher(prevDispatcher);\n    if (enableSchedulerTracing) {\n      popInteractions(((prevInteractions: any): Set<Interaction>));\n    }\n    // 初始渲染 不执行\n    if (workInProgressRootExitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      stopInterruptedWorkLoopTimer();\n      prepareFreshStack(root, expirationTime);\n      markRootSuspendedAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n      throw fatalError;\n    }\n\n    if (workInProgress !== null) {\n      // 这是一个同步渲染, 所以我们应该完成整棵树\n      // 无法提交不完整的 root, 此错误可能是由于React中的错误所致. 请提出问题.\n      invariant(\n        false,\n        'Cannot commit an incomplete root. This error is likely caused by a ' +\n          'bug in React. Please file an issue.',\n      );\n    } else {\n      // We now have a consistent tree. Because this is a sync render, we\n      // will commit it even if something suspended.\n      stopFinishedWorkLoopTimer();\n      // 将构建好的新 Fiber 对象存储在 finishedWork 属性中\n      // 提交阶段使用\n      root.finishedWork = (root.current.alternate: any);\n      root.finishedExpirationTime = expirationTime;\n      // 结束 render 阶段\n      // 进入 commit 阶段\n      finishSyncRender(root);\n    }\n\n    // Before exiting, make sure there's a callback scheduled for the next\n    // pending level.\n    ensureRootIsScheduled(root);\n  }\n\n  return null;\n}\n\nfunction finishSyncRender(root) {\n  // 销毁 workInProgress Fiber 树\n  // 因为待提交 Fiber 对象已经被存储在了 root.finishedWork 中\n  workInProgressRoot = null;\n  // 进入 commit 阶段\n  commitRoot(root);\n}\n\nexport function flushRoot(root: FiberRoot, expirationTime: ExpirationTime) {\n  markRootExpiredAtTime(root, expirationTime);\n  ensureRootIsScheduled(root);\n  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function flushDiscreteUpdates() {\n  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.\n  // However, `act` uses `batchedUpdates`, so there's no way to distinguish\n  // those two cases. Need to fix this before exposing flushDiscreteUpdates\n  // as a public API.\n  if (\n    (executionContext & (BatchedContext | RenderContext | CommitContext)) !==\n    NoContext\n  ) {\n    if (__DEV__) {\n      if ((executionContext & RenderContext) !== NoContext) {\n        console.error(\n          'unstable_flushDiscreteUpdates: Cannot flush updates when React is ' +\n            'already rendering.',\n        );\n      }\n    }\n    // We're already rendering, so we can't synchronously flush pending work.\n    // This is probably a nested event dispatch triggered by a lifecycle/effect,\n    // like `el.focus()`. Exit.\n    return;\n  }\n  flushPendingDiscreteUpdates();\n  // If the discrete updates scheduled passive effects, flush them now so that\n  // they fire before the next serial event.\n  flushPassiveEffects();\n}\n\nexport function deferredUpdates<A>(fn: () => A): A {\n  // TODO: Remove in favor of Scheduler.next\n  return runWithPriority(NormalPriority, fn);\n}\n\nexport function syncUpdates<A, B, C, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n): R {\n  return runWithPriority(ImmediatePriority, fn.bind(null, a, b, c));\n}\n\nfunction flushPendingDiscreteUpdates() {\n  if (rootsWithPendingDiscreteUpdates !== null) {\n    // For each root with pending discrete updates, schedule a callback to\n    // immediately flush them.\n    const roots = rootsWithPendingDiscreteUpdates;\n    rootsWithPendingDiscreteUpdates = null;\n    roots.forEach((expirationTime, root) => {\n      markRootExpiredAtTime(root, expirationTime);\n      ensureRootIsScheduled(root);\n    });\n    // Now flush the immediate queue.\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function batchedUpdates<A, R>(fn: (A) => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function batchedEventUpdates<A, R>(fn: (A) => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= EventContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function discreteUpdates<A, B, C, D, R>(\n  fn: (A, B, C) => R,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= DiscreteEventContext;\n  try {\n    // Should this\n    return runWithPriority(UserBlockingPriority, fn.bind(null, a, b, c, d));\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext &= ~BatchedContext;\n  executionContext |= LegacyUnbatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\nexport function flushSync<A, R>(fn: (A) => R, a: A): R {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    invariant(\n      false,\n      'flushSync was called from inside a lifecycle method. It cannot be ' +\n        'called when React is already rendering.',\n    );\n  }\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return runWithPriority(ImmediatePriority, fn.bind(null, a));\n  } finally {\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    flushSyncCallbackQueue();\n  }\n}\n\nexport function flushControlled(fn: () => mixed): void {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    runWithPriority(ImmediatePriority, fn);\n  } finally {\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      flushSyncCallbackQueue();\n    }\n  }\n}\n\n/**\n * 构建 workInProgressFiber 树及 rootFiber\n */\nfunction prepareFreshStack(root, expirationTime) {\n  // 为 FiberRoot 对象添加 finishedWork 属性\n  // finishedWork 表示 render 阶段执行完成后构建的待提交的 Fiber 对象\n  root.finishedWork = null;\n  // 初始化 finishedExpirationTime 值为 0\n  root.finishedExpirationTime = NoWork;\n\n  const timeoutHandle = root.timeoutHandle;\n  // 初始化渲染不执行 timeoutHandle => -1 noTimeout => -1\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  // 初始化渲染不执行 workInProgress 全局变量 初始化为 null\n  // false\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n  // 建构 workInProgress Fiber 树的 fiberRoot 对象\n  workInProgressRoot = root;\n  // 构建 workInProgress Fiber 树中的 rootFiber\n  workInProgress = createWorkInProgress(root.current, null);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false;\n  // true\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentDebugFiberInDEV();\n\n      if (workInProgress === null || workInProgress.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // interntionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n        workInProgress = null;\n        return null;\n      }\n\n      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n      }\n\n      throwException(\n        root,\n        workInProgress.return,\n        workInProgress,\n        thrownValue,\n        renderExpirationTime,\n      );\n      workInProgress = completeUnitOfWork(workInProgress);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n      continue;\n    }\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher(root) {\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nfunction pushInteractions(root) {\n  if (enableSchedulerTracing) {\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n    return prevInteractions;\n  }\n  return null;\n}\n\nfunction popInteractions(prevInteractions) {\n  if (enableSchedulerTracing) {\n    __interactionsRef.current = prevInteractions;\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\n\nexport function markRenderEventTimeAndConfig(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): void {\n  if (\n    expirationTime < workInProgressRootLatestProcessedExpirationTime &&\n    expirationTime > Idle\n  ) {\n    workInProgressRootLatestProcessedExpirationTime = expirationTime;\n  }\n  if (suspenseConfig !== null) {\n    if (\n      expirationTime < workInProgressRootLatestSuspenseTimeout &&\n      expirationTime > Idle\n    ) {\n      workInProgressRootLatestSuspenseTimeout = expirationTime;\n      // Most of the time we only have one config and getting wrong is not bad.\n      workInProgressRootCanSuspendUsingConfig = suspenseConfig;\n    }\n  }\n}\n\nexport function markUnprocessedUpdateTime(\n  expirationTime: ExpirationTime,\n): void {\n  if (expirationTime > workInProgressRootNextUnprocessedUpdateTime) {\n    workInProgressRootNextUnprocessedUpdateTime = expirationTime;\n  }\n}\n\nexport function renderDidSuspend(): void {\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\n\nexport function renderDidSuspendDelayIfPossible(): void {\n  if (\n    workInProgressRootExitStatus === RootIncomplete ||\n    workInProgressRootExitStatus === RootSuspended\n  ) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  }\n\n  // Check if there's a lower priority update somewhere else in the tree.\n  if (\n    workInProgressRootNextUnprocessedUpdateTime !== NoWork &&\n    workInProgressRoot !== null\n  ) {\n    // Mark the current render as suspended, and then mark that there's a\n    // pending update.\n    // TODO: This should immediately interrupt the current render, instead\n    // of waiting until the next time we yield.\n    markRootSuspendedAtTime(workInProgressRoot, renderExpirationTime);\n    markRootUpdatedAtTime(\n      workInProgressRoot,\n      workInProgressRootNextUnprocessedUpdateTime,\n    );\n  }\n}\n\nexport function renderDidError() {\n  if (workInProgressRootExitStatus !== RootCompleted) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n}\n\n// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nexport function renderHasNotSuspendedYet(): boolean {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootIncomplete;\n}\n\nfunction inferTimeFromExpirationTime(expirationTime: ExpirationTime): number {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n}\n\nfunction inferTimeFromExpirationTimeWithSuspenseConfig(\n  expirationTime: ExpirationTime,\n  suspenseConfig: SuspenseConfig,\n): number {\n  // We don't know exactly when the update was scheduled, but we can infer an\n  // approximate start time from the expiration time by subtracting the timeout\n  // that was added to the event time.\n  const earliestExpirationTimeMs = expirationTimeToMs(expirationTime);\n  return (\n    earliestExpirationTimeMs -\n    (suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION)\n  );\n}\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // workInProgress 是一个 fiber 对象\n  // 它的值不为 null 意味着该 fiber 对象上仍然有更新要执行\n  // while 方法支撑 render 阶段 所有 fiber 节点的构建\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n// 构建 Fiber 对象\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // unitOfWork => workInProgress Fiber 树中的 rootFiber\n  // current => currentFiber 树中的 rootFiber\n  const current = unitOfWork.alternate;\n  startWorkTimer(unitOfWork);\n  // 开发环境执行 忽略\n  setCurrentDebugFiberInDEV(unitOfWork);\n  // 存储下一个要构建的子级 Fiber 对象\n  let next;\n  // 初始渲染 不执行\n  // false\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    // beginWork: 从父到子, 构建 Fiber 节点对象\n    // 返回值 next 为当前节点的子节点\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n  // 开发环境执行 忽略\n  resetCurrentDebugFiberInDEV();\n  // 为旧的 props 属性赋值\n  // 此次更新后 pendingProps 变为 memoizedProps\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  // 如果子节点不存在说明当前节点向下遍历子节点已经到底了\n  // 继续向上返回 遇到兄弟节点 构建兄弟节点的子 Fiber 对象 直到返回到根 Fiber 对象\n  if (next === null) {\n    // 从子到父, 构建其余节点 Fiber 对象\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\n/**\n * 1. 创建 Fiber 对象\n * 2. 创建每一个节点的真实 DOM 对象并将其添加到 stateNode 属性中\n * 3. 收集要执行 DOM 操作的 Fiber 节点, 组建 effect 链表结构\n */\nfunction completeUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // 为 workInProgress 全局变量重新赋值\n  workInProgress = unitOfWork;\n  do {\n    // 获取备份节点\n    // 初始化渲染 非根 Fiber 对象没有备份节点 所以 current 为 null\n    const current = workInProgress.alternate;\n    // 父级 Fiber 对象, 非根 Fiber 对象都有父级\n    const returnFiber = workInProgress.return;\n    // 判断传入的 Fiber 对象是否构建完成, 任务调度相关\n    // & 是表示位的与运算, 把左右两边的数字转化为二进制\n    // 然后每一位分别进行比较, 如果相等就为1, 不相等即为0\n    // 此处应用\"位与\"运算符的目的是\"清零\"\n    // true\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // 开发环境代码 忽略\n      setCurrentDebugFiberInDEV(workInProgress);\n      let next;\n      // 如果不能使用分析器的 timer, 直接执行 completeWork\n      // enableProfilerTimer => true\n      // 但此处无论条件是否成立都会执行 completeWork\n      if (\n        !enableProfilerTimer ||\n        (workInProgress.mode & ProfileMode) === NoMode\n      ) {\n        // 重点代码(二)\n        // 创建节点真实 DOM 对象并将其添加到 stateNode 属性中\n        next = completeWork(current, workInProgress, renderExpirationTime);\n      } else {\n        // 否则执行分析器timer, 并执行 completeWork\n        startProfilerTimer(workInProgress);\n        // 创建节点真实 DOM 对象并将其添加到 stateNode 属性中\n        next = completeWork(current, workInProgress, renderExpirationTime);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n      stopWorkTimer(workInProgress);\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(workInProgress);\n      // 重点代码(一)\n      // 如果子级存在\n      if (next !== null) {\n        // 返回子级 一直返回到 workLoopSync\n        // 再重新执行 performUnitOfWork 构建子级 Fiber 节点对象\n        return next;\n      }\n\n      // 构建 effect 链表结构\n      // 如果不是根 Fiber 就是 true 否则就是 false\n      // 将子树和此 Fiber 的所有 effect 附加到父级的 effect 列表中\n      if (\n        // 如果父 Fiber 存在 并且\n        returnFiber !== null &&\n        // 父 Fiber 对象中的 effectTag 为 0\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // 将子树和此 Fiber 的所有副作用附加到父级的 effect 列表上\n\n        // 以下两个判断的作用是搜集子 Fiber的 effect 到父 Fiber\n        if (returnFiber.firstEffect === null) {\n          // first\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            // next\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          // last\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // 获取副作用标记\n        // 初始渲染时除[根组件]以外的 Fiber, effectTag 值都为 0, 即不需要执行任何真实DOM操作\n        // 根组件的 effectTag 值为 3, 即需要将此节点对应的真实DOM对象添加到页面中\n        const effectTag = workInProgress.effectTag;\n\n        // 创建 effect 列表时跳过 NoWork(0) 和 PerformedWork(1) 标记\n        // PerformedWork 由 React DevTools 读取, 不提交\n        // 初始渲染时 只有遍历到了根组件 判断条件才能成立, 将 effect 链表添加到 rootFiber\n        // 初始渲染 FiberRoot 对象中的 firstEffect 和 lastEffect 都是 App 组件\n        // 因为当所有节点在内存中构建完成后, 只需要一次将所有 DOM 添加到页面中\n        if (effectTag > PerformedWork) {\n          // false\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            // 为 fiberRoot 添加 firstEffect\n            returnFiber.firstEffect = workInProgress;\n          }\n          // 为 fiberRoot 添加 lastEffect\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n    } else {\n      // 初始渲染不执行\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(workInProgress, renderExpirationTime);\n\n      // Because this fiber did not complete, don't reset its expiration time.\n\n      if (\n        enableProfilerTimer &&\n        (workInProgress.mode & ProfileMode) !== NoMode\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = workInProgress.actualDuration;\n        let child = workInProgress.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        workInProgress.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        // TODO: The name stopFailedWorkTimer is misleading because Suspense\n        // also captures and restarts.\n        stopFailedWorkTimer(workInProgress);\n        next.effectTag &= HostEffectMask;\n        return next;\n      }\n      stopWorkTimer(workInProgress);\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n    // 获取下一个同级 Fiber 对象\n    const siblingFiber = workInProgress.sibling;\n    // 如果下一个同级 Fiber 对象存在\n    if (siblingFiber !== null) {\n      // 返回下一个同级 Fiber 对象\n      return siblingFiber;\n    }\n    // 否则退回父级\n    workInProgress = returnFiber;\n  } while (workInProgress !== null);\n\n  // 当执行到这里的时候, 说明遍历到了 root 节点, 已完成遍历\n  // 更新 workInProgressRootExitStatus 的状态为 已完成\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n  return null;\n}\n\nfunction getRemainingExpirationTime(fiber: Fiber) {\n  const updateExpirationTime = fiber.expirationTime;\n  const childExpirationTime = fiber.childExpirationTime;\n  return updateExpirationTime > childExpirationTime\n    ? updateExpirationTime\n    : childExpirationTime;\n}\n\nfunction resetChildExpirationTime(completedWork: Fiber) {\n  if (\n    renderExpirationTime !== Never &&\n    completedWork.childExpirationTime === Never\n  ) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  let newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n    // In profiling mode, resetChildExpirationTime is also used to reset\n    // profiler durations.\n    let actualDuration = completedWork.actualDuration;\n    let treeBaseDuration = completedWork.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0. This value will\n    // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration. If\n    // the fiber has not been cloned though, (meaning no work was done), then\n    // this value will reflect the amount of time spent working on a previous\n    // render. In that case it should not bubble. We determine whether it was\n    // cloned by comparing the child pointer.\n    const shouldBubbleActualDurations =\n      completedWork.alternate === null ||\n      completedWork.child !== completedWork.alternate.child;\n\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    completedWork.actualDuration = actualDuration;\n    completedWork.treeBaseDuration = treeBaseDuration;\n  } else {\n    let child = completedWork.child;\n    while (child !== null) {\n      const childUpdateExpirationTime = child.expirationTime;\n      const childChildExpirationTime = child.childExpirationTime;\n      if (childUpdateExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (childChildExpirationTime > newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      child = child.sibling;\n    }\n  }\n\n  completedWork.childExpirationTime = newChildExpirationTime;\n}\n\nfunction commitRoot(root) {\n  // 获取任务优先级 97 => 普通优先级\n  const renderPriorityLevel = getCurrentPriorityLevel();\n  // 使用最高优先级执行当前任务, 因为 commit 阶段不可以被打断\n  // ImmediatePriority, 优先级为 99, 最高优先级\n  runWithPriority(\n    ImmediatePriority,\n    commitRootImpl.bind(null, root, renderPriorityLevel),\n  );\n  return null;\n}\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // 触发useEffect回调与其他同步任务\n    // 由于这些任务可能触发新的渲染\n    // 所以这里要一直遍历执行直到没有任务\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n  // 开发环境执行 忽略\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Should not already be working.',\n  );\n  // 获取待提交 Fiber 对象 rootFiber\n  const finishedWork = root.finishedWork;\n\n  // 1073741823\n  const expirationTime = root.finishedExpirationTime;\n\n  // 如果没有任务要执行\n  if (finishedWork === null) {\n    // 阻止程序继续向下执行\n    return null;\n  }\n  // 重置为默认值\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n\n  invariant(\n    finishedWork !== root.current,\n    'Cannot commit the same tree as before. This error is likely caused by ' +\n      'a bug in React. Please file an issue.',\n  );\n\n  // commitRoot 是最后阶段, 不会再被异步调用了\n  // 所以清除 callback 相关的属性\n  root.callbackNode = null;\n  root.callbackExpirationTime = NoWork;\n  root.callbackPriority = NoPriority;\n  root.nextKnownPendingLevel = NoWork;\n\n  startCommitTimer();\n\n  // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n  const remainingExpirationTimeBeforeCommit = getRemainingExpirationTime(\n    finishedWork,\n  );\n  // 重置优先级相关变量\n  markRootFinishedAtTime(\n    root,\n    expirationTime,\n    remainingExpirationTimeBeforeCommit,\n  );\n  // false\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    renderExpirationTime = NoWork;\n  } else {\n    // 这表明我们处理的最后一个根与我们现在提交的根不同\n    // 最常见的情况是在挂起的根超时时发生\n  }\n\n  // 将 effectList 赋值给 firstEffect\n  // 由于每个 Fiber 的 effectList 只包含他的子孙节点\n  // 所以根节点如果有 effectTag 则不会被包含进来\n  // 所以这里将有 effectTag 的根节点插入到 effectList 尾部\n  // 这样才能保证有 effect 的 fiber 都在 effectList 中\n  let firstEffect;\n  // finishedWork.effectTag => 0\n  // PerformedWork => 1\n  // false\n  if (finishedWork.effectTag > PerformedWork) {\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // 根节点没有 effectTag\n    // 获取要执行 DOM 操作的副作用列表\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  // 以上代码为 commit 之前所做的准备工作\n  // firstEffect 会在 commit 的三个子阶段会用到\n\n  // true\n  if (firstEffect !== null) {\n    // 8\n    const prevExecutionContext = executionContext;\n    // 40\n    executionContext |= CommitContext;\n    const prevInteractions = pushInteractions(root);\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    startCommitSnapshotEffectsTimer();\n    prepareForCommit(root.containerInfo);\n    nextEffect = firstEffect;\n    // commit 第一个子阶段\n    // 处理类组件的 getSnapShotBeforeUpdate 生命周期函数\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(null, commitBeforeMutationEffects, null);\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitBeforeMutationEffects();\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitSnapshotEffectsTimer();\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    startCommitHostEffectsTimer();\n    // commit 第二个子阶段\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitMutationEffects,\n          null,\n          root,\n          renderPriorityLevel,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitMutationEffects(root, renderPriorityLevel);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitHostEffectsTimer();\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    startCommitLifeCyclesTimer();\n    // commit 第三个子阶段\n    nextEffect = firstEffect;\n    do {\n      if (__DEV__) {\n        invokeGuardedCallback(\n          null,\n          commitLayoutEffects,\n          null,\n          root,\n          expirationTime,\n        );\n        if (hasCaughtError()) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      } else {\n        try {\n          commitLayoutEffects(root, expirationTime);\n        } catch (error) {\n          invariant(nextEffect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(nextEffect, error);\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    } while (nextEffect !== null);\n    stopCommitLifeCyclesTimer();\n\n    // 重置 nextEffect\n    nextEffect = null;\n\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    requestPaint();\n\n    if (enableSchedulerTracing) {\n      popInteractions(((prevInteractions: any): Set<Interaction>));\n    }\n    executionContext = prevExecutionContext;\n  } else {\n    // No effects.\n    root.current = finishedWork;\n    // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n    startCommitSnapshotEffectsTimer();\n    stopCommitSnapshotEffectsTimer();\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n    startCommitHostEffectsTimer();\n    stopCommitHostEffectsTimer();\n    startCommitLifeCyclesTimer();\n    stopCommitLifeCyclesTimer();\n  }\n\n  stopCommitTimer();\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsExpirationTime = expirationTime;\n    pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n  } else {\n    // We are done with the effect chain at this point so let's clear the\n    // nextEffect pointers to assist with GC. If we have passive effects, we'll\n    // clear this in flushPassiveEffects.\n    nextEffect = firstEffect;\n    while (nextEffect !== null) {\n      const nextNextEffect = nextEffect.nextEffect;\n      nextEffect.nextEffect = null;\n      nextEffect = nextNextEffect;\n    }\n  }\n\n  // Check if there's remaining work on this root\n  const remainingExpirationTime = root.firstPendingTime;\n  if (remainingExpirationTime !== NoWork) {\n    if (enableSchedulerTracing) {\n      if (spawnedWorkDuringRender !== null) {\n        const expirationTimes = spawnedWorkDuringRender;\n        spawnedWorkDuringRender = null;\n        for (let i = 0; i < expirationTimes.length; i++) {\n          scheduleInteractions(\n            root,\n            expirationTimes[i],\n            root.memoizedInteractions,\n          );\n        }\n      }\n      schedulePendingInteractions(root, remainingExpirationTime);\n    }\n  } else {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (enableSchedulerTracing) {\n    if (!rootDidHavePassiveEffects) {\n      // If there are no passive effects, then we can complete the pending interactions.\n      // Otherwise, we'll wait until after the passive effects are flushed.\n      // Wait to do this until after remaining work has been scheduled,\n      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.\n      finishPendingInteractions(root, expirationTime);\n    }\n  }\n\n  if (remainingExpirationTime === Sync) {\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  onCommitRoot(finishedWork.stateNode, expirationTime);\n\n  // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n  ensureRootIsScheduled(root);\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {\n    // This is a legacy edge case. We just committed the initial mount of\n    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired\n    // synchronously, but layout updates should be deferred until the end\n    // of the batch.\n    return null;\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbackQueue();\n  return null;\n}\n\n// commit 阶段的第一个子阶段\n// 调用类组件的 getSnapshotBeforeUpdate 生命周期函数\nfunction commitBeforeMutationEffects() {\n  // 循环 effect 链\n  while (nextEffect !== null) {\n    // nextEffect 是 effect 链上从 firstEffect 到 lastEffect\n    // 的每一个需要commit的 fiber 对象\n\n    // 初始化渲染第一个 nextEffect 为 App 组件\n    // effectTag => 3\n    const effectTag = nextEffect.effectTag;\n    // console.log(effectTag);\n    // nextEffect = null;\n    // return;\n\n    // 如果 fiber 对象中里有 Snapshot 这个 effectTag 的话\n    // Snapshot 和更新有关系 初始化渲染 不执行\n    if ((effectTag & Snapshot) !== NoEffect) {\n      // 开发环境执行 忽略\n      setCurrentDebugFiberInDEV(nextEffect);\n      // 计 effect 的数\n      recordEffect();\n      // 获取当前 fiber 节点\n      const current = nextEffect.alternate;\n      // 当 nextEffect 上有 Snapshot 这个 effectTag 时\n      // 执行以下方法, 主要是类组件调用 getSnapshotBeforeUpdate 生命周期函数\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n      // 开发环境执行 忽略\n      resetCurrentDebugFiberInDEV();\n    }\n    // 调度 useEffect\n    // 初始化渲染 目前没有 不执行\n    // false\n    if ((effectTag & Passive) !== NoEffect) {\n      // If there are passive effects, schedule a callback to flush at\n      // the earliest opportunity.\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalPriority, () => {\n          // 触发useEffect\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\n// commit 阶段的第二个子阶段\n// 根据 effectTag 执行 DOM 操作\nfunction commitMutationEffects(root: FiberRoot, renderPriorityLevel) {\n  // 循环 effect 链\n  while (nextEffect !== null) {\n    // 开发环境执行 忽略\n    setCurrentDebugFiberInDEV(nextEffect);\n    // 获取 effectTag\n    // 初始渲染第一次循环为 App 组件\n    // 即将根组件及内部所有内容一次性添加到页面中\n    const effectTag = nextEffect.effectTag;\n\n    // 如果有文本节点, 将 value 置为''\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n    // 更新 ref\n    if (effectTag & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n    }\n\n    // 根据 effectTag 分别处理\n    let primaryEffectTag =\n      effectTag & (Placement | Update | Deletion | Hydrating);\n    // 匹配 effectTag\n    // 初始渲染 primaryEffectTag 为 2 匹配到 Placement\n    switch (primaryEffectTag) {\n      // 针对该节点及子节点进行插入操作\n      case Placement: {\n        commitPlacement(nextEffect);\n        // effectTag 从 3 变为 1\n        // 从 effect 标签中清除 \"placement\" 重置 effectTag 值\n        // 以便我们知道在调用诸如componentDidMount之类的任何生命周期之前已将其插入。\n        nextEffect.effectTag &= ~Placement;\n        break;\n      }\n      // 插入并更新 DOM\n      case PlacementAndUpdate: {\n        // 插入\n        commitPlacement(nextEffect);\n        // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        nextEffect.effectTag &= ~Placement;\n\n        // 更新\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 服务器端渲染\n      case Hydrating: {\n        nextEffect.effectTag &= ~Hydrating;\n        break;\n      }\n      // 服务器端渲染\n      case HydratingAndUpdate: {\n        nextEffect.effectTag &= ~Hydrating;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 更新 DOM\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      // 删除 DOM\n      case Deletion: {\n        commitDeletion(root, nextEffect, renderPriorityLevel);\n        break;\n      }\n    }\n\n    // TODO: Only record a mutation effect if primaryEffectTag is non-zero.\n    recordEffect();\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\n// commit 阶段的第三个子阶段\nfunction commitLayoutEffects(\n  root: FiberRoot,\n  committedExpirationTime: ExpirationTime,\n) {\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n    // 此时 effectTag 已经被重置为 1, 表示 DOM 操作已经完成\n    const effectTag = nextEffect.effectTag;\n    // 调用生命周期函数和钩子函数\n    // 前提是类组件中调用了生命周期函数\n    // 或者函数组件中调用了 useEffect\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      const current = nextEffect.alternate;\n      // 类组件处理生命周期函数\n      // 函数组件处理钩子函数\n      commitLayoutEffectOnFiber(\n        root,\n        current,\n        nextEffect,\n        committedExpirationTime,\n      );\n    }\n    // 赋值ref\n    // false\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    // 更新循环条件\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n\nexport function flushPassiveEffects() {\n  if (pendingPassiveEffectsRenderPriority !== NoPriority) {\n    const priorityLevel =\n      pendingPassiveEffectsRenderPriority > NormalPriority\n        ? NormalPriority\n        : pendingPassiveEffectsRenderPriority;\n    pendingPassiveEffectsRenderPriority = NoPriority;\n    return runWithPriority(priorityLevel, flushPassiveEffectsImpl);\n  }\n}\n\nexport function enqueuePendingPassiveHookEffectMount(\n  fiber: Fiber,\n  effect: HookEffect,\n): void {\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    pendingPassiveHookEffectsMount.push(effect, fiber);\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nexport function enqueuePendingPassiveHookEffectUnmount(\n  fiber: Fiber,\n  effect: HookEffect,\n): void {\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    pendingPassiveHookEffectsUnmount.push(effect, fiber);\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction invokePassiveEffectCreate(effect: HookEffect): void {\n  const create = effect.create;\n  effect.destroy = create();\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n  const root = rootWithPendingPassiveEffects;\n  const expirationTime = pendingPassiveEffectsExpirationTime;\n  rootWithPendingPassiveEffects = null;\n  pendingPassiveEffectsExpirationTime = NoWork;\n\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Cannot flush passive effects while already rendering.',\n  );\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  const prevInteractions = pushInteractions(root);\n\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    // It's important that ALL pending passive effect destroy functions are called\n    // before ANY passive effect create functions are called.\n    // Otherwise effects in sibling components might interfere with each other.\n    // e.g. a destroy function in one component may unintentionally override a ref\n    // value set by a create function in another component.\n    // Layout effects have the same constraint.\n\n    // First pass: Destroy stale passive effects.\n    let unmountEffects = pendingPassiveHookEffectsUnmount;\n    pendingPassiveHookEffectsUnmount = [];\n    for (let i = 0; i < unmountEffects.length; i += 2) {\n      const effect = ((unmountEffects[i]: any): HookEffect);\n      const fiber = ((unmountEffects[i + 1]: any): Fiber);\n      const destroy = effect.destroy;\n      effect.destroy = undefined;\n      if (typeof destroy === 'function') {\n        if (__DEV__) {\n          setCurrentDebugFiberInDEV(fiber);\n          invokeGuardedCallback(null, destroy, null);\n          if (hasCaughtError()) {\n            invariant(fiber !== null, 'Should be working on an effect.');\n            const error = clearCaughtError();\n            captureCommitPhaseError(fiber, error);\n          }\n          resetCurrentDebugFiberInDEV();\n        } else {\n          try {\n            destroy();\n          } catch (error) {\n            invariant(fiber !== null, 'Should be working on an effect.');\n            captureCommitPhaseError(fiber, error);\n          }\n        }\n      }\n    }\n\n    // Second pass: Create new passive effects.\n    let mountEffects = pendingPassiveHookEffectsMount;\n    pendingPassiveHookEffectsMount = [];\n    for (let i = 0; i < mountEffects.length; i += 2) {\n      const effect = ((mountEffects[i]: any): HookEffect);\n      const fiber = ((mountEffects[i + 1]: any): Fiber);\n      if (__DEV__) {\n        setCurrentDebugFiberInDEV(fiber);\n        invokeGuardedCallback(null, invokePassiveEffectCreate, null, effect);\n        if (hasCaughtError()) {\n          invariant(fiber !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(fiber, error);\n        }\n        resetCurrentDebugFiberInDEV();\n      } else {\n        try {\n          const create = effect.create;\n          effect.destroy = create();\n        } catch (error) {\n          invariant(fiber !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(fiber, error);\n        }\n      }\n    }\n  } else {\n    // Note: This currently assumes there are no passive effects on the root fiber\n    // because the root is not part of its own effect list.\n    // This could change in the future.\n    let effect = root.current.firstEffect;\n    while (effect !== null) {\n      if (__DEV__) {\n        setCurrentDebugFiberInDEV(effect);\n        invokeGuardedCallback(null, commitPassiveHookEffects, null, effect);\n        if (hasCaughtError()) {\n          invariant(effect !== null, 'Should be working on an effect.');\n          const error = clearCaughtError();\n          captureCommitPhaseError(effect, error);\n        }\n        resetCurrentDebugFiberInDEV();\n      } else {\n        try {\n          commitPassiveHookEffects(effect);\n        } catch (error) {\n          invariant(effect !== null, 'Should be working on an effect.');\n          captureCommitPhaseError(effect, error);\n        }\n      }\n      const nextNextEffect = effect.nextEffect;\n      // Remove nextEffect pointer to assist GC\n      effect.nextEffect = null;\n      effect = nextNextEffect;\n    }\n  }\n\n  if (enableSchedulerTracing) {\n    popInteractions(((prevInteractions: any): Set<Interaction>));\n    finishPendingInteractions(root, expirationTime);\n  }\n\n  executionContext = prevExecutionContext;\n\n  flushSyncCallbackQueue();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error: mixed) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(\n  rootFiber: Fiber,\n  sourceFiber: Fiber,\n  error: mixed,\n) {\n  const errorInfo = createCapturedValue(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, Sync);\n  enqueueUpdate(rootFiber, update);\n  const root = markUpdateTimeFromFiberToRoot(rootFiber, Sync);\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, Sync);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = sourceFiber.return;\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n      if (\n        typeof ctor.getDerivedStateFromError === 'function' ||\n        (typeof instance.componentDidCatch === 'function' &&\n          !isAlreadyFailedLegacyErrorBoundary(instance))\n      ) {\n        const errorInfo = createCapturedValue(error, sourceFiber);\n        const update = createClassErrorUpdate(\n          fiber,\n          errorInfo,\n          // TODO: This is always sync\n          Sync,\n        );\n        enqueueUpdate(fiber, update);\n        const root = markUpdateTimeFromFiberToRoot(fiber, Sync);\n        if (root !== null) {\n          ensureRootIsScheduled(root);\n          schedulePendingInteractions(root, Sync);\n        }\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n}\n\nexport function pingSuspendedRoot(\n  root: FiberRoot,\n  thenable: Thenable,\n  suspendedTime: ExpirationTime,\n) {\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(thenable);\n  }\n\n  if (workInProgressRoot === root && renderExpirationTime === suspendedTime) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n\n    // If we're suspended with delay, we'll always suspend so we can always\n    // restart. If we're suspended without any updates, it might be a retry.\n    // If it's early in the retry we can restart. We can't know for sure\n    // whether we'll eventually process an update during this render pass,\n    // but it's somewhat unlikely that we get to a ping before that, since\n    // getting to the root most update is usually very fast.\n    if (\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\n      (workInProgressRootExitStatus === RootSuspended &&\n        workInProgressRootLatestProcessedExpirationTime === Sync &&\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\n    ) {\n      // Restart from the root. Don't need to schedule a ping because\n      // we're already working on this tree.\n      prepareFreshStack(root, renderExpirationTime);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootHasPendingPing = true;\n    }\n    return;\n  }\n\n  if (!isRootSuspendedAtTime(root, suspendedTime)) {\n    // The root is no longer suspended at this time.\n    return;\n  }\n\n  const lastPingedTime = root.lastPingedTime;\n  if (lastPingedTime !== NoWork && lastPingedTime < suspendedTime) {\n    // There's already a lower priority ping scheduled.\n    return;\n  }\n\n  // Mark the time at which this ping was scheduled.\n  root.lastPingedTime = suspendedTime;\n\n  if (!enableTrainModelFix && root.finishedExpirationTime === suspendedTime) {\n    // If there's a pending fallback waiting to commit, throw it away.\n    root.finishedExpirationTime = NoWork;\n    root.finishedWork = null;\n  }\n\n  ensureRootIsScheduled(root);\n  schedulePendingInteractions(root, suspendedTime);\n}\n\nfunction retryTimedOutBoundary(\n  boundaryFiber: Fiber,\n  retryTime: ExpirationTime,\n) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new expiration time.\n  if (retryTime === NoWork) {\n    const suspenseConfig = null; // Retries don't carry over the already committed update.\n    const currentTime = requestCurrentTimeForUpdate();\n    retryTime = computeExpirationForFiber(\n      currentTime,\n      boundaryFiber,\n      suspenseConfig,\n    );\n  }\n  // TODO: Special case idle priority?\n  const root = markUpdateTimeFromFiberToRoot(boundaryFiber, retryTime);\n  if (root !== null) {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, retryTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n  let retryTime = NoWork;\n  if (suspenseState !== null) {\n    retryTime = suspenseState.retryTime;\n  }\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\n\nexport function resolveRetryThenable(boundaryFiber: Fiber, thenable: Thenable) {\n  let retryTime = NoWork; // Default\n  let retryCache: WeakSet<Thenable> | Set<Thenable> | null;\n  if (enableSuspenseServerRenderer) {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n        if (suspenseState !== null) {\n          retryTime = suspenseState.retryTime;\n        }\n        break;\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n      default:\n        invariant(\n          false,\n          'Pinged unknown suspense boundary type. ' +\n            'This is probably a bug in React.',\n        );\n    }\n  } else {\n    retryCache = boundaryFiber.stateNode;\n  }\n\n  if (retryCache !== null) {\n    // The thenable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(thenable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryTime);\n}\n\n// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed: number) {\n  return timeElapsed < 120\n    ? 120\n    : timeElapsed < 480\n    ? 480\n    : timeElapsed < 1080\n    ? 1080\n    : timeElapsed < 1920\n    ? 1920\n    : timeElapsed < 3000\n    ? 3000\n    : timeElapsed < 4320\n    ? 4320\n    : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction computeMsUntilSuspenseLoadingDelay(\n  mostRecentEventTime: ExpirationTime,\n  committedExpirationTime: ExpirationTime,\n  suspenseConfig: SuspenseConfig,\n) {\n  const busyMinDurationMs = (suspenseConfig.busyMinDurationMs: any) | 0;\n  if (busyMinDurationMs <= 0) {\n    return 0;\n  }\n  const busyDelayMs = (suspenseConfig.busyDelayMs: any) | 0;\n\n  // Compute the time until this render pass would expire.\n  const currentTimeMs: number = now();\n  const eventTimeMs: number = inferTimeFromExpirationTimeWithSuspenseConfig(\n    mostRecentEventTime,\n    suspenseConfig,\n  );\n  const timeElapsed = currentTimeMs - eventTimeMs;\n  if (timeElapsed <= busyDelayMs) {\n    // If we haven't yet waited longer than the initial delay, we don't\n    // have to wait any additional time.\n    return 0;\n  }\n  const msUntilTimeout = busyDelayMs + busyMinDurationMs - timeElapsed;\n  // This is the value that is passed to `setTimeout`.\n  return msUntilTimeout;\n}\n\nfunction checkForNestedUpdates() {\n  // NESTED_UPDATE_LIMIT => 50\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    invariant(\n      false,\n      'Maximum update depth exceeded. This can happen when a component ' +\n        'repeatedly calls setState inside componentWillUpdate or ' +\n        'componentDidUpdate. React limits the number of nested updates to ' +\n        'prevent infinite loops.',\n    );\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      console.error(\n        'Maximum update depth exceeded. This can happen when a component ' +\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\n          'have a dependency array, or one of the dependencies changes on ' +\n          'every render.',\n      );\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction stopFinishedWorkLoopTimer() {\n  const didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction stopInterruptedWorkLoopTimer() {\n  // TODO: Track which fiber caused the interruption.\n  const didCompleteRoot = false;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  interruptedBy = null;\n}\n\nfunction checkForInterruption(\n  fiberThatReceivedUpdate: Fiber,\n  updateExpirationTime: ExpirationTime,\n) {\n  if (\n    enableUserTimingAPI &&\n    workInProgressRoot !== null &&\n    updateExpirationTime > renderExpirationTime\n  ) {\n    interruptedBy = fiberThatReceivedUpdate;\n  }\n}\n\nlet didWarnStateUpdateForUnmountedComponent: Set<string> | null = null;\nfunction warnAboutUpdateOnUnmountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    const tag = fiber.tag;\n    if (\n      tag !== HostRoot &&\n      tag !== ClassComponent &&\n      tag !== FunctionComponent &&\n      tag !== ForwardRef &&\n      tag !== MemoComponent &&\n      tag !== SimpleMemoComponent &&\n      tag !== Block\n    ) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n\n    if (\n      deferPassiveEffectCleanupDuringUnmount &&\n      runAllPassiveEffectDestroysBeforeCreates\n    ) {\n      // If there are pending passive effects unmounts for this Fiber,\n      // we can assume that they would have prevented this update.\n      if (pendingPassiveHookEffectsUnmount.indexOf(fiber) >= 0) {\n        return;\n      }\n    }\n\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentName(fiber.type) || 'ReactComponent';\n    if (didWarnStateUpdateForUnmountedComponent !== null) {\n      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {\n        return;\n      }\n      didWarnStateUpdateForUnmountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);\n    }\n    console.error(\n      \"Can't perform a React state update on an unmounted component. This \" +\n        'is a no-op, but it indicates a memory leak in your application. To ' +\n        'fix, cancel all subscriptions and asynchronous tasks in %s.%s',\n      tag === ClassComponent\n        ? 'the componentWillUnmount method'\n        : 'a useEffect cleanup function',\n      getStackByFiberInDevAndProd(fiber),\n    );\n  }\n}\n\nlet beginWork;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  let dummyFiber = null;\n  beginWork = (current, unitOfWork, expirationTime) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\n      dummyFiber,\n      unitOfWork,\n    );\n    try {\n      return originalBeginWork(current, unitOfWork, expirationTime);\n    } catch (originalError) {\n      if (\n        originalError !== null &&\n        typeof originalError === 'object' &&\n        typeof originalError.then === 'function'\n      ) {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      }\n\n      // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n\n      // Unwind the failed stack frame\n      unwindInterruptedWork(unitOfWork);\n\n      // Restore the original properties of the fiber.\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      }\n\n      // Run beginWork again.\n      invokeGuardedCallback(\n        null,\n        originalBeginWork,\n        null,\n        current,\n        unitOfWork,\n        expirationTime,\n      );\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.\n        // Rethrow this error instead of the original one.\n        throw replayError;\n      } else {\n        // This branch is reachable if the render phase is impure.\n        throw originalError;\n      }\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (\n      ReactCurrentDebugFiberIsRenderingInDEV &&\n      (executionContext & RenderContext) !== NoContext\n    ) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent: {\n          const renderingComponentName =\n            (workInProgress && getComponentName(workInProgress.type)) ||\n            'Unknown';\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\n          const dedupeKey = renderingComponentName;\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n            const setStateComponentName =\n              getComponentName(fiber.type) || 'Unknown';\n            console.error(\n              'Cannot update a component (`%s`) while rendering a ' +\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\n                'follow the stack trace as described in https://fb.me/setstate-in-render',\n              setStateComponentName,\n              renderingComponentName,\n              renderingComponentName,\n            );\n          }\n          break;\n        }\n        case ClassComponent: {\n          if (!didWarnAboutUpdateInRender) {\n            console.error(\n              'Cannot update during an existing state transition (such as ' +\n                'within `render`). Render methods should be a pure ' +\n                'function of props and state.',\n            );\n            didWarnAboutUpdateInRender = true;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\n// a 'shared' variable that changes when act() opens/closes in tests.\nexport const IsThisRendererActing = {current: (false: boolean)};\n\nexport function warnIfNotScopedWithMatchingAct(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      IsSomeRendererActing.current === true &&\n      IsThisRendererActing.current !== true\n    ) {\n      console.error(\n        \"It looks like you're using the wrong act() around your test interactions.\\n\" +\n          'Be sure to use the matching version of act() corresponding to your renderer:\\n\\n' +\n          '// for react-dom:\\n' +\n          \"import {act} from 'react-dom/test-utils';\\n\" +\n          '// ...\\n' +\n          'act(() => ...);\\n\\n' +\n          '// for react-test-renderer:\\n' +\n          \"import TestRenderer from 'react-test-renderer';\\n\" +\n          'const {act} = TestRenderer;\\n' +\n          '// ...\\n' +\n          'act(() => ...);' +\n          '%s',\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport function warnIfNotCurrentlyActingEffectsInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      (fiber.mode & StrictMode) !== NoMode &&\n      IsSomeRendererActing.current === false &&\n      IsThisRendererActing.current === false\n    ) {\n      console.error(\n        'An update to %s ran an effect, but was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nfunction warnIfNotCurrentlyActingUpdatesInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (\n      warnsIfNotActing === true &&\n      executionContext === NoContext &&\n      IsSomeRendererActing.current === false &&\n      IsThisRendererActing.current === false\n    ) {\n      console.error(\n        'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n          'When testing, code that causes React state updates should be ' +\n          'wrapped into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* fire events that update state */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://fb.me/react-wrap-tests-with-act' +\n          '%s',\n        getComponentName(fiber.type),\n        getStackByFiberInDevAndProd(fiber),\n      );\n    }\n  }\n}\n\nexport const warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;\n\n// In tests, we want to enforce a mocked scheduler.\nlet didWarnAboutUnmockedScheduler = false;\n// TODO Before we release concurrent mode, revisit this and decide whether a mocked\n// scheduler is the actual recommendation. The alternative could be a testing build,\n// a new lib, or whatever; we dunno just yet. This message is for early adopters\n// to get their tests right.\n\nexport function warnIfUnmockedScheduler(fiber: Fiber) {\n  if (__DEV__) {\n    if (\n      didWarnAboutUnmockedScheduler === false &&\n      Scheduler.unstable_flushAllWithoutAsserting === undefined\n    ) {\n      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {\n        didWarnAboutUnmockedScheduler = true;\n        console.error(\n          'In Concurrent or Sync modes, the \"scheduler\" module needs to be mocked ' +\n            'to guarantee consistent behaviour across tests and browsers. ' +\n            'For example, with jest: \\n' +\n            \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" +\n            'For more info, visit https://fb.me/react-mock-scheduler',\n        );\n      } else if (warnAboutUnmockedScheduler === true) {\n        didWarnAboutUnmockedScheduler = true;\n        console.error(\n          'Starting from React v17, the \"scheduler\" module will need to be mocked ' +\n            'to guarantee consistent behaviour across tests and browsers. ' +\n            'For example, with jest: \\n' +\n            \"jest.mock('scheduler', () => require('scheduler/unstable_mock'));\\n\\n\" +\n            'For more info, visit https://fb.me/react-mock-scheduler',\n        );\n      }\n    }\n  }\n}\n\nfunction computeThreadID(root, expirationTime) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + root.interactionThreadID;\n}\n\nexport function markSpawnedWork(expirationTime: ExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  if (spawnedWorkDuringRender === null) {\n    spawnedWorkDuringRender = [expirationTime];\n  } else {\n    spawnedWorkDuringRender.push(expirationTime);\n  }\n}\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach((interaction) => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      interactions.forEach((interaction) => {\n        interaction.__count++;\n      });\n    }\n\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction schedulePendingInteractions(root, expirationTime) {\n  // This is called when work is scheduled on a root.\n  // It associates the current interactions with the newly-scheduled expiration.\n  // They will be restored when that expiration is later committed.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  scheduleInteractions(root, expirationTime, __interactionsRef.current);\n}\n\nfunction startWorkOnPendingInteractions(root, expirationTime) {\n  // This is called when new work is started on a root.\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  // Determine which interactions this batch of work currently includes, So that\n  // we can accurately attribute time spent working on it, And so that cascading\n  // work triggered during the render phase will be associated with it.\n  const interactions: Set<Interaction> = new Set();\n  root.pendingInteractionMap.forEach(\n    (scheduledInteractions, scheduledExpirationTime) => {\n      if (scheduledExpirationTime >= expirationTime) {\n        scheduledInteractions.forEach((interaction) =>\n          interactions.add(interaction),\n        );\n      }\n    },\n  );\n\n  // Store the current set of interactions on the FiberRoot for a few reasons:\n  // We can re-use it in hot functions like performConcurrentWorkOnRoot()\n  // without having to recalculate it. We will also use it in commitWork() to\n  // pass to any Profiler onRender() hooks. This also provides DevTools with a\n  // way to access it when the onCommitRoot() hook is called.\n  root.memoizedInteractions = interactions;\n\n  if (interactions.size > 0) {\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      const threadID = computeThreadID(root, expirationTime);\n      try {\n        subscriber.onWorkStarted(interactions, threadID);\n      } catch (error) {\n        // If the subscriber throws, rethrow it in a separate task\n        scheduleCallback(ImmediatePriority, () => {\n          throw error;\n        });\n      }\n    }\n  }\n}\n\nfunction finishPendingInteractions(root, committedExpirationTime) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  const earliestRemainingTimeAfterCommit = root.firstPendingTime;\n\n  let subscriber;\n\n  try {\n    subscriber = __subscriberRef.current;\n    if (subscriber !== null && root.memoizedInteractions.size > 0) {\n      const threadID = computeThreadID(root, committedExpirationTime);\n      subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n    }\n  } catch (error) {\n    // If the subscriber throws, rethrow it in a separate task\n    scheduleCallback(ImmediatePriority, () => {\n      throw error;\n    });\n  } finally {\n    // Clear completed interactions from the pending Map.\n    // Unless the render was suspended or cascading work was scheduled,\n    // In which case– leave pending interactions until the subsequent render.\n    const pendingInteractionMap = root.pendingInteractionMap;\n    pendingInteractionMap.forEach(\n      (scheduledInteractions, scheduledExpirationTime) => {\n        // Only decrement the pending interaction count if we're done.\n        // If there's still work at the current priority,\n        // That indicates that we are waiting for suspense data.\n        if (scheduledExpirationTime > earliestRemainingTimeAfterCommit) {\n          pendingInteractionMap.delete(scheduledExpirationTime);\n\n          scheduledInteractions.forEach((interaction) => {\n            interaction.__count--;\n\n            if (subscriber !== null && interaction.__count === 0) {\n              try {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              } catch (error) {\n                // If the subscriber throws, rethrow it in a separate task\n                scheduleCallback(ImmediatePriority, () => {\n                  throw error;\n                });\n              }\n            }\n          });\n        }\n      },\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}