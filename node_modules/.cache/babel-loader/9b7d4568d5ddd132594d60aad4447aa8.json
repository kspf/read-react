{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { unstable_wrap as Schedule_tracing_wrap } from 'scheduler/tracing';\nimport { deferPassiveEffectCleanupDuringUnmount, enableSchedulerTracing, enableProfilerTimer, enableSuspenseServerRenderer, enableDeprecatedFlareAPI, enableFundamentalAPI, enableSuspenseCallback, enableScopeAPI, runAllPassiveEffectDestroysBeforeCreates } from 'shared/ReactFeatureFlags';\nimport { FunctionComponent, ForwardRef, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, Profiler, SuspenseComponent, DehydratedFragment, IncompleteClassComponent, MemoComponent, SimpleMemoComponent, SuspenseListComponent, FundamentalComponent, ScopeComponent, Block } from 'shared/ReactWorkTags';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { NoEffect, ContentReset, Placement, Snapshot, Update, Passive } from 'shared/ReactSideEffectTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport { onCommitUnmount } from './ReactFiberDevToolsHook';\nimport { startPhaseTimer, stopPhaseTimer } from './ReactDebugFiberPerf';\nimport { getStackByFiberInDevAndProd } from './ReactCurrentFiber';\nimport { logCapturedError } from './ReactFiberErrorLogger';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { getCommitTime } from './ReactProfilerTimer';\nimport { commitUpdateQueue } from './ReactUpdateQueue';\nimport { getPublicInstance, supportsMutation, supportsPersistence, supportsHydration, commitMount, commitUpdate, resetTextContent, commitTextUpdate, appendChild, appendChildToContainer, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, clearSuspenseBoundary, clearSuspenseBoundaryFromContainer, replaceContainerChildren, createContainerChildSet, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance, unmountFundamentalComponent, updateFundamentalComponent, commitHydratedContainer, commitHydratedSuspenseInstance, beforeRemoveInstance } from './ReactFiberHostConfig';\nimport { captureCommitPhaseError, resolveRetryThenable, markCommitTimeOfFallback, enqueuePendingPassiveHookEffectMount, enqueuePendingPassiveHookEffectUnmount } from './ReactFiberWorkLoop';\nimport { NoEffect as NoHookEffect, HasEffect as HookHasEffect, Layout as HookLayout, Passive as HookPassive } from './ReactHookEffectTags';\nimport { didWarnAboutReassigningProps } from './ReactFiberBeginWork';\nimport { runWithPriority, NormalPriority } from './SchedulerWithReactIntegration';\nimport { updateDeprecatedEventListeners, unmountDeprecatedResponderListeners } from './ReactFiberDeprecatedEvents';\nlet didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nexport function logError(boundary, errorInfo) {\n  const source = errorInfo.source;\n  let stack = errorInfo.stack;\n\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  const capturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function (current, instance) {\n  startPhaseTimer(current, 'componentWillUnmount');\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n}; // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, instance) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);\n\n    if (hasCaughtError()) {\n      const unmountError = clearCaughtError();\n      captureCommitPhaseError(current, unmountError);\n    }\n  } else {\n    try {\n      callComponentWillUnmountWithTimer(current, instance);\n    } catch (unmountError) {\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current) {\n  const ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      if (__DEV__) {\n        invokeGuardedCallback(null, ref, null, null);\n\n        if (hasCaughtError()) {\n          const refError = clearCaughtError();\n          captureCommitPhaseError(current, refError);\n        }\n      } else {\n        try {\n          ref(null);\n        } catch (refError) {\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, destroy) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, destroy, null);\n\n    if (hasCaughtError()) {\n      const error = clearCaughtError();\n      captureCommitPhaseError(current, error);\n    }\n  } else {\n    try {\n      destroy();\n    } catch (error) {\n      captureCommitPhaseError(current, error);\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current, finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block:\n      {\n        return;\n      }\n    // 如果该 fiber 类型是 ClassComponent\n\n    case ClassComponent:\n      {\n        if (finishedWork.effectTag & Snapshot) {\n          if (current !== null) {\n            // 旧的 props\n            const prevProps = current.memoizedProps; // 旧的 state\n\n            const prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate'); // 获取 classComponent 组件的实例对象\n\n            const instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                }\n              }\n            } // 执行 getSnapshotBeforeUpdate 生命周期函数\n            // 在组件更新前捕获一些 DOM 信息\n            // 返回自定义的值或 null, 统称为 snapshot\n\n\n            const snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            if (__DEV__) {\n              const didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                console.error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));\n              }\n            } // 将 snapshot 赋值到 __reactInternalSnapshotBeforeUpdate 属性上\n\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n            stopPhaseTimer();\n          }\n        }\n\n        return;\n      }\n\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      // Nothing to do for these component types\n      return;\n  }\n\n  invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction commitHookEffectListUnmount(tag, finishedWork) {\n  const updateQueue = finishedWork.updateQueue;\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & tag) === tag) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n/**\n * useEffect 回调函数调用\n */\n\n\nfunction commitHookEffectListMount(tag, finishedWork) {\n  // 获取任务队列\n  const updateQueue = finishedWork.updateQueue; // 获取 lastEffect\n\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null; // 如果 lastEffect 不为 null\n\n  if (lastEffect !== null) {\n    // 获取要执行的副作用\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect; // 通过遍历的方式调用 useEffect 中的回调函数\n    // 在组件中定义了调用了几次 useEffect 遍历就会执行几次\n\n    do {\n      if ((effect.tag & tag) === tag) {\n        // Mount\n        const create = effect.create; // create 就是 useEffect 方法的第一个参数\n        // 返回值就是清理函数\n\n        effect.destroy = create();\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let addendum;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + 'useEffect(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` + 'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            console.error('An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s%s', addendum, getStackByFiberInDevAndProd(finishedWork));\n          }\n        }\n      } // 更新循环条件\n\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction schedulePassiveEffects(finishedWork) {\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    const updateQueue = finishedWork.updateQueue;\n    let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n    if (lastEffect !== null) {\n      const firstEffect = lastEffect.next;\n      let effect = firstEffect;\n\n      do {\n        const {\n          next,\n          tag\n        } = effect;\n\n        if ((tag & HookPassive) !== NoHookEffect && (tag & HookHasEffect) !== NoHookEffect) {\n          enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);\n          enqueuePendingPassiveHookEffectMount(finishedWork, effect);\n        }\n\n        effect = next;\n      } while (effect !== firstEffect);\n    }\n  }\n}\n\nexport function commitPassiveHookEffects(finishedWork) {\n  if ((finishedWork.effectTag & Passive) !== NoEffect) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n      case Block:\n        {\n          // TODO (#17945) We should call all passive destroy functions (for all fibers)\n          // before calling any create functions. The current approach only serializes\n          // these for a single fiber.\n          commitHookEffectListUnmount(HookPassive | HookHasEffect, finishedWork);\n          commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n          break;\n        }\n\n      default:\n        break;\n    }\n  }\n}\n\nfunction commitLifeCycles(finishedRoot, current, finishedWork, committedExpirationTime) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block:\n      {\n        // At this point layout effects have already been destroyed (during mutation phase).\n        // This is done to prevent sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n        commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n\n        if (runAllPassiveEffectDestroysBeforeCreates) {\n          schedulePassiveEffects(finishedWork);\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        // 获取类组件实例对象\n        const instance = finishedWork.stateNode; // 如果在类组件中存在生命周期函数判断条件就会成立\n\n        if (finishedWork.effectTag & Update) {\n          // 初始渲染阶段\n          if (current === null) {\n            startPhaseTimer(finishedWork, 'componentDidMount');\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                }\n              }\n            } // 调用 componentDidMount 生命周期函数\n\n\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            // 更新阶段\n            // 获取旧的 props\n            const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps); // 获取旧的 state\n\n            const prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, 'componentDidUpdate');\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n                }\n              }\n            } // 调用 componentDidUpdate 生命周期函数\n            // instance.__reactInternalSnapshotBeforeUpdate 快照\n            // getSnapShotBeforeUpdate 方法的返回值\n\n\n            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n            stopPhaseTimer();\n          }\n        } // 获取任务队列\n\n\n        const updateQueue = finishedWork.updateQueue; // 如果任务队列存在\n\n        if (updateQueue !== null) {\n          if (__DEV__) {\n            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n              }\n\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');\n              }\n            }\n          }\n          /**\n           * 调用 ReactElement 渲染完成之后的回调函数\n           * 即 render 方法的第三个参数\n           */\n\n\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n\n        return;\n      }\n\n    case HostRoot:\n      {\n        const updateQueue = finishedWork.updateQueue;\n\n        if (updateQueue !== null) {\n          let instance = null;\n\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n\n              case ClassComponent:\n                instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        const instance = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n\n        if (current === null && finishedWork.effectTag & Update) {\n          const type = finishedWork.type;\n          const props = finishedWork.memoizedProps;\n          commitMount(instance, type, props, finishedWork);\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        // We have no life-cycles associated with text.\n        return;\n      }\n\n    case HostPortal:\n      {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n\n    case Profiler:\n      {\n        if (enableProfilerTimer) {\n          const onRender = finishedWork.memoizedProps.onRender;\n\n          if (typeof onRender === 'function') {\n            if (enableSchedulerTracing) {\n              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);\n            } else {\n              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        return;\n      }\n\n    case SuspenseListComponent:\n    case IncompleteClassComponent:\n    case FundamentalComponent:\n    case ScopeComponent:\n      return;\n  }\n\n  invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        const instance = node.stateNode;\n\n        if (isHidden) {\n          hideInstance(instance);\n        } else {\n          unhideInstance(node.stateNode, node.memoizedProps);\n        }\n      } else if (node.tag === HostText) {\n        const instance = node.stateNode;\n\n        if (isHidden) {\n          hideTextInstance(instance);\n        } else {\n          unhideTextInstance(instance, node.memoizedProps);\n        }\n      } else if (node.tag === SuspenseComponent && node.memoizedState !== null && node.memoizedState.dehydrated === null) {\n        // Found a nested Suspense component that timed out. Skip over the\n        // primary child fragment, which should remain hidden.\n        const fallbackChildFragment = node.child.sibling;\n        fallbackChildFragment.return = node;\n        node = fallbackChildFragment;\n        continue;\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  const ref = finishedWork.ref;\n\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance.methods;\n    }\n\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  const currentRef = current.ref;\n\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n} // User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\n\n\nfunction commitUnmount(finishedRoot, current, renderPriorityLevel) {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block:\n      {\n        const updateQueue = current.updateQueue;\n\n        if (updateQueue !== null) {\n          const lastEffect = updateQueue.lastEffect;\n\n          if (lastEffect !== null) {\n            const firstEffect = lastEffect.next;\n\n            if (deferPassiveEffectCleanupDuringUnmount && runAllPassiveEffectDestroysBeforeCreates) {\n              let effect = firstEffect;\n\n              do {\n                const {\n                  destroy,\n                  tag\n                } = effect;\n\n                if (destroy !== undefined) {\n                  if ((tag & HookPassive) !== NoHookEffect) {\n                    enqueuePendingPassiveHookEffectUnmount(current, effect);\n                  } else {\n                    safelyCallDestroy(current, destroy);\n                  }\n                }\n\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            } else {\n              // When the owner fiber is deleted, the destroy function of a passive\n              // effect hook is called during the synchronous commit phase. This is\n              // a concession to implementation complexity. Calling it in the\n              // passive effect phase (like they usually are, when dependencies\n              // change during an update) would require either traversing the\n              // children of the deleted fiber again, or including unmount effects\n              // as part of the fiber effect list.\n              //\n              // Because this is during the sync commit phase, we need to change\n              // the priority.\n              //\n              // TODO: Reconsider this implementation trade off.\n              const priorityLevel = renderPriorityLevel > NormalPriority ? NormalPriority : renderPriorityLevel;\n              runWithPriority(priorityLevel, () => {\n                let effect = firstEffect;\n\n                do {\n                  const destroy = effect.destroy;\n\n                  if (destroy !== undefined) {\n                    safelyCallDestroy(current, destroy);\n                  }\n\n                  effect = effect.next;\n                } while (effect !== firstEffect);\n              });\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        safelyDetachRef(current);\n        const instance = current.stateNode;\n\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current, instance);\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        if (enableDeprecatedFlareAPI) {\n          unmountDeprecatedResponderListeners(current);\n          beforeRemoveInstance(current.stateNode);\n        }\n\n        safelyDetachRef(current);\n        return;\n      }\n\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current);\n        }\n\n        return;\n      }\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          const fundamentalInstance = current.stateNode;\n\n          if (fundamentalInstance !== null) {\n            unmountFundamentalComponent(fundamentalInstance);\n            current.stateNode = null;\n          }\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        if (enableSuspenseCallback) {\n          const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n          if (hydrationCallbacks !== null) {\n            const onDeleted = hydrationCallbacks.onDeleted;\n\n            if (onDeleted) {\n              onDeleted(current.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableDeprecatedFlareAPI) {\n          unmountDeprecatedResponderListeners(current);\n        }\n\n        if (enableScopeAPI) {\n          safelyDetachRef(current);\n        }\n\n        return;\n      }\n  }\n}\n\nfunction commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node = root;\n\n  while (true) {\n    commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n\n    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === root) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current) {\n  const alternate = current.alternate; // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n\n  current.return = null;\n  current.child = null;\n  current.memoizedState = null;\n  current.updateQueue = null;\n  current.dependencies = null;\n  current.alternate = null;\n  current.firstEffect = null;\n  current.lastEffect = null;\n  current.pendingProps = null;\n  current.memoizedProps = null;\n  current.stateNode = null;\n\n  if (alternate !== null) {\n    detachFiber(alternate);\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal = current.stateNode;\n  const {\n    containerInfo\n  } = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n    case FundamentalComponent:\n      {\n        return;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        const portalOrRoot = finishedWork.stateNode;\n        const {\n          containerInfo,\n          pendingChildren\n        } = portalOrRoot;\n        replaceContainerChildren(containerInfo, pendingChildren);\n        return;\n      }\n  }\n\n  invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n} // 获取 HostRootFiber 对象\n\n\nfunction getHostParentFiber(fiber) {\n  // 获取当前 Fiber 父级\n  let parent = fiber.return; // 查看父级是否为 null\n\n  while (parent !== null) {\n    // 查看父级是否为 hostRoot\n    if (isHostParent(parent)) {\n      // 返回\n      return parent;\n    } // 继续向上查找\n\n\n    parent = parent.return;\n  }\n\n  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n} // 获取非组件父级\n\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n} // 挂载 DOM 元素\n\n\nfunction commitPlacement(finishedWork) {\n  // finishedWork 初始化渲染时为根组件 Fiber 对象\n  if (!supportsMutation) {\n    return;\n  } // 获取非组件父级 Fiber 对象\n  // 初始渲染时为 <div id=\"root\"></div>\n\n\n  const parentFiber = getHostParentFiber(finishedWork); // 存储真正的父级 DOM 节点对象\n\n  let parent; // 是否为渲染容器\n  // 渲染容器和普通react元素的主要区别在于是否需要特殊处理注释节点\n\n  let isContainer; // 获取父级 DOM 节点对象\n  // 但是初始渲染时 rootFiber 对象中的 stateNode 存储的是 FiberRoot\n\n  const parentStateNode = parentFiber.stateNode; // 判断父节点的类型\n  // 初始渲染时是 hostRoot 3\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n\n    case HostRoot:\n      // 获取真正的 DOM 节点对象\n      // <div id=\"root\"></div>\n      parent = parentStateNode.containerInfo; // 是 container 容器\n\n      isContainer = true;\n      break;\n\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n\n    case FundamentalComponent:\n      if (enableFundamentalAPI) {\n        parent = parentStateNode.instance;\n        isContainer = false;\n      }\n\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  } // 如果父节点是文本节点的话\n\n\n  if (parentFiber.effectTag & ContentReset) {\n    // 在进行任何插入操作前, 需要先将 value 置为 ''\n    resetTextContent(parent); // 清除 ContentReset 这个 effectTag\n\n    parentFiber.effectTag &= ~ContentReset;\n  } // 查看当前节点是否有下一个兄弟节点\n  // 有, 执行 insertBefore\n  // 没有, 执行 appendChild\n\n\n  const before = getHostSibling(finishedWork); // 渲染容器\n\n  if (isContainer) {\n    // 向父节点中追加节点 或者 将子节点插入到 before 节点的前面\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    // 非渲染容器\n    // 向父节点中追加节点 或者 将子节点插入到 before 节点的前面\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n} // 向容器中追加 | 插入到某一个节点的前面\n\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  const {\n    tag\n  } = node; // 如果待插入的节点是一个 DOM 元素或者文本的话\n  // 比如 组件fiber => false div => true\n\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost || enableFundamentalAPI && tag === FundamentalComponent) {\n    // 获取 DOM 节点\n    const stateNode = isHost ? node.stateNode : node.stateNode.instance; // 如果 before 存在\n\n    if (before) {\n      // 插入到 before 前面\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      // 追加到父容器中\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    // 如果是组件节点, 比如 ClassComponent, 则找它的第一个子节点(DOM 元素)\n    // 进行插入操作\n    const child = node.child;\n\n    if (child !== null) {\n      // 向父级中追加子节点或者将子节点插入到 before 的前面\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent); // 获取下一个兄弟节点\n\n      let sibling = child.sibling; // 如果兄弟节点存在\n\n      while (sibling !== null) {\n        // 向父级中追加子节点或者将子节点插入到 before 的前面\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent); // 同步兄弟节点\n\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost || enableFundamentalAPI && tag === FundamentalComponent) {\n    const stateNode = isHost ? node.stateNode : node.stateNode.instance;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction unmountHostComponents(finishedRoot, current, renderPriorityLevel) {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node = current; // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n\n  let currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n\n      findParent: while (true) {\n        invariant(parent !== null, 'Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n        const parentStateNode = parent.stateNode;\n\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n\n          case FundamentalComponent:\n            if (enableFundamentalAPI) {\n              currentParent = parentStateNode.instance;\n              currentParentIsContainer = false;\n            }\n\n        }\n\n        parent = parent.return;\n      }\n\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      } // Don't visit children because we already visited them.\n\n    } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n      const fundamentalNode = node.stateNode.instance;\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel); // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, fundamentalNode);\n      } else {\n        removeChild(currentParent, fundamentalNode);\n      }\n    } else if (enableSuspenseServerRenderer && node.tag === DehydratedFragment) {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n\n          if (onDeleted) {\n            onDeleted(node.stateNode);\n          }\n        }\n      } // Delete the dehydrated suspense boundary and all of its content.\n\n\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n      } else {\n        clearSuspenseBoundary(currentParent, node.stateNode);\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true; // Visit children because portals might contain host components.\n\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, renderPriorityLevel); // Visit children because we may find more host components below.\n\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n\n    if (node === current) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n\n      node = node.return;\n\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(finishedRoot, current, renderPriorityLevel) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, renderPriorityLevel);\n  }\n\n  detachFiber(current);\n}\n\nfunction commitWork(current, finishedWork) {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case Block:\n        {\n          // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n          commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n          return;\n        }\n\n      case Profiler:\n        {\n          return;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseComponent(finishedWork);\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case SuspenseListComponent:\n        {\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case HostRoot:\n        {\n          if (supportsHydration) {\n            const root = finishedWork.stateNode;\n\n            if (root.hydrate) {\n              // We've just hydrated. No need to hydrate again.\n              root.hydrate = false;\n              commitHydratedContainer(root.containerInfo);\n            }\n          }\n\n          break;\n        }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block:\n      {\n        // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        return;\n      }\n\n    case HostComponent:\n      {\n        const instance = finishedWork.stateNode;\n\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n\n          const oldProps = current !== null ? current.memoizedProps : newProps;\n          const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n          const updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n\n          if (enableDeprecatedFlareAPI) {\n            const prevListeners = oldProps.DEPRECATED_flareListeners;\n            const nextListeners = newProps.DEPRECATED_flareListeners;\n\n            if (prevListeners !== nextListeners) {\n              updateDeprecatedEventListeners(nextListeners, finishedWork, null);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        invariant(finishedWork.stateNode !== null, 'This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n        const textInstance = finishedWork.stateNode;\n        const newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n\n        const oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n\n    case HostRoot:\n      {\n        if (supportsHydration) {\n          const root = finishedWork.stateNode;\n\n          if (root.hydrate) {\n            // We've just hydrated. No need to hydrate again.\n            root.hydrate = false;\n            commitHydratedContainer(root.containerInfo);\n          }\n        }\n\n        return;\n      }\n\n    case Profiler:\n      {\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        commitSuspenseComponent(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case IncompleteClassComponent:\n      {\n        return;\n      }\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          const fundamentalInstance = finishedWork.stateNode;\n          updateFundamentalComponent(fundamentalInstance);\n          return;\n        }\n\n        break;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          const scopeInstance = finishedWork.stateNode;\n          scopeInstance.fiber = finishedWork;\n\n          if (enableDeprecatedFlareAPI) {\n            const newProps = finishedWork.memoizedProps;\n            const oldProps = current !== null ? current.memoizedProps : newProps;\n            const prevListeners = oldProps.DEPRECATED_flareListeners;\n            const nextListeners = newProps.DEPRECATED_flareListeners;\n\n            if (prevListeners !== nextListeners || current === null) {\n              updateDeprecatedEventListeners(nextListeners, finishedWork, null);\n            }\n          }\n\n          return;\n        }\n\n        break;\n      }\n  }\n\n  invariant(false, 'This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction commitSuspenseComponent(finishedWork) {\n  let newState = finishedWork.memoizedState;\n  let newDidTimeout;\n  let primaryChildParent = finishedWork;\n\n  if (newState === null) {\n    newDidTimeout = false;\n  } else {\n    newDidTimeout = true;\n    primaryChildParent = finishedWork.child;\n    markCommitTimeOfFallback();\n  }\n\n  if (supportsMutation && primaryChildParent !== null) {\n    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);\n  }\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n\n    if (typeof suspenseCallback === 'function') {\n      const thenables = finishedWork.updateQueue;\n\n      if (thenables !== null) {\n        suspenseCallback(new Set(thenables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  const newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    const current = finishedWork.alternate;\n\n    if (current !== null) {\n      const prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n\n          if (enableSuspenseCallback) {\n            const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n            if (hydrationCallbacks !== null) {\n              const onHydrated = hydrationCallbacks.onHydrated;\n\n              if (onHydrated) {\n                onHydrated(suspenseInstance);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of thenables.\n  // For each thenable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const thenables = finishedWork.updateQueue;\n\n  if (thenables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    thenables.forEach(thenable => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      let retry = resolveRetryThenable.bind(null, finishedWork, thenable);\n\n      if (!retryCache.has(thenable)) {\n        if (enableSchedulerTracing) {\n          if (thenable.__reactDoNotTraceInteractions !== true) {\n            retry = Schedule_tracing_wrap(retry);\n          }\n        }\n\n        retryCache.add(thenable);\n        thenable.then(retry, retry);\n      }\n    });\n  }\n}\n\nfunction commitResetTextContent(current) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  resetTextContent(current.stateNode);\n}\n\nexport { commitBeforeMutationLifeCycles, commitResetTextContent, commitPlacement, commitDeletion, commitWork, commitLifeCycles, commitAttachRef, commitDetachRef };","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberCommitWork.js"],"names":["unstable_wrap","Schedule_tracing_wrap","deferPassiveEffectCleanupDuringUnmount","enableSchedulerTracing","enableProfilerTimer","enableSuspenseServerRenderer","enableDeprecatedFlareAPI","enableFundamentalAPI","enableSuspenseCallback","enableScopeAPI","runAllPassiveEffectDestroysBeforeCreates","FunctionComponent","ForwardRef","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","Profiler","SuspenseComponent","DehydratedFragment","IncompleteClassComponent","MemoComponent","SimpleMemoComponent","SuspenseListComponent","FundamentalComponent","ScopeComponent","Block","invokeGuardedCallback","hasCaughtError","clearCaughtError","NoEffect","ContentReset","Placement","Snapshot","Update","Passive","getComponentName","invariant","onCommitUnmount","startPhaseTimer","stopPhaseTimer","getStackByFiberInDevAndProd","logCapturedError","resolveDefaultProps","getCommitTime","commitUpdateQueue","getPublicInstance","supportsMutation","supportsPersistence","supportsHydration","commitMount","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","clearSuspenseBoundary","clearSuspenseBoundaryFromContainer","replaceContainerChildren","createContainerChildSet","hideInstance","hideTextInstance","unhideInstance","unhideTextInstance","unmountFundamentalComponent","updateFundamentalComponent","commitHydratedContainer","commitHydratedSuspenseInstance","beforeRemoveInstance","captureCommitPhaseError","resolveRetryThenable","markCommitTimeOfFallback","enqueuePendingPassiveHookEffectMount","enqueuePendingPassiveHookEffectUnmount","NoHookEffect","HasEffect","HookHasEffect","Layout","HookLayout","HookPassive","didWarnAboutReassigningProps","runWithPriority","NormalPriority","updateDeprecatedEventListeners","unmountDeprecatedResponderListeners","didWarnAboutUndefinedSnapshotBeforeUpdate","__DEV__","Set","PossiblyWeakSet","WeakSet","logError","boundary","errorInfo","source","stack","capturedError","componentName","type","componentStack","error","value","errorBoundary","errorBoundaryName","errorBoundaryFound","willRetry","tag","stateNode","e","setTimeout","callComponentWillUnmountWithTimer","current","instance","props","memoizedProps","state","memoizedState","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","ref","refError","safelyCallDestroy","destroy","commitBeforeMutationLifeCycles","finishedWork","effectTag","prevProps","prevState","elementType","console","snapshot","getSnapshotBeforeUpdate","didWarnSet","undefined","has","add","__reactInternalSnapshotBeforeUpdate","commitHookEffectListUnmount","updateQueue","lastEffect","firstEffect","next","effect","commitHookEffectListMount","create","addendum","then","schedulePassiveEffects","commitPassiveHookEffects","commitLifeCycles","finishedRoot","committedExpirationTime","componentDidMount","componentDidUpdate","child","onRender","id","actualDuration","treeBaseDuration","actualStartTime","memoizedInteractions","commitSuspenseHydrationCallbacks","hideOrUnhideAllChildren","isHidden","node","dehydrated","fallbackChildFragment","sibling","return","commitAttachRef","instanceToUse","methods","hasOwnProperty","commitDetachRef","currentRef","commitUnmount","renderPriorityLevel","priorityLevel","unmountHostComponents","emptyPortalContainer","fundamentalInstance","hydrationCallbacks","onDeleted","commitNestedUnmounts","root","detachFiber","alternate","dependencies","pendingProps","portal","containerInfo","emptyChildSet","commitContainer","portalOrRoot","pendingChildren","getHostParentFiber","fiber","parent","isHostParent","getHostSibling","siblings","commitPlacement","parentFiber","isContainer","parentStateNode","before","insertOrAppendPlacementNodeIntoContainer","insertOrAppendPlacementNode","isHost","currentParentIsValid","currentParent","currentParentIsContainer","findParent","fundamentalNode","commitDeletion","commitWork","commitSuspenseComponent","attachSuspenseRetryListeners","hydrate","newProps","oldProps","updatePayload","prevListeners","DEPRECATED_flareListeners","nextListeners","textInstance","newText","oldText","scopeInstance","newState","newDidTimeout","primaryChildParent","suspenseCallback","thenables","suspenseInstance","onHydrated","retryCache","forEach","thenable","retry","bind","__reactDoNotTraceInteractions","commitResetTextContent"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Instance,\n  TextInstance,\n  SuspenseInstance,\n  Container,\n  ChildSet,\n  UpdatePayload,\n} from './ReactFiberHostConfig';\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {CapturedValue, CapturedError} from './ReactCapturedValue';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks';\nimport type {Thenable} from './ReactFiberWorkLoop';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';\nimport {\n  deferPassiveEffectCleanupDuringUnmount,\n  enableSchedulerTracing,\n  enableProfilerTimer,\n  enableSuspenseServerRenderer,\n  enableDeprecatedFlareAPI,\n  enableFundamentalAPI,\n  enableSuspenseCallback,\n  enableScopeAPI,\n  runAllPassiveEffectDestroysBeforeCreates,\n} from 'shared/ReactFeatureFlags';\nimport {\n  FunctionComponent,\n  ForwardRef,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  Profiler,\n  SuspenseComponent,\n  DehydratedFragment,\n  IncompleteClassComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  SuspenseListComponent,\n  FundamentalComponent,\n  ScopeComponent,\n  Block,\n} from 'shared/ReactWorkTags';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {\n  NoEffect,\n  ContentReset,\n  Placement,\n  Snapshot,\n  Update,\n  Passive,\n} from 'shared/ReactSideEffectTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\n\nimport {onCommitUnmount} from './ReactFiberDevToolsHook';\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {getStackByFiberInDevAndProd} from './ReactCurrentFiber';\nimport {logCapturedError} from './ReactFiberErrorLogger';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {getCommitTime} from './ReactProfilerTimer';\nimport {commitUpdateQueue} from './ReactUpdateQueue';\nimport {\n  getPublicInstance,\n  supportsMutation,\n  supportsPersistence,\n  supportsHydration,\n  commitMount,\n  commitUpdate,\n  resetTextContent,\n  commitTextUpdate,\n  appendChild,\n  appendChildToContainer,\n  insertBefore,\n  insertInContainerBefore,\n  removeChild,\n  removeChildFromContainer,\n  clearSuspenseBoundary,\n  clearSuspenseBoundaryFromContainer,\n  replaceContainerChildren,\n  createContainerChildSet,\n  hideInstance,\n  hideTextInstance,\n  unhideInstance,\n  unhideTextInstance,\n  unmountFundamentalComponent,\n  updateFundamentalComponent,\n  commitHydratedContainer,\n  commitHydratedSuspenseInstance,\n  beforeRemoveInstance,\n} from './ReactFiberHostConfig';\nimport {\n  captureCommitPhaseError,\n  resolveRetryThenable,\n  markCommitTimeOfFallback,\n  enqueuePendingPassiveHookEffectMount,\n  enqueuePendingPassiveHookEffectUnmount,\n} from './ReactFiberWorkLoop';\nimport {\n  NoEffect as NoHookEffect,\n  HasEffect as HookHasEffect,\n  Layout as HookLayout,\n  Passive as HookPassive,\n} from './ReactHookEffectTags';\nimport {didWarnAboutReassigningProps} from './ReactFiberBeginWork';\nimport {runWithPriority, NormalPriority} from './SchedulerWithReactIntegration';\nimport {\n  updateDeprecatedEventListeners,\n  unmountDeprecatedResponderListeners,\n} from './ReactFiberDeprecatedEvents';\n\nlet didWarnAboutUndefinedSnapshotBeforeUpdate: Set<mixed> | null = null;\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n\nexport function logError(boundary: Fiber, errorInfo: CapturedValue<mixed>) {\n  const source = errorInfo.source;\n  let stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  const capturedError: CapturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false,\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function (current, instance) {\n  startPhaseTimer(current, 'componentWillUnmount');\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current, instance) {\n  if (__DEV__) {\n    invokeGuardedCallback(\n      null,\n      callComponentWillUnmountWithTimer,\n      null,\n      current,\n      instance,\n    );\n    if (hasCaughtError()) {\n      const unmountError = clearCaughtError();\n      captureCommitPhaseError(current, unmountError);\n    }\n  } else {\n    try {\n      callComponentWillUnmountWithTimer(current, instance);\n    } catch (unmountError) {\n      captureCommitPhaseError(current, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current: Fiber) {\n  const ref = current.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      if (__DEV__) {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          const refError = clearCaughtError();\n          captureCommitPhaseError(current, refError);\n        }\n      } else {\n        try {\n          ref(null);\n        } catch (refError) {\n          captureCommitPhaseError(current, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, destroy) {\n  if (__DEV__) {\n    invokeGuardedCallback(null, destroy, null);\n    if (hasCaughtError()) {\n      const error = clearCaughtError();\n      captureCommitPhaseError(current, error);\n    }\n  } else {\n    try {\n      destroy();\n    } catch (error) {\n      captureCommitPhaseError(current, error);\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(\n  current: Fiber | null,\n  finishedWork: Fiber,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block: {\n      return;\n    }\n    // 如果该 fiber 类型是 ClassComponent\n    case ClassComponent: {\n      if (finishedWork.effectTag & Snapshot) {\n        if (current !== null) {\n          // 旧的 props\n          const prevProps = current.memoizedProps;\n          // 旧的 state\n          const prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n          // 获取 classComponent 组件的实例对象\n          const instance = finishedWork.stateNode;\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error(\n                  'Expected %s props to match memoized props before ' +\n                    'getSnapshotBeforeUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentName(finishedWork.type) || 'instance',\n                );\n              }\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error(\n                  'Expected %s state to match memoized state before ' +\n                    'getSnapshotBeforeUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentName(finishedWork.type) || 'instance',\n                );\n              }\n            }\n          }\n          // 执行 getSnapshotBeforeUpdate 生命周期函数\n          // 在组件更新前捕获一些 DOM 信息\n          // 返回自定义的值或 null, 统称为 snapshot\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          if (__DEV__) {\n            const didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<mixed>);\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              console.error(\n                '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' +\n                  'must be returned. You have returned undefined.',\n                getComponentName(finishedWork.type),\n              );\n            }\n          }\n          // 将 snapshot 赋值到 __reactInternalSnapshotBeforeUpdate 属性上\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          stopPhaseTimer();\n        }\n      }\n      return;\n    }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      // Nothing to do for these component types\n      return;\n  }\n  invariant(\n    false,\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n\nfunction commitHookEffectListUnmount(tag: number, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & tag) === tag) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n/**\n * useEffect 回调函数调用\n */\nfunction commitHookEffectListMount(tag: number, finishedWork: Fiber) {\n  // 获取任务队列\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  // 获取 lastEffect\n  let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  // 如果 lastEffect 不为 null\n  if (lastEffect !== null) {\n    // 获取要执行的副作用\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    // 通过遍历的方式调用 useEffect 中的回调函数\n    // 在组件中定义了调用了几次 useEffect 遍历就会执行几次\n    do {\n      if ((effect.tag & tag) === tag) {\n        // Mount\n        const create = effect.create;\n        // create 就是 useEffect 方法的第一个参数\n        // 返回值就是清理函数\n        effect.destroy = create();\n        if (__DEV__) {\n          const destroy = effect.destroy;\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let addendum;\n            if (destroy === null) {\n              addendum =\n                ' You returned null. If your effect does not require clean ' +\n                'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum =\n                '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' +\n                'Instead, write the async function inside your effect ' +\n                'and call it immediately:\\n\\n' +\n                'useEffect(() => {\\n' +\n                '  async function fetchData() {\\n' +\n                '    // You can await here\\n' +\n                '    const response = await MyAPI.getData(someId);\\n' +\n                '    // ...\\n' +\n                '  }\\n' +\n                '  fetchData();\\n' +\n                `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\n                'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n            console.error(\n              'An effect function must not return anything besides a function, ' +\n                'which is used for clean-up.%s%s',\n              addendum,\n              getStackByFiberInDevAndProd(finishedWork),\n            );\n          }\n        }\n      }\n      // 更新循环条件\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction schedulePassiveEffects(finishedWork: Fiber) {\n  if (runAllPassiveEffectDestroysBeforeCreates) {\n    const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n    let lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n    if (lastEffect !== null) {\n      const firstEffect = lastEffect.next;\n      let effect = firstEffect;\n      do {\n        const {next, tag} = effect;\n        if (\n          (tag & HookPassive) !== NoHookEffect &&\n          (tag & HookHasEffect) !== NoHookEffect\n        ) {\n          enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);\n          enqueuePendingPassiveHookEffectMount(finishedWork, effect);\n        }\n        effect = next;\n      } while (effect !== firstEffect);\n    }\n  }\n}\n\nexport function commitPassiveHookEffects(finishedWork: Fiber): void {\n  if ((finishedWork.effectTag & Passive) !== NoEffect) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n      case Block: {\n        // TODO (#17945) We should call all passive destroy functions (for all fibers)\n        // before calling any create functions. The current approach only serializes\n        // these for a single fiber.\n        commitHookEffectListUnmount(HookPassive | HookHasEffect, finishedWork);\n        commitHookEffectListMount(HookPassive | HookHasEffect, finishedWork);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n}\n\nfunction commitLifeCycles(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedExpirationTime: ExpirationTime,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block: {\n      // At this point layout effects have already been destroyed (during mutation phase).\n      // This is done to prevent sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n\n      if (runAllPassiveEffectDestroysBeforeCreates) {\n        schedulePassiveEffects(finishedWork);\n      }\n      return;\n    }\n    case ClassComponent: {\n      // 获取类组件实例对象\n      const instance = finishedWork.stateNode;\n      // 如果在类组件中存在生命周期函数判断条件就会成立\n      if (finishedWork.effectTag & Update) {\n        // 初始渲染阶段\n        if (current === null) {\n          startPhaseTimer(finishedWork, 'componentDidMount');\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error(\n                  'Expected %s props to match memoized props before ' +\n                    'componentDidMount. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentName(finishedWork.type) || 'instance',\n                );\n              }\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error(\n                  'Expected %s state to match memoized state before ' +\n                    'componentDidMount. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentName(finishedWork.type) || 'instance',\n                );\n              }\n            }\n          }\n          // 调用 componentDidMount 生命周期函数\n          instance.componentDidMount();\n          stopPhaseTimer();\n        } else {\n          // 更新阶段\n          // 获取旧的 props\n          const prevProps =\n            finishedWork.elementType === finishedWork.type\n              ? current.memoizedProps\n              : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n          // 获取旧的 state\n          const prevState = current.memoizedState;\n          startPhaseTimer(finishedWork, 'componentDidUpdate');\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error(\n                  'Expected %s props to match memoized props before ' +\n                    'componentDidUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentName(finishedWork.type) || 'instance',\n                );\n              }\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error(\n                  'Expected %s state to match memoized state before ' +\n                    'componentDidUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentName(finishedWork.type) || 'instance',\n                );\n              }\n            }\n          }\n          // 调用 componentDidUpdate 生命周期函数\n          // instance.__reactInternalSnapshotBeforeUpdate 快照\n          // getSnapShotBeforeUpdate 方法的返回值\n          instance.componentDidUpdate(\n            prevProps,\n            prevState,\n            instance.__reactInternalSnapshotBeforeUpdate,\n          );\n          stopPhaseTimer();\n        }\n      }\n      // 获取任务队列\n      const updateQueue = finishedWork.updateQueue;\n      // 如果任务队列存在\n      if (updateQueue !== null) {\n        if (__DEV__) {\n          if (\n            finishedWork.type === finishedWork.elementType &&\n            !didWarnAboutReassigningProps\n          ) {\n            if (instance.props !== finishedWork.memoizedProps) {\n              console.error(\n                'Expected %s props to match memoized props before ' +\n                  'processing the update queue. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n            if (instance.state !== finishedWork.memoizedState) {\n              console.error(\n                'Expected %s state to match memoized state before ' +\n                  'processing the update queue. ' +\n                  'This might either be because of a bug in React, or because ' +\n                  'a component reassigns its own `this.props`. ' +\n                  'Please file an issue.',\n                getComponentName(finishedWork.type) || 'instance',\n              );\n            }\n          }\n        }\n        /**\n         * 调用 ReactElement 渲染完成之后的回调函数\n         * 即 render 方法的第三个参数\n         */\n        commitUpdateQueue(finishedWork, updateQueue, instance);\n      }\n      return;\n    }\n    case HostRoot: {\n      const updateQueue = finishedWork.updateQueue;\n      if (updateQueue !== null) {\n        let instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n              instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(finishedWork, updateQueue, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current === null && finishedWork.effectTag & Update) {\n        const type = finishedWork.type;\n        const props = finishedWork.memoizedProps;\n        commitMount(instance, type, props, finishedWork);\n      }\n\n      return;\n    }\n    case HostText: {\n      // We have no life-cycles associated with text.\n      return;\n    }\n    case HostPortal: {\n      // We have no life-cycles associated with portals.\n      return;\n    }\n    case Profiler: {\n      if (enableProfilerTimer) {\n        const onRender = finishedWork.memoizedProps.onRender;\n\n        if (typeof onRender === 'function') {\n          if (enableSchedulerTracing) {\n            onRender(\n              finishedWork.memoizedProps.id,\n              current === null ? 'mount' : 'update',\n              finishedWork.actualDuration,\n              finishedWork.treeBaseDuration,\n              finishedWork.actualStartTime,\n              getCommitTime(),\n              finishedRoot.memoizedInteractions,\n            );\n          } else {\n            onRender(\n              finishedWork.memoizedProps.id,\n              current === null ? 'mount' : 'update',\n              finishedWork.actualDuration,\n              finishedWork.treeBaseDuration,\n              finishedWork.actualStartTime,\n              getCommitTime(),\n            );\n          }\n        }\n      }\n      return;\n    }\n    case SuspenseComponent: {\n      commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      return;\n    }\n    case SuspenseListComponent:\n    case IncompleteClassComponent:\n    case FundamentalComponent:\n    case ScopeComponent:\n      return;\n  }\n  invariant(\n    false,\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent) {\n        const instance = node.stateNode;\n        if (isHidden) {\n          hideInstance(instance);\n        } else {\n          unhideInstance(node.stateNode, node.memoizedProps);\n        }\n      } else if (node.tag === HostText) {\n        const instance = node.stateNode;\n        if (isHidden) {\n          hideTextInstance(instance);\n        } else {\n          unhideTextInstance(instance, node.memoizedProps);\n        }\n      } else if (\n        node.tag === SuspenseComponent &&\n        node.memoizedState !== null &&\n        node.memoizedState.dehydrated === null\n      ) {\n        // Found a nested Suspense component that timed out. Skip over the\n        // primary child fragment, which should remain hidden.\n        const fallbackChildFragment: Fiber = (node.child: any).sibling;\n        fallbackChildFragment.return = node;\n        node = fallbackChildFragment;\n        continue;\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    // Moved outside to ensure DCE works with this flag\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance.methods;\n    }\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error(\n            'Unexpected ref object provided for %s. ' +\n              'Use either a ref-setter function or React.createRef().%s',\n            getComponentName(finishedWork.type),\n            getStackByFiberInDevAndProd(finishedWork),\n          );\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current: Fiber) {\n  const currentRef = current.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n\n          if (\n            deferPassiveEffectCleanupDuringUnmount &&\n            runAllPassiveEffectDestroysBeforeCreates\n          ) {\n            let effect = firstEffect;\n            do {\n              const {destroy, tag} = effect;\n              if (destroy !== undefined) {\n                if ((tag & HookPassive) !== NoHookEffect) {\n                  enqueuePendingPassiveHookEffectUnmount(current, effect);\n                } else {\n                  safelyCallDestroy(current, destroy);\n                }\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          } else {\n            // When the owner fiber is deleted, the destroy function of a passive\n            // effect hook is called during the synchronous commit phase. This is\n            // a concession to implementation complexity. Calling it in the\n            // passive effect phase (like they usually are, when dependencies\n            // change during an update) would require either traversing the\n            // children of the deleted fiber again, or including unmount effects\n            // as part of the fiber effect list.\n            //\n            // Because this is during the sync commit phase, we need to change\n            // the priority.\n            //\n            // TODO: Reconsider this implementation trade off.\n            const priorityLevel =\n              renderPriorityLevel > NormalPriority\n                ? NormalPriority\n                : renderPriorityLevel;\n            runWithPriority(priorityLevel, () => {\n              let effect = firstEffect;\n              do {\n                const destroy = effect.destroy;\n                if (destroy !== undefined) {\n                  safelyCallDestroy(current, destroy);\n                }\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            });\n          }\n        }\n      }\n      return;\n    }\n    case ClassComponent: {\n      safelyDetachRef(current);\n      const instance = current.stateNode;\n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(current, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      if (enableDeprecatedFlareAPI) {\n        unmountDeprecatedResponderListeners(current);\n        beforeRemoveInstance(current.stateNode);\n      }\n      safelyDetachRef(current);\n      return;\n    }\n    case HostPortal: {\n      // TODO: this is recursive.\n      // We are also not using this parent because\n      // the portal will get pushed immediately.\n      if (supportsMutation) {\n        unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n      } else if (supportsPersistence) {\n        emptyPortalContainer(current);\n      }\n      return;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalInstance = current.stateNode;\n        if (fundamentalInstance !== null) {\n          unmountFundamentalComponent(fundamentalInstance);\n          current.stateNode = null;\n        }\n      }\n      return;\n    }\n    case DehydratedFragment: {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((current.stateNode: SuspenseInstance));\n          }\n        }\n      }\n      return;\n    }\n    case ScopeComponent: {\n      if (enableDeprecatedFlareAPI) {\n        unmountDeprecatedResponderListeners(current);\n      }\n      if (enableScopeAPI) {\n        safelyDetachRef(current);\n      }\n      return;\n    }\n  }\n}\n\nfunction commitNestedUnmounts(\n  finishedRoot: FiberRoot,\n  root: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  let node: Fiber = root;\n  while (true) {\n    commitUnmount(finishedRoot, node, renderPriorityLevel);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (\n      node.child !== null &&\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      (!supportsMutation || node.tag !== HostPortal)\n    ) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current: Fiber) {\n  const alternate = current.alternate;\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current.return = null;\n  current.child = null;\n  current.memoizedState = null;\n  current.updateQueue = null;\n  current.dependencies = null;\n  current.alternate = null;\n  current.firstEffect = null;\n  current.lastEffect = null;\n  current.pendingProps = null;\n  current.memoizedProps = null;\n  current.stateNode = null;\n  if (alternate !== null) {\n    detachFiber(alternate);\n  }\n}\n\nfunction emptyPortalContainer(current: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal: {\n    containerInfo: Container,\n    pendingChildren: ChildSet,\n    ...\n  } = current.stateNode;\n  const {containerInfo} = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n    case FundamentalComponent: {\n      return;\n    }\n    case HostRoot:\n    case HostPortal: {\n      const portalOrRoot: {\n        containerInfo: Container,\n        pendingChildren: ChildSet,\n        ...\n      } = finishedWork.stateNode;\n      const {containerInfo, pendingChildren} = portalOrRoot;\n      replaceContainerChildren(containerInfo, pendingChildren);\n      return;\n    }\n  }\n  invariant(\n    false,\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n\n// 获取 HostRootFiber 对象\nfunction getHostParentFiber(fiber: Fiber): Fiber {\n  // 获取当前 Fiber 父级\n  let parent = fiber.return;\n  // 查看父级是否为 null\n  while (parent !== null) {\n    // 查看父级是否为 hostRoot\n    if (isHostParent(parent)) {\n      // 返回\n      return parent;\n    }\n    // 继续向上查找\n    parent = parent.return;\n  }\n  invariant(\n    false,\n    'Expected to find a host parent. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n}\n// 获取非组件父级\nfunction isHostParent(fiber: Fiber): boolean {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber: Fiber): ?Instance {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node: Fiber = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (\n      node.tag !== HostComponent &&\n      node.tag !== HostText &&\n      node.tag !== DehydratedFragment\n    ) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n// 挂载 DOM 元素\nfunction commitPlacement(finishedWork: Fiber): void {\n  // finishedWork 初始化渲染时为根组件 Fiber 对象\n\n  if (!supportsMutation) {\n    return;\n  }\n  // 获取非组件父级 Fiber 对象\n  // 初始渲染时为 <div id=\"root\"></div>\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  // 存储真正的父级 DOM 节点对象\n  let parent;\n  // 是否为渲染容器\n  // 渲染容器和普通react元素的主要区别在于是否需要特殊处理注释节点\n  let isContainer;\n  // 获取父级 DOM 节点对象\n  // 但是初始渲染时 rootFiber 对象中的 stateNode 存储的是 FiberRoot\n  const parentStateNode = parentFiber.stateNode;\n  // 判断父节点的类型\n  // 初始渲染时是 hostRoot 3\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      // 获取真正的 DOM 节点对象\n      // <div id=\"root\"></div>\n      parent = parentStateNode.containerInfo;\n      // 是 container 容器\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case FundamentalComponent:\n      if (enableFundamentalAPI) {\n        parent = parentStateNode.instance;\n        isContainer = false;\n      }\n    // eslint-disable-next-line-no-fallthrough\n    default:\n      invariant(\n        false,\n        'Invalid host parent fiber. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n  }\n  // 如果父节点是文本节点的话\n  if (parentFiber.effectTag & ContentReset) {\n    // 在进行任何插入操作前, 需要先将 value 置为 ''\n    resetTextContent(parent);\n    // 清除 ContentReset 这个 effectTag\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  // 查看当前节点是否有下一个兄弟节点\n  // 有, 执行 insertBefore\n  // 没有, 执行 appendChild\n  const before = getHostSibling(finishedWork);\n  // 渲染容器\n  if (isContainer) {\n    // 向父节点中追加节点 或者 将子节点插入到 before 节点的前面\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    // 非渲染容器\n    // 向父节点中追加节点 或者 将子节点插入到 before 节点的前面\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n}\n\n// 向容器中追加 | 插入到某一个节点的前面\nfunction insertOrAppendPlacementNodeIntoContainer(\n  node: Fiber,\n  before: ?Instance,\n  parent: Container,\n): void {\n  const {tag} = node;\n  // 如果待插入的节点是一个 DOM 元素或者文本的话\n  // 比如 组件fiber => false div => true\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost || (enableFundamentalAPI && tag === FundamentalComponent)) {\n    // 获取 DOM 节点\n    const stateNode = isHost ? node.stateNode : node.stateNode.instance;\n    // 如果 before 存在\n    if (before) {\n      // 插入到 before 前面\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      // 追加到父容器中\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {\n    // If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    // 如果是组件节点, 比如 ClassComponent, 则找它的第一个子节点(DOM 元素)\n    // 进行插入操作\n    const child = node.child;\n    if (child !== null) {\n      // 向父级中追加子节点或者将子节点插入到 before 的前面\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      // 获取下一个兄弟节点\n      let sibling = child.sibling;\n      // 如果兄弟节点存在\n      while (sibling !== null) {\n        // 向父级中追加子节点或者将子节点插入到 before 的前面\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        // 同步兄弟节点\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(\n  node: Fiber,\n  before: ?Instance,\n  parent: Instance,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  if (isHost || (enableFundamentalAPI && tag === FundamentalComponent)) {\n    const stateNode = isHost ? node.stateNode : node.stateNode.instance;\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) {\n    // If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n  } else {\n    const child = node.child;\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction unmountHostComponents(\n  finishedRoot,\n  current,\n  renderPriorityLevel,\n): void {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  let node: Fiber = current;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  let currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  let currentParent;\n  let currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      let parent = node.return;\n      findParent: while (true) {\n        invariant(\n          parent !== null,\n          'Expected to find a host parent. This error is likely caused by ' +\n            'a bug in React. Please file an issue.',\n        );\n        const parentStateNode = parent.stateNode;\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case FundamentalComponent:\n            if (enableFundamentalAPI) {\n              currentParent = parentStateNode.instance;\n              currentParentIsContainer = false;\n            }\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: Instance | TextInstance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (node.stateNode: Instance | TextInstance),\n        );\n      }\n      // Don't visit children because we already visited them.\n    } else if (enableFundamentalAPI && node.tag === FundamentalComponent) {\n      const fundamentalNode = node.stateNode.instance;\n      commitNestedUnmounts(finishedRoot, node, renderPriorityLevel);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (fundamentalNode: Instance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (fundamentalNode: Instance),\n        );\n      }\n    } else if (\n      enableSuspenseServerRenderer &&\n      node.tag === DehydratedFragment\n    ) {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((node.stateNode: SuspenseInstance));\n          }\n        }\n      }\n\n      // Delete the dehydrated suspense boundary and all of its content.\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: SuspenseInstance),\n        );\n      } else {\n        clearSuspenseBoundary(\n          ((currentParent: any): Instance),\n          (node.stateNode: SuspenseInstance),\n        );\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true;\n        // Visit children because portals might contain host components.\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, renderPriorityLevel);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, renderPriorityLevel);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, renderPriorityLevel);\n  }\n  detachFiber(current);\n}\n\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n      case Block: {\n        // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n        return;\n      }\n      case Profiler: {\n        return;\n      }\n      case SuspenseComponent: {\n        commitSuspenseComponent(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case SuspenseListComponent: {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n      case HostRoot: {\n        if (supportsHydration) {\n          const root: FiberRoot = finishedWork.stateNode;\n          if (root.hydrate) {\n            // We've just hydrated. No need to hydrate again.\n            root.hydrate = false;\n            commitHydratedContainer(root.containerInfo);\n          }\n        }\n        break;\n      }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block: {\n      // Layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // This prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n      return;\n    }\n    case ClassComponent: {\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        // TODO: Type the updateQueue to be specific to host components.\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n        if (enableDeprecatedFlareAPI) {\n          const prevListeners = oldProps.DEPRECATED_flareListeners;\n          const nextListeners = newProps.DEPRECATED_flareListeners;\n          if (prevListeners !== nextListeners) {\n            updateDeprecatedEventListeners(nextListeners, finishedWork, null);\n          }\n        }\n      }\n      return;\n    }\n    case HostText: {\n      invariant(\n        finishedWork.stateNode !== null,\n        'This should have a text node initialized. This error is likely ' +\n          'caused by a bug in React. Please file an issue.',\n      );\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      if (supportsHydration) {\n        const root: FiberRoot = finishedWork.stateNode;\n        if (root.hydrate) {\n          // We've just hydrated. No need to hydrate again.\n          root.hydrate = false;\n          commitHydratedContainer(root.containerInfo);\n        }\n      }\n      return;\n    }\n    case Profiler: {\n      return;\n    }\n    case SuspenseComponent: {\n      commitSuspenseComponent(finishedWork);\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case SuspenseListComponent: {\n      attachSuspenseRetryListeners(finishedWork);\n      return;\n    }\n    case IncompleteClassComponent: {\n      return;\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        const fundamentalInstance = finishedWork.stateNode;\n        updateFundamentalComponent(fundamentalInstance);\n        return;\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        const scopeInstance = finishedWork.stateNode;\n        scopeInstance.fiber = finishedWork;\n        if (enableDeprecatedFlareAPI) {\n          const newProps = finishedWork.memoizedProps;\n          const oldProps = current !== null ? current.memoizedProps : newProps;\n          const prevListeners = oldProps.DEPRECATED_flareListeners;\n          const nextListeners = newProps.DEPRECATED_flareListeners;\n          if (prevListeners !== nextListeners || current === null) {\n            updateDeprecatedEventListeners(nextListeners, finishedWork, null);\n          }\n        }\n        return;\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'This unit of work tag should not have side-effects. This error is ' +\n      'likely caused by a bug in React. Please file an issue.',\n  );\n}\n\nfunction commitSuspenseComponent(finishedWork: Fiber) {\n  let newState: SuspenseState | null = finishedWork.memoizedState;\n\n  let newDidTimeout;\n  let primaryChildParent = finishedWork;\n  if (newState === null) {\n    newDidTimeout = false;\n  } else {\n    newDidTimeout = true;\n    primaryChildParent = finishedWork.child;\n    markCommitTimeOfFallback();\n  }\n\n  if (supportsMutation && primaryChildParent !== null) {\n    hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);\n  }\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n    if (typeof suspenseCallback === 'function') {\n      const thenables: Set<Thenable> | null = (finishedWork.updateQueue: any);\n      if (thenables !== null) {\n        suspenseCallback(new Set(thenables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n) {\n  if (!supportsHydration) {\n    return;\n  }\n  const newState: SuspenseState | null = finishedWork.memoizedState;\n  if (newState === null) {\n    const current = finishedWork.alternate;\n    if (current !== null) {\n      const prevState: SuspenseState | null = current.memoizedState;\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n          if (enableSuspenseCallback) {\n            const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n            if (hydrationCallbacks !== null) {\n              const onHydrated = hydrationCallbacks.onHydrated;\n              if (onHydrated) {\n                onHydrated(suspenseInstance);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork: Fiber) {\n  // If this boundary just timed out, then it will have a set of thenables.\n  // For each thenable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const thenables: Set<Thenable> | null = (finishedWork.updateQueue: any);\n  if (thenables !== null) {\n    finishedWork.updateQueue = null;\n    let retryCache = finishedWork.stateNode;\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n    thenables.forEach((thenable) => {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      let retry = resolveRetryThenable.bind(null, finishedWork, thenable);\n      if (!retryCache.has(thenable)) {\n        if (enableSchedulerTracing) {\n          if (thenable.__reactDoNotTraceInteractions !== true) {\n            retry = Schedule_tracing_wrap(retry);\n          }\n        }\n        retryCache.add(thenable);\n        thenable.then(retry, retry);\n      }\n    });\n  }\n}\n\nfunction commitResetTextContent(current: Fiber) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current.stateNode);\n}\n\nexport {\n  commitBeforeMutationLifeCycles,\n  commitResetTextContent,\n  commitPlacement,\n  commitDeletion,\n  commitWork,\n  commitLifeCycles,\n  commitAttachRef,\n  commitDetachRef,\n};\n"]},"metadata":{},"sourceType":"module"}