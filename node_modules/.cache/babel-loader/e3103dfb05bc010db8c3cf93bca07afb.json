{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nimport { discreteUpdates, flushDiscreteUpdatesIfNeeded } from 'legacy-events/ReactGenericBatching';\nimport { DEPRECATED_dispatchEventForResponderEventSystem } from './DeprecatedDOMEventResponderSystem';\nimport { isReplayableDiscreteEvent, queueDiscreteEvent, hasQueuedDiscreteEvents, clearIfContinuousEvent, queueIfContinuousEvent } from './ReactDOMEventReplaying';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/reflection';\nimport { HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nimport { PLUGIN_EVENT_SYSTEM, RESPONDER_EVENT_SYSTEM, IS_PASSIVE, IS_ACTIVE, PASSIVE_NOT_SUPPORTED } from 'legacy-events/EventSystemFlags';\nimport { addEventBubbleListener, addEventCaptureListener, addEventCaptureListenerWithPassiveFlag } from './EventListener';\nimport getEventTarget from './getEventTarget';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { getRawEventName } from './DOMTopLevelEventTypes';\nimport { passiveBrowserEventsSupported } from './checkPassiveEvents';\nimport { enableDeprecatedFlareAPI } from 'shared/ReactFeatureFlags';\nimport { UserBlockingEvent, ContinuousEvent, DiscreteEvent } from 'shared/ReactTypes';\nimport { getEventPriorityForPluginSystem } from './DOMEventProperties';\nimport { dispatchEventForLegacyPluginEventSystem } from './DOMLegacyEventPluginSystem';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority\n} = Scheduler; // TODO: can we stop exporting these?\n\nexport let _enabled = true;\nexport function setEnabled(enabled) {\n  _enabled = !!enabled;\n}\nexport function isEnabled() {\n  return _enabled;\n}\nexport function trapBubbledEvent(topLevelType, element) {\n  trapEventForPluginEventSystem(element, topLevelType, false);\n}\nexport function trapCapturedEvent(topLevelType, element) {\n  trapEventForPluginEventSystem(element, topLevelType, true);\n}\nexport function addResponderEventSystemEvent(document, topLevelType, passive) {\n  let eventFlags = RESPONDER_EVENT_SYSTEM; // If passive option is not supported, then the event will be\n  // active and not passive, but we flag it as using not being\n  // supported too. This way the responder event plugins know,\n  // and can provide polyfills if needed.\n\n  if (passive) {\n    if (passiveBrowserEventsSupported) {\n      eventFlags |= IS_PASSIVE;\n    } else {\n      eventFlags |= IS_ACTIVE;\n      eventFlags |= PASSIVE_NOT_SUPPORTED;\n      passive = false;\n    }\n  } else {\n    eventFlags |= IS_ACTIVE;\n  } // Check if interactive and wrap in discreteUpdates\n\n\n  const listener = dispatchEvent.bind(null, topLevelType, eventFlags, document);\n\n  if (passiveBrowserEventsSupported) {\n    addEventCaptureListenerWithPassiveFlag(document, topLevelType, listener, passive);\n  } else {\n    addEventCaptureListener(document, topLevelType, listener);\n  }\n\n  return listener;\n}\nexport function removeActiveResponderEventSystemEvent(document, topLevelType, listener) {\n  if (passiveBrowserEventsSupported) {\n    document.removeEventListener(topLevelType, listener, {\n      capture: true,\n      passive: false\n    });\n  } else {\n    document.removeEventListener(topLevelType, listener, true);\n  }\n}\n\nfunction trapEventForPluginEventSystem(container, topLevelType, capture) {\n  let listener;\n\n  switch (getEventPriorityForPluginSystem(topLevelType)) {\n    case DiscreteEvent:\n      listener = dispatchDiscreteEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);\n      break;\n\n    case UserBlockingEvent:\n      listener = dispatchUserBlockingUpdate.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);\n      break;\n\n    case ContinuousEvent:\n    default:\n      listener = dispatchEvent.bind(null, topLevelType, PLUGIN_EVENT_SYSTEM, container);\n      break;\n  }\n\n  const rawEventName = getRawEventName(topLevelType);\n\n  if (capture) {\n    addEventCaptureListener(container, rawEventName, listener);\n  } else {\n    addEventBubbleListener(container, rawEventName, listener);\n  }\n}\n\nfunction dispatchDiscreteEvent(topLevelType, eventSystemFlags, container, nativeEvent) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(dispatchEvent, topLevelType, eventSystemFlags, container, nativeEvent);\n}\n\nfunction dispatchUserBlockingUpdate(topLevelType, eventSystemFlags, container, nativeEvent) {\n  runWithPriority(UserBlockingPriority, dispatchEvent.bind(null, topLevelType, eventSystemFlags, container, nativeEvent));\n}\n\nexport function dispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  if (hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(topLevelType)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.\n    topLevelType, eventSystemFlags, container, nativeEvent);\n    return;\n  }\n\n  const blockedOn = attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent);\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    clearIfContinuousEvent(topLevelType, nativeEvent);\n    return;\n  }\n\n  if (isReplayableDiscreteEvent(topLevelType)) {\n    // This this to be replayed later once the target is available.\n    queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);\n    return;\n  }\n\n  if (queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent)) {\n    return;\n  } // We need to clear only if we didn't queue because\n  // queueing is accummulative.\n\n\n  clearIfContinuousEvent(topLevelType, nativeEvent); // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n  if (enableDeprecatedFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, null);\n    }\n\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      DEPRECATED_dispatchEventForResponderEventSystem(topLevelType, null, nativeEvent, getEventTarget(nativeEvent), eventSystemFlags);\n    }\n  } else {\n    dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, null);\n  }\n} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\n\nexport function attemptToDispatchEvent(topLevelType, eventSystemFlags, container, nativeEvent) {\n  // TODO: Warn if _enabled is false.\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        } // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n\n\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (root.hydrate) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  if (enableDeprecatedFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);\n    }\n\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      DEPRECATED_dispatchEventForResponderEventSystem(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n    }\n  } else {\n    dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst);\n  } // We're not blocked on anything.\n\n\n  return null;\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-dom/src/events/ReactDOMEventListener.js"],"names":["Scheduler","discreteUpdates","flushDiscreteUpdatesIfNeeded","DEPRECATED_dispatchEventForResponderEventSystem","isReplayableDiscreteEvent","queueDiscreteEvent","hasQueuedDiscreteEvents","clearIfContinuousEvent","queueIfContinuousEvent","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","HostRoot","SuspenseComponent","PLUGIN_EVENT_SYSTEM","RESPONDER_EVENT_SYSTEM","IS_PASSIVE","IS_ACTIVE","PASSIVE_NOT_SUPPORTED","addEventBubbleListener","addEventCaptureListener","addEventCaptureListenerWithPassiveFlag","getEventTarget","getClosestInstanceFromNode","getRawEventName","passiveBrowserEventsSupported","enableDeprecatedFlareAPI","UserBlockingEvent","ContinuousEvent","DiscreteEvent","getEventPriorityForPluginSystem","dispatchEventForLegacyPluginEventSystem","unstable_UserBlockingPriority","UserBlockingPriority","unstable_runWithPriority","runWithPriority","_enabled","setEnabled","enabled","isEnabled","trapBubbledEvent","topLevelType","element","trapEventForPluginEventSystem","trapCapturedEvent","addResponderEventSystemEvent","document","passive","eventFlags","listener","dispatchEvent","bind","removeActiveResponderEventSystemEvent","removeEventListener","capture","container","dispatchDiscreteEvent","dispatchUserBlockingUpdate","rawEventName","eventSystemFlags","nativeEvent","timeStamp","blockedOn","attemptToDispatchEvent","nativeEventTarget","targetInst","nearestMounted","tag","instance","root","stateNode","hydrate"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\n\nimport {\n  discreteUpdates,\n  flushDiscreteUpdatesIfNeeded,\n} from 'legacy-events/ReactGenericBatching';\nimport {DEPRECATED_dispatchEventForResponderEventSystem} from './DeprecatedDOMEventResponderSystem';\nimport {\n  isReplayableDiscreteEvent,\n  queueDiscreteEvent,\n  hasQueuedDiscreteEvents,\n  clearIfContinuousEvent,\n  queueIfContinuousEvent,\n} from './ReactDOMEventReplaying';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/reflection';\nimport {HostRoot, SuspenseComponent} from 'shared/ReactWorkTags';\nimport {\n  type EventSystemFlags,\n  PLUGIN_EVENT_SYSTEM,\n  RESPONDER_EVENT_SYSTEM,\n  IS_PASSIVE,\n  IS_ACTIVE,\n  PASSIVE_NOT_SUPPORTED,\n} from 'legacy-events/EventSystemFlags';\n\nimport {\n  addEventBubbleListener,\n  addEventCaptureListener,\n  addEventCaptureListenerWithPassiveFlag,\n} from './EventListener';\nimport getEventTarget from './getEventTarget';\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport {getRawEventName} from './DOMTopLevelEventTypes';\nimport {passiveBrowserEventsSupported} from './checkPassiveEvents';\n\nimport {enableDeprecatedFlareAPI} from 'shared/ReactFeatureFlags';\nimport {\n  UserBlockingEvent,\n  ContinuousEvent,\n  DiscreteEvent,\n} from 'shared/ReactTypes';\nimport {getEventPriorityForPluginSystem} from './DOMEventProperties';\nimport {dispatchEventForLegacyPluginEventSystem} from './DOMLegacyEventPluginSystem';\n\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority,\n} = Scheduler;\n\n// TODO: can we stop exporting these?\nexport let _enabled = true;\n\nexport function setEnabled(enabled: ?boolean) {\n  _enabled = !!enabled;\n}\n\nexport function isEnabled() {\n  return _enabled;\n}\n\nexport function trapBubbledEvent(\n  topLevelType: DOMTopLevelEventType,\n  element: Document | Element | Node,\n): void {\n  trapEventForPluginEventSystem(element, topLevelType, false);\n}\n\nexport function trapCapturedEvent(\n  topLevelType: DOMTopLevelEventType,\n  element: Document | Element | Node,\n): void {\n  trapEventForPluginEventSystem(element, topLevelType, true);\n}\n\nexport function addResponderEventSystemEvent(\n  document: Document,\n  topLevelType: string,\n  passive: boolean,\n): any => void {\n  let eventFlags = RESPONDER_EVENT_SYSTEM;\n\n  // If passive option is not supported, then the event will be\n  // active and not passive, but we flag it as using not being\n  // supported too. This way the responder event plugins know,\n  // and can provide polyfills if needed.\n  if (passive) {\n    if (passiveBrowserEventsSupported) {\n      eventFlags |= IS_PASSIVE;\n    } else {\n      eventFlags |= IS_ACTIVE;\n      eventFlags |= PASSIVE_NOT_SUPPORTED;\n      passive = false;\n    }\n  } else {\n    eventFlags |= IS_ACTIVE;\n  }\n  // Check if interactive and wrap in discreteUpdates\n  const listener = dispatchEvent.bind(\n    null,\n    ((topLevelType: any): DOMTopLevelEventType),\n    eventFlags,\n    document,\n  );\n  if (passiveBrowserEventsSupported) {\n    addEventCaptureListenerWithPassiveFlag(\n      document,\n      topLevelType,\n      listener,\n      passive,\n    );\n  } else {\n    addEventCaptureListener(document, topLevelType, listener);\n  }\n  return listener;\n}\n\nexport function removeActiveResponderEventSystemEvent(\n  document: Document,\n  topLevelType: string,\n  listener: any => void,\n) {\n  if (passiveBrowserEventsSupported) {\n    document.removeEventListener(topLevelType, listener, {\n      capture: true,\n      passive: false,\n    });\n  } else {\n    document.removeEventListener(topLevelType, listener, true);\n  }\n}\n\nfunction trapEventForPluginEventSystem(\n  container: Document | Element | Node,\n  topLevelType: DOMTopLevelEventType,\n  capture: boolean,\n): void {\n  let listener;\n  switch (getEventPriorityForPluginSystem(topLevelType)) {\n    case DiscreteEvent:\n      listener = dispatchDiscreteEvent.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n        container,\n      );\n      break;\n    case UserBlockingEvent:\n      listener = dispatchUserBlockingUpdate.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n        container,\n      );\n      break;\n    case ContinuousEvent:\n    default:\n      listener = dispatchEvent.bind(\n        null,\n        topLevelType,\n        PLUGIN_EVENT_SYSTEM,\n        container,\n      );\n      break;\n  }\n\n  const rawEventName = getRawEventName(topLevelType);\n  if (capture) {\n    addEventCaptureListener(container, rawEventName, listener);\n  } else {\n    addEventBubbleListener(container, rawEventName, listener);\n  }\n}\n\nfunction dispatchDiscreteEvent(\n  topLevelType,\n  eventSystemFlags,\n  container,\n  nativeEvent,\n) {\n  flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);\n  discreteUpdates(\n    dispatchEvent,\n    topLevelType,\n    eventSystemFlags,\n    container,\n    nativeEvent,\n  );\n}\n\nfunction dispatchUserBlockingUpdate(\n  topLevelType,\n  eventSystemFlags,\n  container,\n  nativeEvent,\n) {\n  runWithPriority(\n    UserBlockingPriority,\n    dispatchEvent.bind(\n      null,\n      topLevelType,\n      eventSystemFlags,\n      container,\n      nativeEvent,\n    ),\n  );\n}\n\nexport function dispatchEvent(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  container: Document | Element | Node,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (!_enabled) {\n    return;\n  }\n  if (hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(topLevelType)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(\n      null, // Flags that we're not actually blocked on anything as far as we know.\n      topLevelType,\n      eventSystemFlags,\n      container,\n      nativeEvent,\n    );\n    return;\n  }\n\n  const blockedOn = attemptToDispatchEvent(\n    topLevelType,\n    eventSystemFlags,\n    container,\n    nativeEvent,\n  );\n\n  if (blockedOn === null) {\n    // We successfully dispatched this event.\n    clearIfContinuousEvent(topLevelType, nativeEvent);\n    return;\n  }\n\n  if (isReplayableDiscreteEvent(topLevelType)) {\n    // This this to be replayed later once the target is available.\n    queueDiscreteEvent(\n      blockedOn,\n      topLevelType,\n      eventSystemFlags,\n      container,\n      nativeEvent,\n    );\n    return;\n  }\n\n  if (\n    queueIfContinuousEvent(\n      blockedOn,\n      topLevelType,\n      eventSystemFlags,\n      container,\n      nativeEvent,\n    )\n  ) {\n    return;\n  }\n\n  // We need to clear only if we didn't queue because\n  // queueing is accummulative.\n  clearIfContinuousEvent(topLevelType, nativeEvent);\n\n  // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n  if (enableDeprecatedFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForLegacyPluginEventSystem(\n        topLevelType,\n        eventSystemFlags,\n        nativeEvent,\n        null,\n      );\n    }\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      DEPRECATED_dispatchEventForResponderEventSystem(\n        (topLevelType: any),\n        null,\n        nativeEvent,\n        getEventTarget(nativeEvent),\n        eventSystemFlags,\n      );\n    }\n  } else {\n    dispatchEventForLegacyPluginEventSystem(\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n      null,\n    );\n  }\n}\n\n// Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.\nexport function attemptToDispatchEvent(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  container: Document | Element | Node,\n  nativeEvent: AnyNativeEvent,\n): null | Container | SuspenseInstance {\n  // TODO: Warn if _enabled is false.\n\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        }\n        // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (root.hydrate) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  if (enableDeprecatedFlareAPI) {\n    if (eventSystemFlags & PLUGIN_EVENT_SYSTEM) {\n      dispatchEventForLegacyPluginEventSystem(\n        topLevelType,\n        eventSystemFlags,\n        nativeEvent,\n        targetInst,\n      );\n    }\n    if (eventSystemFlags & RESPONDER_EVENT_SYSTEM) {\n      // React Flare event system\n      DEPRECATED_dispatchEventForResponderEventSystem(\n        (topLevelType: any),\n        targetInst,\n        nativeEvent,\n        nativeEventTarget,\n        eventSystemFlags,\n      );\n    }\n  } else {\n    dispatchEventForLegacyPluginEventSystem(\n      topLevelType,\n      eventSystemFlags,\n      nativeEvent,\n      targetInst,\n    );\n  }\n  // We're not blocked on anything.\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}