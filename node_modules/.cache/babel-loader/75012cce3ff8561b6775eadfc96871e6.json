{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentName from 'shared/getComponentName';\nimport { getIteratorFn, REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE, REACT_FRAGMENT_TYPE, REACT_ELEMENT_TYPE } from 'shared/ReactSymbols';\nimport { warnAboutSpreadingKeyToJSX } from 'shared/ReactFeatureFlags';\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport ReactCurrentOwner from './ReactCurrentOwner';\nimport { isValidElement, createElement, cloneElement, jsxDEV } from './ReactElement';\nimport ReactDebugCurrentFrame, { setCurrentlyValidatingElement } from './ReactDebugCurrentFrame';\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    const name = getComponentName(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    const lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  let info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    const parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  let childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ` It was passed a child from ${getComponentName(element._owner.type)}.`;\n  }\n\n  setCurrentlyValidatingElement(element);\n\n  if (__DEV__) {\n    console.error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      const child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    const iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        const iterator = iteratorFn.call(node);\n        let step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  if (__DEV__) {\n    const type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    const name = getComponentName(type);\n    let propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      setCurrentlyValidatingElement(element);\n      checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n      setCurrentlyValidatingElement(null);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true;\n      console.error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      console.error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  if (__DEV__) {\n    setCurrentlyValidatingElement(fragment);\n    const keys = Object.keys(fragment.props);\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        console.error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      console.error('Invalid attribute `ref` supplied to `React.Fragment`.');\n    }\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nexport function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  const validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    let info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendum(source);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    if (__DEV__) {\n      console.error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  const element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    const children = props.children;\n\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (Array.isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          if (__DEV__) {\n            console.error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n  }\n\n  if (__DEV__) {\n    if (warnAboutSpreadingKeyToJSX) {\n      if (hasOwnProperty.call(props, 'key')) {\n        console.error('React.jsx: Spreading a key to JSX is a deprecated pattern. ' + 'Explicitly pass a key after spreading props in your JSX call. ' + 'E.g. <%s {...props} key={key} />', getComponentName(type) || 'ComponentName');\n      }\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nexport function jsxWithValidationStatic(type, props, key) {\n  return jsxWithValidation(type, props, key, true);\n}\nexport function jsxWithValidationDynamic(type, props, key) {\n  return jsxWithValidation(type, props, key, false);\n}\nexport function createElementWithValidation(type, props, children) {\n  const validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    let info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    if (__DEV__) {\n      console.error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  const element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nlet didWarnAboutDeprecatedCreateFactory = false;\nexport function createFactoryWithValidation(type) {\n  const validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  if (__DEV__) {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n      console.warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        console.warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nexport function cloneElementWithValidation(element, props, children) {\n  const newElement = cloneElement.apply(this, arguments);\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react/src/ReactElementValidator.js"],"names":["isValidElementType","getComponentName","getIteratorFn","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","REACT_FRAGMENT_TYPE","REACT_ELEMENT_TYPE","warnAboutSpreadingKeyToJSX","checkPropTypes","ReactCurrentOwner","isValidElement","createElement","cloneElement","jsxDEV","ReactDebugCurrentFrame","setCurrentlyValidatingElement","propTypesMisspellWarningShown","__DEV__","hasOwnProperty","Object","prototype","getDeclarationErrorAddendum","current","name","type","getSourceInfoErrorAddendum","source","undefined","fileName","replace","lineNumber","getSourceInfoErrorAddendumForProps","elementProps","__source","ownerHasKeyUseWarning","getCurrentComponentErrorInfo","parentType","info","parentName","displayName","validateExplicitKey","element","_store","validated","key","currentComponentErrorInfo","childOwner","_owner","console","error","validateChildKeys","node","Array","isArray","i","length","child","iteratorFn","entries","iterator","call","step","next","done","value","validatePropTypes","propTypes","$$typeof","props","getStackAddendum","PropTypes","getDefaultProps","isReactClassApproved","validateFragmentProps","fragment","keys","ref","jsxWithValidation","isStaticChildren","self","validType","sourceInfo","typeString","children","freeze","jsxWithValidationStatic","jsxWithValidationDynamic","createElementWithValidation","apply","arguments","didWarnAboutDeprecatedCreateFactory","createFactoryWithValidation","validatedFactory","bind","warn","defineProperty","enumerable","get","cloneElementWithValidation","newElement"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nimport isValidElementType from 'shared/isValidElementType';\nimport getComponentName from 'shared/getComponentName';\nimport {\n  getIteratorFn,\n  REACT_FORWARD_REF_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_ELEMENT_TYPE,\n} from 'shared/ReactSymbols';\nimport {warnAboutSpreadingKeyToJSX} from 'shared/ReactFeatureFlags';\nimport checkPropTypes from 'prop-types/checkPropTypes';\n\nimport ReactCurrentOwner from './ReactCurrentOwner';\nimport {\n  isValidElement,\n  createElement,\n  cloneElement,\n  jsxDEV,\n} from './ReactElement';\nimport ReactDebugCurrentFrame, {\n  setCurrentlyValidatingElement,\n} from './ReactDebugCurrentFrame';\n\nlet propTypesMisspellWarningShown;\n\nif (__DEV__) {\n  propTypesMisspellWarningShown = false;\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    const name = getComponentName(ReactCurrentOwner.current.type);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    const fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    const lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nconst ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  let info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    const parentName =\n      typeof parentType === 'string'\n        ? parentType\n        : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = `\\n\\nCheck the top-level render call using <${parentName}>.`;\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  const currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  let childOwner = '';\n  if (\n    element &&\n    element._owner &&\n    element._owner !== ReactCurrentOwner.current\n  ) {\n    // Give the component that originally created this child.\n    childOwner = ` It was passed a child from ${getComponentName(\n      element._owner.type,\n    )}.`;\n  }\n\n  setCurrentlyValidatingElement(element);\n  if (__DEV__) {\n    console.error(\n      'Each child in a list should have a unique \"key\" prop.' +\n        '%s%s See https://fb.me/react-warning-keys for more information.',\n      currentComponentErrorInfo,\n      childOwner,\n    );\n  }\n  setCurrentlyValidatingElement(null);\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (let i = 0; i < node.length; i++) {\n      const child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    const iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        const iterator = iteratorFn.call(node);\n        let step;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  if (__DEV__) {\n    const type = element.type;\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n    const name = getComponentName(type);\n    let propTypes;\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (\n      typeof type === 'object' &&\n      (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)\n    ) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n    if (propTypes) {\n      setCurrentlyValidatingElement(element);\n      checkPropTypes(\n        propTypes,\n        element.props,\n        'prop',\n        name,\n        ReactDebugCurrentFrame.getStackAddendum,\n      );\n      setCurrentlyValidatingElement(null);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true;\n      console.error(\n        'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',\n        name || 'Unknown',\n      );\n    }\n    if (\n      typeof type.getDefaultProps === 'function' &&\n      !type.getDefaultProps.isReactClassApproved\n    ) {\n      console.error(\n        'getDefaultProps is only used on classic React.createClass ' +\n          'definitions. Use a static property named `defaultProps` instead.',\n      );\n    }\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  if (__DEV__) {\n    setCurrentlyValidatingElement(fragment);\n\n    const keys = Object.keys(fragment.props);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key !== 'children' && key !== 'key') {\n        console.error(\n          'Invalid prop `%s` supplied to `React.Fragment`. ' +\n            'React.Fragment can only have `key` and `children` props.',\n          key,\n        );\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      console.error('Invalid attribute `ref` supplied to `React.Fragment`.');\n    }\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nexport function jsxWithValidation(\n  type,\n  props,\n  key,\n  isStaticChildren,\n  source,\n  self,\n) {\n  const validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    let info = '';\n    if (\n      type === undefined ||\n      (typeof type === 'object' &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        ' You likely forgot to export your component from the file ' +\n        \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendum(source);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info =\n        ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    if (__DEV__) {\n      console.error(\n        'React.jsx: type is invalid -- expected a string (for ' +\n          'built-in components) or a class/function (for composite ' +\n          'components) but got: %s.%s',\n        typeString,\n        info,\n      );\n    }\n  }\n\n  const element = jsxDEV(type, props, key, source, self);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n  if (validType) {\n    const children = props.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (Array.isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          if (__DEV__) {\n            console.error(\n              'React.jsx: Static children should always be an array. ' +\n                'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n                'Use the Babel transform instead.',\n            );\n          }\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n  }\n\n  if (__DEV__) {\n    if (warnAboutSpreadingKeyToJSX) {\n      if (hasOwnProperty.call(props, 'key')) {\n        console.error(\n          'React.jsx: Spreading a key to JSX is a deprecated pattern. ' +\n            'Explicitly pass a key after spreading props in your JSX call. ' +\n            'E.g. <%s {...props} key={key} />',\n          getComponentName(type) || 'ComponentName',\n        );\n      }\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\n// These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\nexport function jsxWithValidationStatic(type, props, key) {\n  return jsxWithValidation(type, props, key, true);\n}\n\nexport function jsxWithValidationDynamic(type, props, key) {\n  return jsxWithValidation(type, props, key, false);\n}\n\nexport function createElementWithValidation(type, props, children) {\n  const validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    let info = '';\n    if (\n      type === undefined ||\n      (typeof type === 'object' &&\n        type !== null &&\n        Object.keys(type).length === 0)\n    ) {\n      info +=\n        ' You likely forgot to export your component from the file ' +\n        \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    const sourceInfo = getSourceInfoErrorAddendumForProps(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    let typeString;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = `<${getComponentName(type.type) || 'Unknown'} />`;\n      info =\n        ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    if (__DEV__) {\n      console.error(\n        'React.createElement: type is invalid -- expected a string (for ' +\n          'built-in components) or a class/function (for composite ' +\n          'components) but got: %s.%s',\n        typeString,\n        info,\n      );\n    }\n  }\n\n  const element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nlet didWarnAboutDeprecatedCreateFactory = false;\n\nexport function createFactoryWithValidation(type) {\n  const validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  if (__DEV__) {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n      console.warn(\n        'React.createFactory() is deprecated and will be removed in ' +\n          'a future major release. Consider using JSX ' +\n          'or use React.createElement() directly instead.',\n      );\n    }\n    // Legacy hook: remove it\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function() {\n        console.warn(\n          'Factory.type is deprecated. Access the class directly ' +\n            'before passing it to createFactory.',\n        );\n        Object.defineProperty(this, 'type', {\n          value: type,\n        });\n        return type;\n      },\n    });\n  }\n\n  return validatedFactory;\n}\n\nexport function cloneElementWithValidation(element, props, children) {\n  const newElement = cloneElement.apply(this, arguments);\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n"]},"metadata":{},"sourceType":"module"}