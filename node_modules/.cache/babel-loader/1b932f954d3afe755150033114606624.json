{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nimport { __interactionsRef } from 'scheduler/tracing';\nimport { enableSchedulerTracing } from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nconst {\n  unstable_runWithPriority: Scheduler_runWithPriority,\n  unstable_scheduleCallback: Scheduler_scheduleCallback,\n  unstable_cancelCallback: Scheduler_cancelCallback,\n  unstable_shouldYield: Scheduler_shouldYield,\n  unstable_requestPaint: Scheduler_requestPaint,\n  unstable_now: Scheduler_now,\n  unstable_getCurrentPriorityLevel: Scheduler_getCurrentPriorityLevel,\n  unstable_ImmediatePriority: Scheduler_ImmediatePriority,\n  unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,\n  unstable_NormalPriority: Scheduler_NormalPriority,\n  unstable_LowPriority: Scheduler_LowPriority,\n  unstable_IdlePriority: Scheduler_IdlePriority\n} = Scheduler;\n\nif (enableSchedulerTracing) {\n  // Provide explicit error message when production+profiling bundle of e.g.\n  // react-dom is used with production (non-profiling) bundle of\n  // scheduler/tracing\n  invariant(__interactionsRef != null && __interactionsRef.current != null, 'It is not supported to run the profiling version of a renderer (for ' + 'example, `react-dom/profiling`) without also replacing the ' + '`scheduler/tracing` module with `scheduler/tracing-profiling`. Your ' + 'bundler might have a setting for aliasing both modules. Learn more at ' + 'http://fb.me/react-profiling');\n}\n\nconst fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use\n// ascending numbers so we can compare them like numbers. They start at 90 to\n// avoid clashing with Scheduler's priorities.\n\nexport const ImmediatePriority = 99;\nexport const UserBlockingPriority = 98;\nexport const NormalPriority = 97;\nexport const LowPriority = 96;\nexport const IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.\n\nexport const NoPriority = 90;\nexport const shouldYield = Scheduler_shouldYield;\nexport const requestPaint = // Fall back gracefully if we're running an older version of Scheduler.\nScheduler_requestPaint !== undefined ? Scheduler_requestPaint : () => {};\nlet syncQueue = null;\nlet immediateQueueCallbackNode = null;\nlet isFlushingSyncQueue = false;\nlet initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.\n// This will be the case for modern browsers that support `performance.now`. In\n// older browsers, Scheduler falls back to `Date.now`, which returns a Unix\n// timestamp. In that case, subtract the module initialization time to simulate\n// the behavior of performance.now and keep our times small enough to fit\n// within 32 bits.\n// TODO: Consider lifting this into Scheduler.\n\nexport const now = initialTimeMs < 10000 ? Scheduler_now : () => Scheduler_now() - initialTimeMs;\nexport function getCurrentPriorityLevel() {\n  switch (Scheduler_getCurrentPriorityLevel()) {\n    // 99 立即执行的任务\n    case Scheduler_ImmediatePriority:\n      return ImmediatePriority;\n    // 98 用户交互任务\n\n    case Scheduler_UserBlockingPriority:\n      return UserBlockingPriority;\n    // 97 普通优先级\n\n    case Scheduler_NormalPriority:\n      return NormalPriority;\n    // 96 低优先级任务\n\n    case Scheduler_LowPriority:\n      return LowPriority;\n    // 95 闲时任务\n\n    case Scheduler_IdlePriority:\n      return IdlePriority;\n\n    default:\n      // 缺少优先级\n      invariant(false, 'Unknown priority level.');\n  }\n}\n\nfunction reactPriorityToSchedulerPriority(reactPriorityLevel) {\n  switch (reactPriorityLevel) {\n    case ImmediatePriority:\n      return Scheduler_ImmediatePriority;\n\n    case UserBlockingPriority:\n      return Scheduler_UserBlockingPriority;\n\n    case NormalPriority:\n      return Scheduler_NormalPriority;\n\n    case LowPriority:\n      return Scheduler_LowPriority;\n\n    case IdlePriority:\n      return Scheduler_IdlePriority;\n\n    default:\n      invariant(false, 'Unknown priority level.');\n  }\n}\n\nexport function runWithPriority(reactPriorityLevel, fn) {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_runWithPriority(priorityLevel, fn);\n}\nexport function scheduleCallback(reactPriorityLevel, callback, options) {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_scheduleCallback(priorityLevel, callback, options);\n}\nexport function scheduleSyncCallback(callback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.\n\n    immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n\n  return fakeCallbackNode;\n}\nexport function cancelCallback(callbackNode) {\n  if (callbackNode !== fakeCallbackNode) {\n    Scheduler_cancelCallback(callbackNode);\n  }\n}\nexport function flushSyncCallbackQueue() {\n  if (immediateQueueCallbackNode !== null) {\n    const node = immediateQueueCallbackNode;\n    immediateQueueCallbackNode = null;\n    Scheduler_cancelCallback(node);\n  }\n\n  flushSyncCallbackQueueImpl();\n}\n\nfunction flushSyncCallbackQueueImpl() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrancy.\n    isFlushingSyncQueue = true;\n    let i = 0;\n\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      runWithPriority(ImmediatePriority, () => {\n        for (; i < queue.length; i++) {\n          let callback = queue[i];\n\n          do {\n            callback = callback(isSync);\n          } while (callback !== null);\n        }\n      });\n      syncQueue = null;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      } // Resume flushing in the next tick\n\n\n      Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);\n      throw error;\n    } finally {\n      isFlushingSyncQueue = false;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/SchedulerWithReactIntegration.js"],"names":["Scheduler","__interactionsRef","enableSchedulerTracing","invariant","unstable_runWithPriority","Scheduler_runWithPriority","unstable_scheduleCallback","Scheduler_scheduleCallback","unstable_cancelCallback","Scheduler_cancelCallback","unstable_shouldYield","Scheduler_shouldYield","unstable_requestPaint","Scheduler_requestPaint","unstable_now","Scheduler_now","unstable_getCurrentPriorityLevel","Scheduler_getCurrentPriorityLevel","unstable_ImmediatePriority","Scheduler_ImmediatePriority","unstable_UserBlockingPriority","Scheduler_UserBlockingPriority","unstable_NormalPriority","Scheduler_NormalPriority","unstable_LowPriority","Scheduler_LowPriority","unstable_IdlePriority","Scheduler_IdlePriority","current","fakeCallbackNode","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","NoPriority","shouldYield","requestPaint","undefined","syncQueue","immediateQueueCallbackNode","isFlushingSyncQueue","initialTimeMs","now","getCurrentPriorityLevel","reactPriorityToSchedulerPriority","reactPriorityLevel","runWithPriority","fn","priorityLevel","scheduleCallback","callback","options","scheduleSyncCallback","flushSyncCallbackQueueImpl","push","cancelCallback","callbackNode","flushSyncCallbackQueue","node","i","isSync","queue","length","error","slice"],"mappings":"AAAA;;;;;;;;AASA;AACA;AACA,OAAO,KAAKA,SAAZ,MAA2B,WAA3B;AACA,SAAQC,iBAAR,QAAgC,mBAAhC;AACA,SAAQC,sBAAR,QAAqC,0BAArC;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AAEA,MAAM;AACJC,EAAAA,wBAAwB,EAAEC,yBADtB;AAEJC,EAAAA,yBAAyB,EAAEC,0BAFvB;AAGJC,EAAAA,uBAAuB,EAAEC,wBAHrB;AAIJC,EAAAA,oBAAoB,EAAEC,qBAJlB;AAKJC,EAAAA,qBAAqB,EAAEC,sBALnB;AAMJC,EAAAA,YAAY,EAAEC,aANV;AAOJC,EAAAA,gCAAgC,EAAEC,iCAP9B;AAQJC,EAAAA,0BAA0B,EAAEC,2BARxB;AASJC,EAAAA,6BAA6B,EAAEC,8BAT3B;AAUJC,EAAAA,uBAAuB,EAAEC,wBAVrB;AAWJC,EAAAA,oBAAoB,EAAEC,qBAXlB;AAYJC,EAAAA,qBAAqB,EAAEC;AAZnB,IAaF3B,SAbJ;;AAeA,IAAIE,sBAAJ,EAA4B;AAC1B;AACA;AACA;AACAC,EAAAA,SAAS,CACPF,iBAAiB,IAAI,IAArB,IAA6BA,iBAAiB,CAAC2B,OAAlB,IAA6B,IADnD,EAEP,yEACE,6DADF,GAEE,sEAFF,GAGE,wEAHF,GAIE,8BANK,CAAT;AAQD;;AAOD,MAAMC,gBAAgB,GAAG,EAAzB,C,CAEA;AACA;AACA;;AACA,OAAO,MAAMC,iBAAqC,GAAG,EAA9C;AACP,OAAO,MAAMC,oBAAwC,GAAG,EAAjD;AACP,OAAO,MAAMC,cAAkC,GAAG,EAA3C;AACP,OAAO,MAAMC,WAA+B,GAAG,EAAxC;AACP,OAAO,MAAMC,YAAgC,GAAG,EAAzC,C,CACP;;AACA,OAAO,MAAMC,UAA8B,GAAG,EAAvC;AAEP,OAAO,MAAMC,WAAW,GAAGzB,qBAApB;AACP,OAAO,MAAM0B,YAAY,GACvB;AACAxB,sBAAsB,KAAKyB,SAA3B,GAAuCzB,sBAAvC,GAAgE,MAAM,CAAE,CAFnE;AAIP,IAAI0B,SAA0C,GAAG,IAAjD;AACA,IAAIC,0BAAwC,GAAG,IAA/C;AACA,IAAIC,mBAA4B,GAAG,KAAnC;AACA,IAAIC,aAAqB,GAAG3B,aAAa,EAAzC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAM4B,GAAG,GACdD,aAAa,GAAG,KAAhB,GAAwB3B,aAAxB,GAAwC,MAAMA,aAAa,KAAK2B,aAD3D;AAGP,OAAO,SAASE,uBAAT,GAAuD;AAC5D,UAAQ3B,iCAAiC,EAAzC;AACE;AACA,SAAKE,2BAAL;AACE,aAAOW,iBAAP;AACF;;AACA,SAAKT,8BAAL;AACE,aAAOU,oBAAP;AACF;;AACA,SAAKR,wBAAL;AACE,aAAOS,cAAP;AACF;;AACA,SAAKP,qBAAL;AACE,aAAOQ,WAAP;AACF;;AACA,SAAKN,sBAAL;AACE,aAAOO,YAAP;;AACF;AACE;AACA/B,MAAAA,SAAS,CAAC,KAAD,EAAQ,yBAAR,CAAT;AAlBJ;AAoBD;;AAED,SAAS0C,gCAAT,CAA0CC,kBAA1C,EAA8D;AAC5D,UAAQA,kBAAR;AACE,SAAKhB,iBAAL;AACE,aAAOX,2BAAP;;AACF,SAAKY,oBAAL;AACE,aAAOV,8BAAP;;AACF,SAAKW,cAAL;AACE,aAAOT,wBAAP;;AACF,SAAKU,WAAL;AACE,aAAOR,qBAAP;;AACF,SAAKS,YAAL;AACE,aAAOP,sBAAP;;AACF;AACExB,MAAAA,SAAS,CAAC,KAAD,EAAQ,yBAAR,CAAT;AAZJ;AAcD;;AAED,OAAO,SAAS4C,eAAT,CACLD,kBADK,EAELE,EAFK,EAGF;AACH,QAAMC,aAAa,GAAGJ,gCAAgC,CAACC,kBAAD,CAAtD;AACA,SAAOzC,yBAAyB,CAAC4C,aAAD,EAAgBD,EAAhB,CAAhC;AACD;AAED,OAAO,SAASE,gBAAT,CACLJ,kBADK,EAELK,QAFK,EAGLC,OAHK,EAIL;AACA,QAAMH,aAAa,GAAGJ,gCAAgC,CAACC,kBAAD,CAAtD;AACA,SAAOvC,0BAA0B,CAAC0C,aAAD,EAAgBE,QAAhB,EAA0BC,OAA1B,CAAjC;AACD;AAED,OAAO,SAASC,oBAAT,CAA8BF,QAA9B,EAA2D;AAChE;AACA;AACA,MAAIZ,SAAS,KAAK,IAAlB,EAAwB;AACtBA,IAAAA,SAAS,GAAG,CAACY,QAAD,CAAZ,CADsB,CAEtB;;AACAX,IAAAA,0BAA0B,GAAGjC,0BAA0B,CACrDY,2BADqD,EAErDmC,0BAFqD,CAAvD;AAID,GAPD,MAOO;AACL;AACA;AACAf,IAAAA,SAAS,CAACgB,IAAV,CAAeJ,QAAf;AACD;;AACD,SAAOtB,gBAAP;AACD;AAED,OAAO,SAAS2B,cAAT,CAAwBC,YAAxB,EAA6C;AAClD,MAAIA,YAAY,KAAK5B,gBAArB,EAAuC;AACrCpB,IAAAA,wBAAwB,CAACgD,YAAD,CAAxB;AACD;AACF;AAED,OAAO,SAASC,sBAAT,GAAkC;AACvC,MAAIlB,0BAA0B,KAAK,IAAnC,EAAyC;AACvC,UAAMmB,IAAI,GAAGnB,0BAAb;AACAA,IAAAA,0BAA0B,GAAG,IAA7B;AACA/B,IAAAA,wBAAwB,CAACkD,IAAD,CAAxB;AACD;;AACDL,EAAAA,0BAA0B;AAC3B;;AAED,SAASA,0BAAT,GAAsC;AACpC,MAAI,CAACb,mBAAD,IAAwBF,SAAS,KAAK,IAA1C,EAAgD;AAC9C;AACAE,IAAAA,mBAAmB,GAAG,IAAtB;AACA,QAAImB,CAAC,GAAG,CAAR;;AACA,QAAI;AACF,YAAMC,MAAM,GAAG,IAAf;AACA,YAAMC,KAAK,GAAGvB,SAAd;AACAQ,MAAAA,eAAe,CAACjB,iBAAD,EAAoB,MAAM;AACvC,eAAO8B,CAAC,GAAGE,KAAK,CAACC,MAAjB,EAAyBH,CAAC,EAA1B,EAA8B;AAC5B,cAAIT,QAAQ,GAAGW,KAAK,CAACF,CAAD,CAApB;;AACA,aAAG;AACDT,YAAAA,QAAQ,GAAGA,QAAQ,CAACU,MAAD,CAAnB;AACD,WAFD,QAESV,QAAQ,KAAK,IAFtB;AAGD;AACF,OAPc,CAAf;AAQAZ,MAAAA,SAAS,GAAG,IAAZ;AACD,KAZD,CAYE,OAAOyB,KAAP,EAAc;AACd;AACA,UAAIzB,SAAS,KAAK,IAAlB,EAAwB;AACtBA,QAAAA,SAAS,GAAGA,SAAS,CAAC0B,KAAV,CAAgBL,CAAC,GAAG,CAApB,CAAZ;AACD,OAJa,CAKd;;;AACArD,MAAAA,0BAA0B,CACxBY,2BADwB,EAExBuC,sBAFwB,CAA1B;AAIA,YAAMM,KAAN;AACD,KAvBD,SAuBU;AACRvB,MAAAA,mBAAmB,GAAG,KAAtB;AACD;AACF;AACF","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nimport {__interactionsRef} from 'scheduler/tracing';\nimport {enableSchedulerTracing} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\n\nconst {\n  unstable_runWithPriority: Scheduler_runWithPriority,\n  unstable_scheduleCallback: Scheduler_scheduleCallback,\n  unstable_cancelCallback: Scheduler_cancelCallback,\n  unstable_shouldYield: Scheduler_shouldYield,\n  unstable_requestPaint: Scheduler_requestPaint,\n  unstable_now: Scheduler_now,\n  unstable_getCurrentPriorityLevel: Scheduler_getCurrentPriorityLevel,\n  unstable_ImmediatePriority: Scheduler_ImmediatePriority,\n  unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,\n  unstable_NormalPriority: Scheduler_NormalPriority,\n  unstable_LowPriority: Scheduler_LowPriority,\n  unstable_IdlePriority: Scheduler_IdlePriority,\n} = Scheduler;\n\nif (enableSchedulerTracing) {\n  // Provide explicit error message when production+profiling bundle of e.g.\n  // react-dom is used with production (non-profiling) bundle of\n  // scheduler/tracing\n  invariant(\n    __interactionsRef != null && __interactionsRef.current != null,\n    'It is not supported to run the profiling version of a renderer (for ' +\n      'example, `react-dom/profiling`) without also replacing the ' +\n      '`scheduler/tracing` module with `scheduler/tracing-profiling`. Your ' +\n      'bundler might have a setting for aliasing both modules. Learn more at ' +\n      'http://fb.me/react-profiling',\n  );\n}\n\nexport type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;\nexport type SchedulerCallback = (isSync: boolean) => SchedulerCallback | null;\n\ntype SchedulerCallbackOptions = {timeout?: number, ...};\n\nconst fakeCallbackNode = {};\n\n// Except for NoPriority, these correspond to Scheduler priorities. We use\n// ascending numbers so we can compare them like numbers. They start at 90 to\n// avoid clashing with Scheduler's priorities.\nexport const ImmediatePriority: ReactPriorityLevel = 99;\nexport const UserBlockingPriority: ReactPriorityLevel = 98;\nexport const NormalPriority: ReactPriorityLevel = 97;\nexport const LowPriority: ReactPriorityLevel = 96;\nexport const IdlePriority: ReactPriorityLevel = 95;\n// NoPriority is the absence of priority. Also React-only.\nexport const NoPriority: ReactPriorityLevel = 90;\n\nexport const shouldYield = Scheduler_shouldYield;\nexport const requestPaint =\n  // Fall back gracefully if we're running an older version of Scheduler.\n  Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : () => {};\n\nlet syncQueue: Array<SchedulerCallback> | null = null;\nlet immediateQueueCallbackNode: mixed | null = null;\nlet isFlushingSyncQueue: boolean = false;\nlet initialTimeMs: number = Scheduler_now();\n\n// If the initial timestamp is reasonably small, use Scheduler's `now` directly.\n// This will be the case for modern browsers that support `performance.now`. In\n// older browsers, Scheduler falls back to `Date.now`, which returns a Unix\n// timestamp. In that case, subtract the module initialization time to simulate\n// the behavior of performance.now and keep our times small enough to fit\n// within 32 bits.\n// TODO: Consider lifting this into Scheduler.\nexport const now =\n  initialTimeMs < 10000 ? Scheduler_now : () => Scheduler_now() - initialTimeMs;\n\nexport function getCurrentPriorityLevel(): ReactPriorityLevel {\n  switch (Scheduler_getCurrentPriorityLevel()) {\n    // 99 立即执行的任务\n    case Scheduler_ImmediatePriority:\n      return ImmediatePriority;\n    // 98 用户交互任务\n    case Scheduler_UserBlockingPriority:\n      return UserBlockingPriority;\n    // 97 普通优先级\n    case Scheduler_NormalPriority:\n      return NormalPriority;\n    // 96 低优先级任务\n    case Scheduler_LowPriority:\n      return LowPriority;\n    // 95 闲时任务\n    case Scheduler_IdlePriority:\n      return IdlePriority;\n    default:\n      // 缺少优先级\n      invariant(false, 'Unknown priority level.');\n  }\n}\n\nfunction reactPriorityToSchedulerPriority(reactPriorityLevel) {\n  switch (reactPriorityLevel) {\n    case ImmediatePriority:\n      return Scheduler_ImmediatePriority;\n    case UserBlockingPriority:\n      return Scheduler_UserBlockingPriority;\n    case NormalPriority:\n      return Scheduler_NormalPriority;\n    case LowPriority:\n      return Scheduler_LowPriority;\n    case IdlePriority:\n      return Scheduler_IdlePriority;\n    default:\n      invariant(false, 'Unknown priority level.');\n  }\n}\n\nexport function runWithPriority<T>(\n  reactPriorityLevel: ReactPriorityLevel,\n  fn: () => T,\n): T {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_runWithPriority(priorityLevel, fn);\n}\n\nexport function scheduleCallback(\n  reactPriorityLevel: ReactPriorityLevel,\n  callback: SchedulerCallback,\n  options: SchedulerCallbackOptions | void | null,\n) {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_scheduleCallback(priorityLevel, callback, options);\n}\n\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n    // Flush the queue in the next tick, at the earliest.\n    immediateQueueCallbackNode = Scheduler_scheduleCallback(\n      Scheduler_ImmediatePriority,\n      flushSyncCallbackQueueImpl,\n    );\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n  return fakeCallbackNode;\n}\n\nexport function cancelCallback(callbackNode: mixed) {\n  if (callbackNode !== fakeCallbackNode) {\n    Scheduler_cancelCallback(callbackNode);\n  }\n}\n\nexport function flushSyncCallbackQueue() {\n  if (immediateQueueCallbackNode !== null) {\n    const node = immediateQueueCallbackNode;\n    immediateQueueCallbackNode = null;\n    Scheduler_cancelCallback(node);\n  }\n  flushSyncCallbackQueueImpl();\n}\n\nfunction flushSyncCallbackQueueImpl() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrancy.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      runWithPriority(ImmediatePriority, () => {\n        for (; i < queue.length; i++) {\n          let callback = queue[i];\n          do {\n            callback = callback(isSync);\n          } while (callback !== null);\n        }\n      });\n      syncQueue = null;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      Scheduler_scheduleCallback(\n        Scheduler_ImmediatePriority,\n        flushSyncCallbackQueue,\n      );\n      throw error;\n    } finally {\n      isFlushingSyncQueue = false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}