{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport { REACT_ELEMENT_TYPE } from 'shared/ReactSymbols';\nimport ReactCurrentOwner from './ReactCurrentOwner';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nlet specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\nif (__DEV__) {\n  didWarnAboutStringRefs = {};\n}\n/**\n * 查看参数对象中是否有合法的 ref 属性\n * 返回布尔值\n */\n\n\nfunction hasValidRef(config) {\n  // 在开发环境下\n  if (__DEV__) {\n    // 查看 config 对象的自有属性中是否有 ref 属性\n    if (hasOwnProperty.call(config, 'ref')) {\n      // 获取 ref 属性的属性描述符中的 get\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n/**\n * 查看参数对象中是否有合法的 key 属性\n * 返回布尔值\n */\n\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n/**\n *  指定当通过 props 对象获取 key 属性时报错\n *  props        组件中的 props 对象\n *  displayName  组件名称标识\n */\n\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  // 通过 props 对象获取 key 属性报错\n  const warnAboutAccessingKey = function () {\n    // 在开发环境中\n    if (__DEV__) {\n      // specialPropKeyWarningShown 控制错误只输出一次的变量\n      if (!specialPropKeyWarningShown) {\n        // 通过 specialPropKeyWarningShown 变量锁住判断条件\n        specialPropKeyWarningShown = true; // 指定报错信息和组件名称\n\n        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true; // 为 props 对象添加 key 属性\n\n  Object.defineProperty(props, 'key', {\n    // 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n/**\n *  指定当通过 props 对象获取 ref 属性时报错\n *  props        组件中的 props 对象\n *  displayName  组件名称标识\n */\n\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  // 通过 props 对象获取 ref 属性报错\n  const warnAboutAccessingRef = function () {\n    if (__DEV__) {\n      // specialPropRefWarningShown 控制错误只输出一次的变量\n      if (!specialPropRefWarningShown) {\n        // 通过 specialPropRefWarningShown 变量锁住判断条件\n        specialPropRefWarningShown = true; // 指定报错信息和组件名称\n\n        console.error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true; // 为 props 对象添加 key 属性\n\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n/**\n * 在开发环境中如果 ref 属性接收的值为字符串 报警告\n */\n\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  // 在开发环境下\n  if (__DEV__) {\n    // 如果 ref 属性的值是字符串类型\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      const componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        console.error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * 接收参数 返回 ReactElement\n */\n\n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  const element = {\n    /**\n     * 组件的类型, 十六进制数值或者 Symbol 值\n     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE\n     * 需要此属性作为判断的依据\n     */\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    /**\n     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等\n     * 如果元素是组件 type 属性中存储的就是组件的构造函数\n     */\n    type: type,\n\n    /**\n     * 元素的唯一标识\n     * 用作内部 vdom 比对 提升 DOM 操作性能\n     */\n    key: key,\n\n    /**\n     * 存储元素 DOM 对象或者组件 实例对象\n     */\n    ref: ref,\n\n    /**\n     * 存储向组件内部传递的数据\n     */\n    props: props,\n\n    /**\n     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)\n     */\n    _owner: owner\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  } // 返回 ReactElement\n\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\n\nexport function jsx(type, config, maybeKey) {\n  let propName; // Reserved names are extracted\n\n  const props = {};\n  let key = null;\n  let ref = null; // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n\n  if (maybeKey !== undefined) {\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  } // Remaining properties are added to a new props object\n\n\n  for (propName in config) {\n    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n      props[propName] = config[propName];\n    }\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, undefined, undefined, ReactCurrentOwner.current, props);\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nexport function jsxDEV(type, config, maybeKey, source, self) {\n  let propName; // Reserved names are extracted\n\n  const props = {};\n  let key = null;\n  let ref = null; // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n\n  if (maybeKey !== undefined) {\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n    warnIfStringRefCannotBeAutoConverted(config);\n  } // Remaining properties are added to a new props object\n\n\n  for (propName in config) {\n    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n      props[propName] = config[propName];\n    }\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (key || ref) {\n    const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n    if (key) {\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    if (ref) {\n      defineRefPropWarningGetter(props, displayName);\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\n/**\n * 创建 React Element\n * type      元素类型\n * config    配置属性\n * children  子元素\n * 1. 分离 props 属性和特殊属性\n * 2. 将子元素挂载到 props.children 中\n * 3. 为 props 属性赋默认值 (defaultProps)\n * 4. 创建并返回 ReactElement\n */\n\nexport function createElement(type, config, children) {\n  /**\n   * propName -> 属性名称\n   * 用于后面的 for 循环\n   */\n  let propName;\n  /**\n   * 存储 React Element 中的普通元素属性 即不包含 key ref self source\n   */\n\n  const props = {};\n  /**\n   * 待提取属性\n   * React 内部为了实现某些功能而存在的属性\n   */\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null; // 如果 config 不为 null\n\n  if (config != null) {\n    // 如果 config 对象中有合法的 ref 属性\n    if (hasValidRef(config)) {\n      // 将 config.ref 属性提取到 ref 变量中\n      ref = config.ref; // 在开发环境中\n\n      if (__DEV__) {\n        // 如果 ref 属性的值被设置成了字符串形式就报一个提示\n        // 说明此用法在将来的版本中会被删除\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    } // 如果在 config 对象中拥有合法的 key 属性\n\n\n    if (hasValidKey(config)) {\n      // 将 config.key 属性中的值提取到 key 变量中\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // 遍历 config 对象\n\n    for (propName in config) {\n      // 如果当前遍历到的属性是对象自身属性\n      // 并且在 RESERVED_PROPS 对象中不存在该属性\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        // 将满足条件的属性添加到 props 对象中 (普通属性)\n        props[propName] = config[propName];\n      }\n    }\n  }\n  /**\n   * 将第三个及之后的参数挂载到 props.children 属性中\n   * 如果子元素是多个 props.children 是数组\n   * 如果子元素是一个 props.children 是对象\n   */\n  // 由于从第三个参数开始及以后都表示子元素\n  // 所以减去前两个参数的结果就是子元素的数量\n\n\n  const childrenLength = arguments.length - 2; // 如果子元素的数量是 1\n\n  if (childrenLength === 1) {\n    // 直接将子元素挂载到到 props.children 属性上\n    // 此时 children 是对象类型\n    props.children = children; // 如果子元素的数量大于 1\n  } else if (childrenLength > 1) {\n    // 创建数组, 数组中元素的数量等于子元素的数量\n    const childArray = Array(childrenLength); // 开启循环 循环次匹配子元素的数量\n\n    for (let i = 0; i < childrenLength; i++) {\n      // 将子元素添加到 childArray 数组中\n      // i + 2 的原因是实参集合的前两个参数不是子元素\n      childArray[i] = arguments[i + 2];\n    } // 如果是开发环境\n\n\n    if (__DEV__) {\n      // 如果 Object 对象中存在 freeze 方法\n      if (Object.freeze) {\n        // 调用 freeze 方法 冻结 childArray 数组\n        // 防止 React 核心对象被修改 冻结对象提高性能\n        Object.freeze(childArray);\n      }\n    } // 将子元素数组挂载到 props.children 属性中\n\n\n    props.children = childArray;\n  }\n  /**\n   * 如果当前处理是组件\n   * 看组件身上是否有 defaultProps 属性\n   * 这个属性中存储的是 props 对象中属性的默认值\n   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined\n   * 如果为undefined 就将默认值赋值给对应的 props 属性值\n   */\n  // 将 type 属性值视为函数 查看其中是否具有 defaultProps 属性\n\n\n  if (type && type.defaultProps) {\n    // 将 type 函数下的 defaultProps 属性赋值给 defaultProps 变量\n    const defaultProps = type.defaultProps; // 遍历 defaultProps 对象中的属性 将属性名称赋值给 propName 变量\n\n    for (propName in defaultProps) {\n      // 如果 props 对象中的该属性的值为 undefined\n      if (props[propName] === undefined) {\n        // 将 defaultProps 对象中的对应属性的值赋值给 props 对象中的对应属性的值\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  /**\n   * 在开发环境中 React 会检测开发者是否在组件内部\n   * 通过 props 对象获取 key 属性或者 ref 属性\n   * 如果开发者调用了 在控制台中报错误提示\n   */\n  // 如果处于开发环境\n\n\n  if (__DEV__) {\n    // 元素具有 key 属性或者 ref 属性\n    if (key || ref) {\n      // 看一下 type 属性中存储的是否是函数 如果是函数就表示当前元素是组件\n      // 如果元素不是组件 就直接返回元素类型字符串\n      // displayName 用于在报错过程中显示是哪一个组件报错了\n      // 如果开发者显式定义了 displayName 属性 就显示开发者定义的\n      // 否者就显示组件名称 如果组件也没有名称 就显示 'Unknown'\n      const displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type; // 如果 key 属性存在\n\n      if (key) {\n        // 为 props 对象添加key 属性\n        // 并指定当通过 props 对象获取 key 属性时报错\n        defineKeyPropWarningGetter(props, displayName);\n      } // 如果 ref 属性存在\n\n\n      if (ref) {\n        // 为 props 对象添加 ref 属性\n        // 并指定当通过 props 对象获取 ref 属性时报错\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  } // 返回 ReactElement\n\n\n  return ReactElement(type, key, ref, self, source, // 在 Virtual DOM 中用于识别自定义组件\n  ReactCurrentOwner.current, props);\n}\n/**\n * 此方法在 React 对象中进行导出 但官方已经不推荐使用\n * 作用是返回一个函数 用于根据给定的类型创建 ReactElement\n * 官方推荐直接使用 JSX 或者 React.createElement 方法直接创建 ReactElement\n */\n\nexport function createFactory(type) {\n  const factory = createElement.bind(null, type); // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook: remove it\n\n  factory.type = type;\n  return factory;\n}\n/**\n * 克隆 ReactElement 并替换新 key\n */\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * 克隆 ReactElement\n * 返回新的 ReactElement\n */\n\nexport function cloneElement(element, config, children) {\n  // 如果 element 参数为 null 或者 undefined 报错\n  invariant(!(element === null || element === undefined), 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element);\n  let propName; // 获取原有 element 身上的属性\n\n  const props = Object.assign({}, element.props); // Reserved names are extracted\n\n  let key = element.key;\n  let ref = element.ref; // Self is preserved since the owner is preserved.\n\n  const self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  const source = element._source; // Owner will be preserved, unless ref is overridden\n\n  let owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    let defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  const childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * 验证 object 参数是否是 ReactElement. 返回布尔值\n * 验证成功的条件:\n * object 是对象\n * object 不为 null\n * object 对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE\n */\n\nexport function isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react/src/ReactElement.js"],"names":["getComponentName","invariant","REACT_ELEMENT_TYPE","ReactCurrentOwner","hasOwnProperty","Object","prototype","RESERVED_PROPS","key","ref","__self","__source","specialPropKeyWarningShown","specialPropRefWarningShown","didWarnAboutStringRefs","__DEV__","hasValidRef","config","call","getter","getOwnPropertyDescriptor","get","isReactWarning","undefined","hasValidKey","defineKeyPropWarningGetter","props","displayName","warnAboutAccessingKey","console","error","defineProperty","configurable","defineRefPropWarningGetter","warnAboutAccessingRef","warnIfStringRefCannotBeAutoConverted","current","stateNode","componentName","type","ReactElement","self","source","owner","element","$$typeof","_owner","_store","enumerable","writable","value","freeze","jsx","maybeKey","propName","defaultProps","jsxDEV","name","createElement","children","childrenLength","arguments","length","childArray","Array","i","createFactory","factory","bind","cloneAndReplaceKey","oldElement","newKey","newElement","_self","_source","cloneElement","assign","isValidElement","object"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport {REACT_ELEMENT_TYPE} from 'shared/ReactSymbols';\n\nimport ReactCurrentOwner from './ReactCurrentOwner';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true,\n};\n\nlet specialPropKeyWarningShown,\n  specialPropRefWarningShown,\n  didWarnAboutStringRefs;\n\nif (__DEV__) {\n  didWarnAboutStringRefs = {};\n}\n\n/**\n * 查看参数对象中是否有合法的 ref 属性\n * 返回布尔值\n */\nfunction hasValidRef(config) {\n  // 在开发环境下\n  if (__DEV__) {\n    // 查看 config 对象的自有属性中是否有 ref 属性\n    if (hasOwnProperty.call(config, 'ref')) {\n      // 获取 ref 属性的属性描述符中的 get\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n/**\n * 查看参数对象中是否有合法的 key 属性\n * 返回布尔值\n */\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\n/**\n *  指定当通过 props 对象获取 key 属性时报错\n *  props        组件中的 props 对象\n *  displayName  组件名称标识\n */\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  // 通过 props 对象获取 key 属性报错\n  const warnAboutAccessingKey = function () {\n    // 在开发环境中\n    if (__DEV__) {\n      // specialPropKeyWarningShown 控制错误只输出一次的变量\n      if (!specialPropKeyWarningShown) {\n        // 通过 specialPropKeyWarningShown 变量锁住判断条件\n        specialPropKeyWarningShown = true;\n        // 指定报错信息和组件名称\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://reactjs.org/link/special-props)',\n          displayName,\n        );\n      }\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  // 为 props 对象添加 key 属性\n  Object.defineProperty(props, 'key', {\n    // 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错\n    get: warnAboutAccessingKey,\n    configurable: true,\n  });\n}\n\n/**\n *  指定当通过 props 对象获取 ref 属性时报错\n *  props        组件中的 props 对象\n *  displayName  组件名称标识\n */\nfunction defineRefPropWarningGetter(props, displayName) {\n  // 通过 props 对象获取 ref 属性报错\n  const warnAboutAccessingRef = function () {\n    if (__DEV__) {\n      // specialPropRefWarningShown 控制错误只输出一次的变量\n      if (!specialPropRefWarningShown) {\n        // 通过 specialPropRefWarningShown 变量锁住判断条件\n        specialPropRefWarningShown = true;\n        // 指定报错信息和组件名称\n        console.error(\n          '%s: `ref` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://reactjs.org/link/special-props)',\n          displayName,\n        );\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  // 为 props 对象添加 key 属性\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true,\n  });\n}\n\n/**\n * 在开发环境中如果 ref 属性接收的值为字符串 报警告\n */\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  // 在开发环境下\n  if (__DEV__) {\n    // 如果 ref 属性的值是字符串类型\n    if (\n      typeof config.ref === 'string' &&\n      ReactCurrentOwner.current &&\n      config.__self &&\n      ReactCurrentOwner.current.stateNode !== config.__self\n    ) {\n      const componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        console.error(\n          'Component \"%s\" contains the string ref \"%s\". ' +\n            'Support for string refs will be removed in a future major release. ' +\n            'This case cannot be automatically converted to an arrow function. ' +\n            'We ask you to manually fix this case by using useRef() or createRef() instead. ' +\n            'Learn more about using refs safely here: ' +\n            'https://reactjs.org/link/strict-mode-string-ref',\n          componentName,\n          config.ref,\n        );\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\n/**\n * 接收参数 返回 ReactElement\n */\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  const element = {\n    /**\n     * 组件的类型, 十六进制数值或者 Symbol 值\n     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE\n     * 需要此属性作为判断的依据\n     */\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    /**\n     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等\n     * 如果元素是组件 type 属性中存储的就是组件的构造函数\n     */\n    type: type,\n    /**\n     * 元素的唯一标识\n     * 用作内部 vdom 比对 提升 DOM 操作性能\n     */\n    key: key,\n    /**\n     * 存储元素 DOM 对象或者组件 实例对象\n     */\n    ref: ref,\n    /**\n     * 存储向组件内部传递的数据\n     */\n    props: props,\n\n    /**\n     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)\n     */\n    _owner: owner,\n  };\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false,\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self,\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n  // 返回 ReactElement\n  return element;\n};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsx(type, config, maybeKey) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n  }\n\n  // Remaining properties are added to a new props object\n  for (propName in config) {\n    if (\n      hasOwnProperty.call(config, propName) &&\n      !RESERVED_PROPS.hasOwnProperty(propName)\n    ) {\n      props[propName] = config[propName];\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    undefined,\n    undefined,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, source, self) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    key = '' + config.key;\n  }\n\n  if (hasValidRef(config)) {\n    ref = config.ref;\n    warnIfStringRefCannotBeAutoConverted(config);\n  }\n\n  // Remaining properties are added to a new props object\n  for (propName in config) {\n    if (\n      hasOwnProperty.call(config, propName) &&\n      !RESERVED_PROPS.hasOwnProperty(propName)\n    ) {\n      props[propName] = config[propName];\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (key || ref) {\n    const displayName =\n      typeof type === 'function'\n        ? type.displayName || type.name || 'Unknown'\n        : type;\n    if (key) {\n      defineKeyPropWarningGetter(props, displayName);\n    }\n    if (ref) {\n      defineRefPropWarningGetter(props, displayName);\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\n/**\n * 创建 React Element\n * type      元素类型\n * config    配置属性\n * children  子元素\n * 1. 分离 props 属性和特殊属性\n * 2. 将子元素挂载到 props.children 中\n * 3. 为 props 属性赋默认值 (defaultProps)\n * 4. 创建并返回 ReactElement\n */\nexport function createElement(type, config, children) {\n  /**\n   * propName -> 属性名称\n   * 用于后面的 for 循环\n   */\n  let propName;\n\n  /**\n   * 存储 React Element 中的普通元素属性 即不包含 key ref self source\n   */\n  const props = {};\n\n  /**\n   * 待提取属性\n   * React 内部为了实现某些功能而存在的属性\n   */\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  // 如果 config 不为 null\n  if (config != null) {\n    // 如果 config 对象中有合法的 ref 属性\n    if (hasValidRef(config)) {\n      // 将 config.ref 属性提取到 ref 变量中\n      ref = config.ref;\n      // 在开发环境中\n      if (__DEV__) {\n        // 如果 ref 属性的值被设置成了字符串形式就报一个提示\n        // 说明此用法在将来的版本中会被删除\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n    // 如果在 config 对象中拥有合法的 key 属性\n    if (hasValidKey(config)) {\n      // 将 config.key 属性中的值提取到 key 变量中\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // 遍历 config 对象\n    for (propName in config) {\n      // 如果当前遍历到的属性是对象自身属性\n      // 并且在 RESERVED_PROPS 对象中不存在该属性\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        // 将满足条件的属性添加到 props 对象中 (普通属性)\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  /**\n   * 将第三个及之后的参数挂载到 props.children 属性中\n   * 如果子元素是多个 props.children 是数组\n   * 如果子元素是一个 props.children 是对象\n   */\n\n  // 由于从第三个参数开始及以后都表示子元素\n  // 所以减去前两个参数的结果就是子元素的数量\n  const childrenLength = arguments.length - 2;\n  // 如果子元素的数量是 1\n  if (childrenLength === 1) {\n    // 直接将子元素挂载到到 props.children 属性上\n    // 此时 children 是对象类型\n    props.children = children;\n    // 如果子元素的数量大于 1\n  } else if (childrenLength > 1) {\n    // 创建数组, 数组中元素的数量等于子元素的数量\n    const childArray = Array(childrenLength);\n    // 开启循环 循环次匹配子元素的数量\n    for (let i = 0; i < childrenLength; i++) {\n      // 将子元素添加到 childArray 数组中\n      // i + 2 的原因是实参集合的前两个参数不是子元素\n      childArray[i] = arguments[i + 2];\n    }\n    // 如果是开发环境\n    if (__DEV__) {\n      // 如果 Object 对象中存在 freeze 方法\n      if (Object.freeze) {\n        // 调用 freeze 方法 冻结 childArray 数组\n        // 防止 React 核心对象被修改 冻结对象提高性能\n        Object.freeze(childArray);\n      }\n    }\n    // 将子元素数组挂载到 props.children 属性中\n    props.children = childArray;\n  }\n\n  /**\n   * 如果当前处理是组件\n   * 看组件身上是否有 defaultProps 属性\n   * 这个属性中存储的是 props 对象中属性的默认值\n   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined\n   * 如果为undefined 就将默认值赋值给对应的 props 属性值\n   */\n\n  // 将 type 属性值视为函数 查看其中是否具有 defaultProps 属性\n  if (type && type.defaultProps) {\n    // 将 type 函数下的 defaultProps 属性赋值给 defaultProps 变量\n    const defaultProps = type.defaultProps;\n    // 遍历 defaultProps 对象中的属性 将属性名称赋值给 propName 变量\n    for (propName in defaultProps) {\n      // 如果 props 对象中的该属性的值为 undefined\n      if (props[propName] === undefined) {\n        // 将 defaultProps 对象中的对应属性的值赋值给 props 对象中的对应属性的值\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  /**\n   * 在开发环境中 React 会检测开发者是否在组件内部\n   * 通过 props 对象获取 key 属性或者 ref 属性\n   * 如果开发者调用了 在控制台中报错误提示\n   */\n\n  // 如果处于开发环境\n  if (__DEV__) {\n    // 元素具有 key 属性或者 ref 属性\n    if (key || ref) {\n      // 看一下 type 属性中存储的是否是函数 如果是函数就表示当前元素是组件\n      // 如果元素不是组件 就直接返回元素类型字符串\n      // displayName 用于在报错过程中显示是哪一个组件报错了\n      // 如果开发者显式定义了 displayName 属性 就显示开发者定义的\n      // 否者就显示组件名称 如果组件也没有名称 就显示 'Unknown'\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      // 如果 key 属性存在\n      if (key) {\n        // 为 props 对象添加key 属性\n        // 并指定当通过 props 对象获取 key 属性时报错\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      // 如果 ref 属性存在\n      if (ref) {\n        // 为 props 对象添加 ref 属性\n        // 并指定当通过 props 对象获取 ref 属性时报错\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n  // 返回 ReactElement\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    // 在 Virtual DOM 中用于识别自定义组件\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n/**\n * 此方法在 React 对象中进行导出 但官方已经不推荐使用\n * 作用是返回一个函数 用于根据给定的类型创建 ReactElement\n * 官方推荐直接使用 JSX 或者 React.createElement 方法直接创建 ReactElement\n */\nexport function createFactory(type) {\n  const factory = createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. `<Foo />.type === Foo`.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  // Legacy hook: remove it\n  factory.type = type;\n  return factory;\n}\n\n/**\n * 克隆 ReactElement 并替换新 key\n */\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const newElement = ReactElement(\n    oldElement.type,\n    newKey,\n    oldElement.ref,\n    oldElement._self,\n    oldElement._source,\n    oldElement._owner,\n    oldElement.props,\n  );\n\n  return newElement;\n}\n\n/**\n * 克隆 ReactElement\n * 返回新的 ReactElement\n */\nexport function cloneElement(element, config, children) {\n  // 如果 element 参数为 null 或者 undefined 报错\n  invariant(\n    !(element === null || element === undefined),\n    'React.cloneElement(...): The argument must be a React element, but you passed %s.',\n    element,\n  );\n\n  let propName;\n\n  // 获取原有 element 身上的属性\n  const props = Object.assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n  let ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  const self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  const source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    let defaultProps;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * 验证 object 参数是否是 ReactElement. 返回布尔值\n * 验证成功的条件:\n * object 是对象\n * object 不为 null\n * object 对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n"]},"metadata":{},"sourceType":"module"}