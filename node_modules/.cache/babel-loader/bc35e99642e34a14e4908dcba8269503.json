{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { HostRoot, HostComponent, HostText } from 'shared/ReactWorkTags';\nimport { IS_FIRST_ANCESTOR } from 'legacy-events/EventSystemFlags';\nimport { batchedEventUpdates } from 'legacy-events/ReactGenericBatching';\nimport { runEventsInBatch } from 'legacy-events/EventBatching';\nimport { plugins } from 'legacy-events/EventPluginRegistry';\nimport accumulateInto from 'legacy-events/accumulateInto';\nimport { registrationNameDependencies } from 'legacy-events/EventPluginRegistry';\nimport getEventTarget from './getEventTarget';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { trapCapturedEvent, trapBubbledEvent } from './ReactDOMEventListener';\nimport { getListenerMapForElement } from './DOMEventListenerMap';\nimport isEventSupported from './isEventSupported';\nimport { TOP_BLUR, TOP_CANCEL, TOP_CLOSE, TOP_FOCUS, TOP_INVALID, TOP_RESET, TOP_SCROLL, TOP_SUBMIT, getRawEventName, mediaEventTypes } from './DOMTopLevelEventTypes';\n/**\n * Summary of `DOMEventPluginSystem` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginRegistry`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginRegistry` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginRegistry` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|PluginRegistry|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nconst CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nconst callbackBookkeepingPool = [];\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n} // Used to store ancestor hierarchy in top level callback\n\n\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags) {\n  if (callbackBookkeepingPool.length) {\n    const instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.eventSystemFlags = eventSystemFlags;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n\n  return {\n    topLevelType,\n    eventSystemFlags,\n    nativeEvent,\n    targetInst,\n    ancestors: []\n  };\n}\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\n\n\nfunction findRootContainerNode(inst) {\n  if (inst.tag === HostRoot) {\n    return inst.stateNode.containerInfo;\n  } // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n\n\n  while (inst.return) {\n    inst = inst.return;\n  }\n\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n\n  return inst.stateNode.containerInfo;\n}\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\n\n\nfunction extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  let events = null;\n\n  for (let i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    const possiblePlugin = plugins[i];\n\n    if (possiblePlugin) {\n      const extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n\n  return events;\n}\n\nfunction runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  const events = extractPluginEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n  runEventsInBatch(events);\n}\n\nfunction handleTopLevel(bookKeeping) {\n  let targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n\n  let ancestor = targetInst;\n\n  do {\n    if (!ancestor) {\n      const ancestors = bookKeeping.ancestors;\n      ancestors.push(ancestor);\n      break;\n    }\n\n    const root = findRootContainerNode(ancestor);\n\n    if (!root) {\n      break;\n    }\n\n    const tag = ancestor.tag;\n\n    if (tag === HostComponent || tag === HostText) {\n      bookKeeping.ancestors.push(ancestor);\n    }\n\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (let i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    const eventTarget = getEventTarget(bookKeeping.nativeEvent);\n    const topLevelType = bookKeeping.topLevelType;\n    const nativeEvent = bookKeeping.nativeEvent;\n    let eventSystemFlags = bookKeeping.eventSystemFlags; // If this is the first ancestor, we mark it on the system flags\n\n    if (i === 0) {\n      eventSystemFlags |= IS_FIRST_ANCESTOR;\n    }\n\n    runExtractedPluginEventsInBatch(topLevelType, targetInst, nativeEvent, eventTarget, eventSystemFlags);\n  }\n}\n\nexport function dispatchEventForLegacyPluginEventSystem(topLevelType, eventSystemFlags, nativeEvent, targetInst) {\n  const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst, eventSystemFlags);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\n\nexport function legacyListenToEvent(registrationName, mountAt) {\n  const listenerMap = getListenerMapForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    legacyListenToTopLevelEvent(dependency, mountAt, listenerMap);\n  }\n}\nexport function legacyListenToTopLevelEvent(topLevelType, mountAt, listenerMap) {\n  if (!listenerMap.has(topLevelType)) {\n    switch (topLevelType) {\n      case TOP_SCROLL:\n        trapCapturedEvent(TOP_SCROLL, mountAt);\n        break;\n\n      case TOP_FOCUS:\n      case TOP_BLUR:\n        trapCapturedEvent(TOP_FOCUS, mountAt);\n        trapCapturedEvent(TOP_BLUR, mountAt); // We set the flag for a single dependency later in this function,\n        // but this ensures we mark both as attached rather than just one.\n\n        listenerMap.set(TOP_BLUR, null);\n        listenerMap.set(TOP_FOCUS, null);\n        break;\n\n      case TOP_CANCEL:\n      case TOP_CLOSE:\n        if (isEventSupported(getRawEventName(topLevelType))) {\n          trapCapturedEvent(topLevelType, mountAt);\n        }\n\n        break;\n\n      case TOP_INVALID:\n      case TOP_SUBMIT:\n      case TOP_RESET:\n        // We listen to them on the target DOM elements.\n        // Some of them bubble so we don't want them to fire twice.\n        break;\n\n      default:\n        // By default, listen on the top level to all non-media events.\n        // Media events don't bubble so adding the listener wouldn't do anything.\n        const isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -1;\n\n        if (!isMediaEvent) {\n          trapBubbledEvent(topLevelType, mountAt);\n        }\n\n        break;\n    }\n\n    listenerMap.set(topLevelType, null);\n  }\n}\nexport function isListeningToAllDependencies(registrationName, mountAt) {\n  const listenerMap = getListenerMapForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n\n    if (!listenerMap.has(dependency)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-dom/src/events/DOMLegacyEventPluginSystem.js"],"names":["HostRoot","HostComponent","HostText","IS_FIRST_ANCESTOR","batchedEventUpdates","runEventsInBatch","plugins","accumulateInto","registrationNameDependencies","getEventTarget","getClosestInstanceFromNode","trapCapturedEvent","trapBubbledEvent","getListenerMapForElement","isEventSupported","TOP_BLUR","TOP_CANCEL","TOP_CLOSE","TOP_FOCUS","TOP_INVALID","TOP_RESET","TOP_SCROLL","TOP_SUBMIT","getRawEventName","mediaEventTypes","CALLBACK_BOOKKEEPING_POOL_SIZE","callbackBookkeepingPool","releaseTopLevelCallbackBookKeeping","instance","topLevelType","nativeEvent","targetInst","ancestors","length","push","getTopLevelCallbackBookKeeping","eventSystemFlags","pop","findRootContainerNode","inst","tag","stateNode","containerInfo","return","extractPluginEvents","nativeEventTarget","events","i","possiblePlugin","extractedEvents","extractEvents","runExtractedPluginEventsInBatch","handleTopLevel","bookKeeping","ancestor","root","eventTarget","dispatchEventForLegacyPluginEventSystem","legacyListenToEvent","registrationName","mountAt","listenerMap","dependencies","dependency","legacyListenToTopLevelEvent","has","set","isMediaEvent","indexOf","isListeningToAllDependencies"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport type {EventSystemFlags} from 'legacy-events/EventSystemFlags';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport type {PluginModule} from 'legacy-events/PluginModuleType';\nimport type {ReactSyntheticEvent} from 'legacy-events/ReactSyntheticEventType';\nimport type {TopLevelType} from 'legacy-events/TopLevelEventTypes';\n\nimport {HostRoot, HostComponent, HostText} from 'shared/ReactWorkTags';\nimport {IS_FIRST_ANCESTOR} from 'legacy-events/EventSystemFlags';\nimport {batchedEventUpdates} from 'legacy-events/ReactGenericBatching';\nimport {runEventsInBatch} from 'legacy-events/EventBatching';\nimport {plugins} from 'legacy-events/EventPluginRegistry';\nimport accumulateInto from 'legacy-events/accumulateInto';\nimport {registrationNameDependencies} from 'legacy-events/EventPluginRegistry';\n\nimport getEventTarget from './getEventTarget';\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport {trapCapturedEvent, trapBubbledEvent} from './ReactDOMEventListener';\nimport {getListenerMapForElement} from './DOMEventListenerMap';\nimport isEventSupported from './isEventSupported';\nimport {\n  TOP_BLUR,\n  TOP_CANCEL,\n  TOP_CLOSE,\n  TOP_FOCUS,\n  TOP_INVALID,\n  TOP_RESET,\n  TOP_SCROLL,\n  TOP_SUBMIT,\n  getRawEventName,\n  mediaEventTypes,\n} from './DOMTopLevelEventTypes';\n\n/**\n * Summary of `DOMEventPluginSystem` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginRegistry`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginRegistry` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginRegistry` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|PluginRegistry|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nconst CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nconst callbackBookkeepingPool = [];\n\ntype BookKeepingInstance = {|\n  topLevelType: DOMTopLevelEventType | null,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent | null,\n  targetInst: Fiber | null,\n  ancestors: Array<Fiber | null>,\n|};\n\nfunction releaseTopLevelCallbackBookKeeping(\n  instance: BookKeepingInstance,\n): void {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(\n  topLevelType: DOMTopLevelEventType,\n  nativeEvent: AnyNativeEvent,\n  targetInst: Fiber | null,\n  eventSystemFlags: EventSystemFlags,\n): BookKeepingInstance {\n  if (callbackBookkeepingPool.length) {\n    const instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.eventSystemFlags = eventSystemFlags;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType,\n    eventSystemFlags,\n    nativeEvent,\n    targetInst,\n    ancestors: [],\n  };\n}\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  if (inst.tag === HostRoot) {\n    return inst.stateNode.containerInfo;\n  }\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst.return) {\n    inst = inst.return;\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractPluginEvents(\n  topLevelType: TopLevelType,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n): Array<ReactSyntheticEvent> | ReactSyntheticEvent | null {\n  let events = null;\n  for (let i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    const possiblePlugin: PluginModule<AnyNativeEvent> = plugins[i];\n    if (possiblePlugin) {\n      const extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget,\n        eventSystemFlags,\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runExtractedPluginEventsInBatch(\n  topLevelType: TopLevelType,\n  targetInst: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: null | EventTarget,\n  eventSystemFlags: EventSystemFlags,\n) {\n  const events = extractPluginEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget,\n    eventSystemFlags,\n  );\n  runEventsInBatch(events);\n}\n\nfunction handleTopLevel(bookKeeping: BookKeepingInstance) {\n  let targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  let ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      const ancestors = bookKeeping.ancestors;\n      ((ancestors: any): Array<Fiber | null>).push(ancestor);\n      break;\n    }\n    const root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    const tag = ancestor.tag;\n    if (tag === HostComponent || tag === HostText) {\n      bookKeeping.ancestors.push(ancestor);\n    }\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (let i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    const eventTarget = getEventTarget(bookKeeping.nativeEvent);\n    const topLevelType = ((bookKeeping.topLevelType: any): DOMTopLevelEventType);\n    const nativeEvent = ((bookKeeping.nativeEvent: any): AnyNativeEvent);\n    let eventSystemFlags = bookKeeping.eventSystemFlags;\n\n    // If this is the first ancestor, we mark it on the system flags\n    if (i === 0) {\n      eventSystemFlags |= IS_FIRST_ANCESTOR;\n    }\n\n    runExtractedPluginEventsInBatch(\n      topLevelType,\n      targetInst,\n      nativeEvent,\n      eventTarget,\n      eventSystemFlags,\n    );\n  }\n}\n\nexport function dispatchEventForLegacyPluginEventSystem(\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetInst: null | Fiber,\n): void {\n  const bookKeeping = getTopLevelCallbackBookKeeping(\n    topLevelType,\n    nativeEvent,\n    targetInst,\n    eventSystemFlags,\n  );\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\nexport function legacyListenToEvent(\n  registrationName: string,\n  mountAt: Document | Element | Node,\n): void {\n  const listenerMap = getListenerMapForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    legacyListenToTopLevelEvent(dependency, mountAt, listenerMap);\n  }\n}\n\nexport function legacyListenToTopLevelEvent(\n  topLevelType: DOMTopLevelEventType,\n  mountAt: Document | Element | Node,\n  listenerMap: Map<DOMTopLevelEventType | string, null | (any => void)>,\n): void {\n  if (!listenerMap.has(topLevelType)) {\n    switch (topLevelType) {\n      case TOP_SCROLL:\n        trapCapturedEvent(TOP_SCROLL, mountAt);\n        break;\n      case TOP_FOCUS:\n      case TOP_BLUR:\n        trapCapturedEvent(TOP_FOCUS, mountAt);\n        trapCapturedEvent(TOP_BLUR, mountAt);\n        // We set the flag for a single dependency later in this function,\n        // but this ensures we mark both as attached rather than just one.\n        listenerMap.set(TOP_BLUR, null);\n        listenerMap.set(TOP_FOCUS, null);\n        break;\n      case TOP_CANCEL:\n      case TOP_CLOSE:\n        if (isEventSupported(getRawEventName(topLevelType))) {\n          trapCapturedEvent(topLevelType, mountAt);\n        }\n        break;\n      case TOP_INVALID:\n      case TOP_SUBMIT:\n      case TOP_RESET:\n        // We listen to them on the target DOM elements.\n        // Some of them bubble so we don't want them to fire twice.\n        break;\n      default:\n        // By default, listen on the top level to all non-media events.\n        // Media events don't bubble so adding the listener wouldn't do anything.\n        const isMediaEvent = mediaEventTypes.indexOf(topLevelType) !== -1;\n        if (!isMediaEvent) {\n          trapBubbledEvent(topLevelType, mountAt);\n        }\n        break;\n    }\n    listenerMap.set(topLevelType, null);\n  }\n}\n\nexport function isListeningToAllDependencies(\n  registrationName: string,\n  mountAt: Document | Element,\n): boolean {\n  const listenerMap = getListenerMapForElement(mountAt);\n  const dependencies = registrationNameDependencies[registrationName];\n\n  for (let i = 0; i < dependencies.length; i++) {\n    const dependency = dependencies[i];\n    if (!listenerMap.has(dependency)) {\n      return false;\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}