{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\nimport { NoWork, Sync } from './ReactFiberExpirationTime';\nimport { enterDisallowedContextReadInDEV, exitDisallowedContextReadInDEV } from './ReactFiberNewContext';\nimport { Callback, ShouldCapture, DidCapture } from 'shared/ReactSideEffectTags';\nimport { debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\nimport { StrictMode } from './ReactTypeOfMode';\nimport { markRenderEventTimeAndConfig, markUnprocessedUpdateTime } from './ReactFiberWorkLoop';\nimport invariant from 'shared/invariant';\nimport { getCurrentPriorityLevel } from './SchedulerWithReactIntegration';\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nlet hasForceUpdate = false;\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\n\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function initializeUpdateQueue(fiber) {\n  const queue = {\n    baseState: fiber.memoizedState,\n    baseQueue: null,\n    shared: {\n      pending: null\n    },\n    effects: null\n  };\n  fiber.updateQueue = queue;\n} // 克隆更新队列\n\nexport function cloneUpdateQueue(current, workInProgress) {\n  const queue = workInProgress.updateQueue;\n  const currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    const clone = {\n      baseState: currentQueue.baseState,\n      baseQueue: currentQueue.baseQueue,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nexport function createUpdate(expirationTime, suspenseConfig) {\n  let update = {\n    expirationTime,\n    suspenseConfig,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  update.next = update;\n\n  if (__DEV__) {\n    update.priority = getCurrentPriorityLevel();\n  }\n\n  return update;\n} // 将任务(Update)存放于任务队列(updateQueue)中\n// 创建单向链表结构存放 update, next 用来串联 update\n\nexport function enqueueUpdate(fiber, update) {\n  // 获取当前 Fiber 的 更新队列\n  const updateQueue = fiber.updateQueue; // 如果更新队列不存在 就返回 null\n\n  if (updateQueue === null) {\n    // 仅发生在 fiber 已经被卸载\n    return;\n  } // 获取待执行的 Update 任务\n  // 初始渲染时没有待执行的任务\n\n\n  const sharedQueue = updateQueue.shared;\n  const pending = sharedQueue.pending; // 如果没有待执行的 Update 任务\n\n  if (pending === null) {\n    // 这是第一次更新, 创建一个循环列表.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  } // 将 Update 任务存储在 pending 属性中\n\n\n  sharedQueue.pending = update;\n\n  if (__DEV__) {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      console.error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\nexport function enqueueCapturedUpdate(workInProgress, update) {\n  const current = workInProgress.alternate;\n\n  if (current !== null) {\n    // Ensure the work-in-progress queue is a clone\n    cloneUpdateQueue(current, workInProgress);\n  } // Captured updates go only on the work-in-progress queue.\n\n\n  const queue = workInProgress.updateQueue; // Append the update to the end of the list.\n\n  const last = queue.baseQueue;\n\n  if (last === null) {\n    queue.baseQueue = update.next = update;\n    update.next = update;\n  } else {\n    update.next = last.next;\n    last.next = update;\n  }\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        const payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              payload.call(instance, prevState, nextProps);\n            }\n          }\n\n          const nextState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        const payload = update.payload;\n        let partialState;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              payload.call(instance, prevState, nextProps);\n            }\n          }\n\n          partialState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return Object.assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nexport function processUpdateQueue(workInProgress, props, instance, renderExpirationTime) {\n  // 对于 ClassComponent 和 HostRoot 总是不为空\n  const queue = workInProgress.updateQueue; // 是否有强制更新 false\n\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  } // The last rebase update that is NOT part of the base state.\n  // 初始渲染 null\n\n\n  let baseQueue = queue.baseQueue; // The last pending update that hasn't been processed yet.\n\n  let pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    // null\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      let baseFirst = baseQueue.next;\n      let pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    baseQueue = pendingQueue;\n    queue.shared.pending = null; // TODO: Pass `current` as argument\n\n    const current = workInProgress.alternate;\n\n    if (current !== null) {\n      const currentQueue = current.updateQueue;\n\n      if (currentQueue !== null) {\n        currentQueue.baseQueue = pendingQueue;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (baseQueue !== null) {\n    let first = baseQueue.next; // Iterate through the list of updates to compute the result.\n\n    let newState = queue.baseState;\n    let newExpirationTime = NoWork;\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n\n    if (first !== null) {\n      let update = first;\n\n      do {\n        const updateExpirationTime = update.expirationTime; // false\n\n        if (updateExpirationTime < renderExpirationTime) {\n          // Priority is insufficient. Skip this update. If this is the first\n          // skipped update, the previous update/state is the new base\n          // update/state.\n          const clone = {\n            expirationTime: update.expirationTime,\n            suspenseConfig: update.suspenseConfig,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n\n          if (newBaseQueueLast === null) {\n            newBaseQueueFirst = newBaseQueueLast = clone;\n            newBaseState = newState;\n          } else {\n            newBaseQueueLast = newBaseQueueLast.next = clone;\n          } // Update the remaining priority in the queue.\n\n\n          if (updateExpirationTime > newExpirationTime) {\n            newExpirationTime = updateExpirationTime;\n          }\n        } else {\n          // This update does have sufficient priority.\n          // false\n          if (newBaseQueueLast !== null) {\n            const clone = {\n              expirationTime: Sync,\n              // This update is going to be committed so we never want uncommit it.\n              suspenseConfig: update.suspenseConfig,\n              tag: update.tag,\n              payload: update.payload,\n              callback: update.callback,\n              next: null\n            };\n            newBaseQueueLast = newBaseQueueLast.next = clone;\n          } // Mark the event time of this update as relevant to this render pass.\n          // TODO: This should ideally use the true event time of this update rather than\n          // its priority which is a derived and not reverseable value.\n          // TODO: We should skip this update if it was already committed but currently\n          // we have no way of detecting the difference between a committed and suspended\n          // update here.\n\n\n          markRenderEventTimeAndConfig(updateExpirationTime, update.suspenseConfig); // Process this update.\n\n          newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n          const callback = update.callback;\n\n          if (callback !== null) {\n            workInProgress.effectTag |= Callback;\n            let effects = queue.effects;\n\n            if (effects === null) {\n              queue.effects = [update];\n            } else {\n              effects.push(update);\n            }\n          }\n        }\n\n        update = update.next;\n\n        if (update === null || update === first) {\n          pendingQueue = queue.shared.pending;\n\n          if (pendingQueue === null) {\n            break;\n          } else {\n            // An update was scheduled from inside a reducer. Add the new\n            // pending updates to the end of the list and keep processing.\n            update = baseQueue.next = pendingQueue.next;\n            pendingQueue.next = first;\n            queue.baseQueue = baseQueue = pendingQueue;\n            queue.shared.pending = null;\n          }\n        }\n      } while (true);\n    }\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    }\n\n    queue.baseState = newBaseState;\n    queue.baseQueue = newBaseQueueLast; // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n    markUnprocessedUpdateTime(newExpirationTime);\n    workInProgress.expirationTime = newExpirationTime;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(typeof callback === 'function', 'Invalid argument passed as callback. Expected a function. Instead ' + 'received: %s', callback);\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nexport function checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n/**\n * 执行渲染完成之后的回调函数\n */\n\nexport function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n  // effects 为数组, 存储任务对象 (Update 对象)\n  // 但前提是在调用 render 方法时传递了回调函数, 就是 render 方法的第三个参数\n  const effects = finishedQueue.effects; // 重置 finishedQueue.effects 数组\n\n  finishedQueue.effects = null; // 如果传递了 render 方法的第三个参数, effect 数组就不会为 null\n\n  if (effects !== null) {\n    // 遍历 effect 数组\n    for (let i = 0; i < effects.length; i++) {\n      // 获取数组中的第 i 个需要执行的 effect\n      const effect = effects[i]; // 获取 callback 回调函数\n\n      const callback = effect.callback; // 如果回调函数不为 null\n\n      if (callback !== null) {\n        // 清空 effect 中的 callback\n        effect.callback = null; // 执行回调函数\n\n        callCallback(callback, instance);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactUpdateQueue.js"],"names":["NoWork","Sync","enterDisallowedContextReadInDEV","exitDisallowedContextReadInDEV","Callback","ShouldCapture","DidCapture","debugRenderPhaseSideEffectsForStrictMode","StrictMode","markRenderEventTimeAndConfig","markUnprocessedUpdateTime","invariant","getCurrentPriorityLevel","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","__DEV__","initializeUpdateQueue","fiber","queue","baseState","memoizedState","baseQueue","shared","pending","effects","updateQueue","cloneUpdateQueue","current","workInProgress","currentQueue","clone","createUpdate","expirationTime","suspenseConfig","update","tag","payload","callback","next","priority","enqueueUpdate","sharedQueue","console","error","enqueueCapturedUpdate","alternate","last","getStateFromUpdate","prevState","nextProps","instance","mode","call","nextState","effectTag","partialState","undefined","Object","assign","processUpdateQueue","props","renderExpirationTime","pendingQueue","baseFirst","pendingFirst","first","newState","newExpirationTime","newBaseState","newBaseQueueFirst","newBaseQueueLast","updateExpirationTime","push","callCallback","context","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedWork","finishedQueue","i","length","effect"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed — a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {SuspenseConfig} from './ReactFiberSuspenseConfig';\nimport type {ReactPriorityLevel} from './SchedulerWithReactIntegration';\n\nimport {NoWork, Sync} from './ReactFiberExpirationTime';\nimport {\n  enterDisallowedContextReadInDEV,\n  exitDisallowedContextReadInDEV,\n} from './ReactFiberNewContext';\nimport {Callback, ShouldCapture, DidCapture} from 'shared/ReactSideEffectTags';\n\nimport {debugRenderPhaseSideEffectsForStrictMode} from 'shared/ReactFeatureFlags';\n\nimport {StrictMode} from './ReactTypeOfMode';\nimport {\n  markRenderEventTimeAndConfig,\n  markUnprocessedUpdateTime,\n} from './ReactFiberWorkLoop';\n\nimport invariant from 'shared/invariant';\nimport {getCurrentPriorityLevel} from './SchedulerWithReactIntegration';\n\nexport type Update<State> = {|\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n\n  tag: 0 | 1 | 2 | 3,\n  payload: any,\n  callback: (() => mixed) | null,\n\n  next: Update<State>,\n\n  // DEV only\n  priority?: ReactPriorityLevel,\n|};\n\ntype SharedQueue<State> = {|pending: Update<State> | null|};\n\nexport type UpdateQueue<State> = {|\n  baseState: State,\n  baseQueue: Update<State> | null,\n  shared: SharedQueue<State>,\n  effects: Array<Update<State>> | null,\n|};\n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nlet hasForceUpdate = false;\n\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    baseQueue: null,\n    shared: {\n      pending: null,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n// 克隆更新队列\nexport function cloneUpdateQueue<State>(\n  current: Fiber,\n  workInProgress: Fiber,\n): void {\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n  const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n  if (queue === currentQueue) {\n    const clone: UpdateQueue<State> = {\n      baseState: currentQueue.baseState,\n      baseQueue: currentQueue.baseQueue,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects,\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\n\nexport function createUpdate(\n  expirationTime: ExpirationTime,\n  suspenseConfig: null | SuspenseConfig,\n): Update<*> {\n  let update: Update<*> = {\n    expirationTime,\n    suspenseConfig,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: (null: any),\n  };\n  update.next = update;\n  if (__DEV__) {\n    update.priority = getCurrentPriorityLevel();\n  }\n  return update;\n}\n\n// 将任务(Update)存放于任务队列(updateQueue)中\n// 创建单向链表结构存放 update, next 用来串联 update\nexport function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {\n  // 获取当前 Fiber 的 更新队列\n  const updateQueue = fiber.updateQueue;\n  // 如果更新队列不存在 就返回 null\n  if (updateQueue === null) {\n    // 仅发生在 fiber 已经被卸载\n    return;\n  }\n  // 获取待执行的 Update 任务\n  // 初始渲染时没有待执行的任务\n  const sharedQueue = updateQueue.shared;\n  const pending = sharedQueue.pending;\n  // 如果没有待执行的 Update 任务\n  if (pending === null) {\n    // 这是第一次更新, 创建一个循环列表.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n  // 将 Update 任务存储在 pending 属性中\n  sharedQueue.pending = update;\n  if (__DEV__) {\n    if (\n      currentlyProcessingQueue === sharedQueue &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      console.error(\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.',\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nexport function enqueueCapturedUpdate<State>(\n  workInProgress: Fiber,\n  update: Update<State>,\n) {\n  const current = workInProgress.alternate;\n  if (current !== null) {\n    // Ensure the work-in-progress queue is a clone\n    cloneUpdateQueue(current, workInProgress);\n  }\n\n  // Captured updates go only on the work-in-progress queue.\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n  // Append the update to the end of the list.\n  const last = queue.baseQueue;\n  if (last === null) {\n    queue.baseQueue = update.next = update;\n    update.next = update;\n  } else {\n    update.next = last.next;\n    last.next = update;\n  }\n}\n\nfunction getStateFromUpdate<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n  prevState: State,\n  nextProps: any,\n  instance: any,\n): any {\n  switch (update.tag) {\n    case ReplaceState: {\n      const payload = update.payload;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n          if (\n            debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictMode\n          ) {\n            payload.call(instance, prevState, nextProps);\n          }\n        }\n        const nextState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          exitDisallowedContextReadInDEV();\n        }\n        return nextState;\n      }\n      // State object\n      return payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.effectTag =\n        (workInProgress.effectTag & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      const payload = update.payload;\n      let partialState;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n          if (\n            debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictMode\n          ) {\n            payload.call(instance, prevState, nextProps);\n          }\n        }\n        partialState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          exitDisallowedContextReadInDEV();\n        }\n      } else {\n        // Partial state object\n        partialState = payload;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return Object.assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nexport function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  props: any,\n  instance: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  // 对于 ClassComponent 和 HostRoot 总是不为空\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  // 是否有强制更新 false\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  // The last rebase update that is NOT part of the base state.\n  // 初始渲染 null\n  let baseQueue = queue.baseQueue;\n\n  // The last pending update that hasn't been processed yet.\n  let pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    // null\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      let baseFirst = baseQueue.next;\n      let pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    baseQueue = pendingQueue;\n\n    queue.shared.pending = null;\n\n    // TODO: Pass `current` as argument\n    const current = workInProgress.alternate;\n    if (current !== null) {\n      const currentQueue = current.updateQueue;\n      if (currentQueue !== null) {\n        currentQueue.baseQueue = pendingQueue;\n      }\n    }\n  }\n\n  // These values may change as we process the queue.\n  if (baseQueue !== null) {\n    let first = baseQueue.next;\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState;\n\n    let newExpirationTime = NoWork;\n\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n\n    if (first !== null) {\n      let update = first;\n      do {\n        const updateExpirationTime = update.expirationTime;\n        // false\n        if (updateExpirationTime < renderExpirationTime) {\n          // Priority is insufficient. Skip this update. If this is the first\n          // skipped update, the previous update/state is the new base\n          // update/state.\n          const clone: Update<State> = {\n            expirationTime: update.expirationTime,\n            suspenseConfig: update.suspenseConfig,\n\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n\n            next: (null: any),\n          };\n          if (newBaseQueueLast === null) {\n            newBaseQueueFirst = newBaseQueueLast = clone;\n            newBaseState = newState;\n          } else {\n            newBaseQueueLast = newBaseQueueLast.next = clone;\n          }\n          // Update the remaining priority in the queue.\n          if (updateExpirationTime > newExpirationTime) {\n            newExpirationTime = updateExpirationTime;\n          }\n        } else {\n          // This update does have sufficient priority.\n          // false\n          if (newBaseQueueLast !== null) {\n            const clone: Update<State> = {\n              expirationTime: Sync, // This update is going to be committed so we never want uncommit it.\n              suspenseConfig: update.suspenseConfig,\n\n              tag: update.tag,\n              payload: update.payload,\n              callback: update.callback,\n\n              next: (null: any),\n            };\n            newBaseQueueLast = newBaseQueueLast.next = clone;\n          }\n\n          // Mark the event time of this update as relevant to this render pass.\n          // TODO: This should ideally use the true event time of this update rather than\n          // its priority which is a derived and not reverseable value.\n          // TODO: We should skip this update if it was already committed but currently\n          // we have no way of detecting the difference between a committed and suspended\n          // update here.\n          markRenderEventTimeAndConfig(\n            updateExpirationTime,\n            update.suspenseConfig,\n          );\n\n          // Process this update.\n          newState = getStateFromUpdate(\n            workInProgress,\n            queue,\n            update,\n            newState,\n            props,\n            instance,\n          );\n\n          const callback = update.callback;\n          if (callback !== null) {\n            workInProgress.effectTag |= Callback;\n            let effects = queue.effects;\n            if (effects === null) {\n              queue.effects = [update];\n            } else {\n              effects.push(update);\n            }\n          }\n        }\n        update = update.next;\n\n        if (update === null || update === first) {\n          pendingQueue = queue.shared.pending;\n          if (pendingQueue === null) {\n            break;\n          } else {\n            // An update was scheduled from inside a reducer. Add the new\n            // pending updates to the end of the list and keep processing.\n            update = baseQueue.next = pendingQueue.next;\n            pendingQueue.next = first;\n            queue.baseQueue = baseQueue = pendingQueue;\n            queue.shared.pending = null;\n          }\n        }\n      } while (true);\n    }\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\n    }\n\n    queue.baseState = ((newBaseState: any): State);\n    queue.baseQueue = newBaseQueueLast;\n\n    // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n    markUnprocessedUpdateTime(newExpirationTime);\n    workInProgress.expirationTime = newExpirationTime;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  invariant(\n    typeof callback === 'function',\n    'Invalid argument passed as callback. Expected a function. Instead ' +\n      'received: %s',\n    callback,\n  );\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nexport function checkHasForceUpdateAfterProcessing(): boolean {\n  return hasForceUpdate;\n}\n\n/**\n * 执行渲染完成之后的回调函数\n */\nexport function commitUpdateQueue<State>(\n  finishedWork: Fiber,\n  finishedQueue: UpdateQueue<State>,\n  instance: any,\n): void {\n  // effects 为数组, 存储任务对象 (Update 对象)\n  // 但前提是在调用 render 方法时传递了回调函数, 就是 render 方法的第三个参数\n  const effects = finishedQueue.effects;\n  // 重置 finishedQueue.effects 数组\n  finishedQueue.effects = null;\n  // 如果传递了 render 方法的第三个参数, effect 数组就不会为 null\n  if (effects !== null) {\n    // 遍历 effect 数组\n    for (let i = 0; i < effects.length; i++) {\n      // 获取数组中的第 i 个需要执行的 effect\n      const effect = effects[i];\n      // 获取 callback 回调函数\n      const callback = effect.callback;\n      // 如果回调函数不为 null\n      if (callback !== null) {\n        // 清空 effect 中的 callback\n        effect.callback = null;\n        // 执行回调函数\n        callCallback(callback, instance);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}