{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * \n */\nimport { IS_PASSIVE, PASSIVE_NOT_SUPPORTED } from 'legacy-events/EventSystemFlags';\nimport { HostComponent, ScopeComponent, HostPortal } from 'shared/ReactWorkTags';\nimport { batchedEventUpdates, discreteUpdates, flushDiscreteUpdatesIfNeeded, executeUserEventHandler } from 'legacy-events/ReactGenericBatching';\nimport { enqueueStateRestore } from 'legacy-events/ReactControlledComponent';\nimport { enableDeprecatedFlareAPI } from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport { getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { ContinuousEvent, UserBlockingEvent, DiscreteEvent } from 'shared/ReactTypes'; // Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\n\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority\n} = Scheduler;\nexport let listenToResponderEventTypesImpl;\nexport function setListenToResponderEventTypes(_listenToResponderEventTypesImpl) {\n  listenToResponderEventTypesImpl = _listenToResponderEventTypesImpl;\n}\nconst rootEventTypesToEventResponderInstances = new Map();\nconst DoNotPropagateToNextResponder = 0;\nconst PropagateToNextResponder = 1;\nlet currentTimeStamp = 0;\nlet currentInstance = null;\nlet currentDocument = null;\nlet currentPropagationBehavior = DoNotPropagateToNextResponder;\nconst eventResponderContext = {\n  dispatchEvent(eventValue, eventListener, eventPriority) {\n    validateResponderContext();\n    validateEventValue(eventValue);\n\n    switch (eventPriority) {\n      case DiscreteEvent:\n        {\n          flushDiscreteUpdatesIfNeeded(currentTimeStamp);\n          discreteUpdates(() => executeUserEventHandler(eventListener, eventValue));\n          break;\n        }\n\n      case UserBlockingEvent:\n        {\n          runWithPriority(UserBlockingPriority, () => executeUserEventHandler(eventListener, eventValue));\n          break;\n        }\n\n      case ContinuousEvent:\n        {\n          executeUserEventHandler(eventListener, eventValue);\n          break;\n        }\n    }\n  },\n\n  isTargetWithinResponder(target) {\n    validateResponderContext();\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = currentInstance.fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n\n        fiber = fiber.return;\n      }\n    }\n\n    return false;\n  },\n\n  isTargetWithinResponderScope(target) {\n    validateResponderContext();\n    const componentInstance = currentInstance;\n    const responder = componentInstance.responder;\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = currentInstance.fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n\n        if (doesFiberHaveResponder(fiber, responder)) {\n          return false;\n        }\n\n        fiber = fiber.return;\n      }\n    }\n\n    return false;\n  },\n\n  isTargetWithinNode(childTarget, parentTarget) {\n    validateResponderContext();\n    const childFiber = getClosestInstanceFromNode(childTarget);\n    const parentFiber = getClosestInstanceFromNode(parentTarget);\n\n    if (childFiber != null && parentFiber != null) {\n      const parentAlternateFiber = parentFiber.alternate;\n      let node = childFiber;\n\n      while (node !== null) {\n        if (node === parentFiber || node === parentAlternateFiber) {\n          return true;\n        }\n\n        node = node.return;\n      }\n\n      return false;\n    } // Fallback to DOM APIs\n\n\n    return parentTarget.contains(childTarget);\n  },\n\n  addRootEventTypes(rootEventTypes) {\n    validateResponderContext();\n    listenToResponderEventTypesImpl(rootEventTypes, currentDocument);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      const eventResponderInstance = currentInstance;\n      DEPRECATED_registerRootEventType(rootEventType, eventResponderInstance);\n    }\n  },\n\n  removeRootEventTypes(rootEventTypes) {\n    validateResponderContext();\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      let rootEventResponders = rootEventTypesToEventResponderInstances.get(rootEventType);\n      let rootEventTypesSet = currentInstance.rootEventTypes;\n\n      if (rootEventTypesSet !== null) {\n        rootEventTypesSet.delete(rootEventType);\n      }\n\n      if (rootEventResponders !== undefined) {\n        rootEventResponders.delete(currentInstance);\n      }\n    }\n  },\n\n  getActiveDocument,\n  objectAssign: Object.assign,\n\n  getTimeStamp() {\n    validateResponderContext();\n    return currentTimeStamp;\n  },\n\n  isTargetWithinHostComponent(target, elementType) {\n    validateResponderContext();\n    let fiber = getClosestInstanceFromNode(target);\n\n    while (fiber !== null) {\n      if (fiber.tag === HostComponent && fiber.type === elementType) {\n        return true;\n      }\n\n      fiber = fiber.return;\n    }\n\n    return false;\n  },\n\n  continuePropagation() {\n    currentPropagationBehavior = PropagateToNextResponder;\n  },\n\n  enqueueStateRestore,\n\n  getResponderNode() {\n    validateResponderContext();\n    const responderFiber = currentInstance.fiber;\n\n    if (responderFiber.tag === ScopeComponent) {\n      return null;\n    }\n\n    return responderFiber.stateNode;\n  }\n\n};\n\nfunction validateEventValue(eventValue) {\n  if (typeof eventValue === 'object' && eventValue !== null) {\n    const {\n      target,\n      type,\n      timeStamp\n    } = eventValue;\n\n    if (target == null || type == null || timeStamp == null) {\n      throw new Error('context.dispatchEvent: \"target\", \"timeStamp\", and \"type\" fields on event object are required.');\n    }\n\n    const showWarning = name => {\n      if (__DEV__) {\n        console.error('%s is not available on event objects created from event responder modules (React Flare). ' + 'Try wrapping in a conditional, i.e. `if (event.type !== \"press\") { event.%s }`', name, name);\n      }\n    };\n\n    eventValue.isDefaultPrevented = () => {\n      if (__DEV__) {\n        showWarning('isDefaultPrevented()');\n      }\n    };\n\n    eventValue.isPropagationStopped = () => {\n      if (__DEV__) {\n        showWarning('isPropagationStopped()');\n      }\n    }; // $FlowFixMe: we don't need value, Flow thinks we do\n\n\n    Object.defineProperty(eventValue, 'nativeEvent', {\n      get() {\n        if (__DEV__) {\n          showWarning('nativeEvent');\n        }\n      }\n\n    });\n  }\n}\n\nfunction doesFiberHaveResponder(fiber, responder) {\n  const tag = fiber.tag;\n\n  if (tag === HostComponent || tag === ScopeComponent) {\n    const dependencies = fiber.dependencies;\n\n    if (dependencies !== null) {\n      const respondersMap = dependencies.responders;\n\n      if (respondersMap !== null && respondersMap.has(responder)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction getActiveDocument() {\n  return currentDocument;\n}\n\nfunction createDOMResponderEvent(topLevelType, nativeEvent, nativeEventTarget, passive) {\n  const {\n    buttons,\n    pointerType\n  } = nativeEvent;\n  let eventPointerType = '';\n\n  if (pointerType !== undefined) {\n    eventPointerType = pointerType;\n  } else if (nativeEvent.key !== undefined) {\n    eventPointerType = 'keyboard';\n  } else if (buttons !== undefined) {\n    eventPointerType = 'mouse';\n  } else if (nativeEvent.changedTouches !== undefined) {\n    eventPointerType = 'touch';\n  }\n\n  return {\n    nativeEvent: nativeEvent,\n    passive,\n    pointerType: eventPointerType,\n    target: nativeEventTarget,\n    type: topLevelType\n  };\n}\n\nfunction responderEventTypesContainType(eventTypes, type, isPassive) {\n  for (let i = 0, len = eventTypes.length; i < len; i++) {\n    const eventType = eventTypes[i];\n\n    if (eventType === type || !isPassive && eventType === type + '_active') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction validateResponderTargetEventTypes(eventType, responder, isPassive) {\n  const {\n    targetEventTypes\n  } = responder; // Validate the target event type exists on the responder\n\n  if (targetEventTypes !== null) {\n    return responderEventTypesContainType(targetEventTypes, eventType, isPassive);\n  }\n\n  return false;\n}\n\nfunction traverseAndHandleEventResponderInstances(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  const isPassiveEvent = (eventSystemFlags & IS_PASSIVE) !== 0;\n  const isPassiveSupported = (eventSystemFlags & PASSIVE_NOT_SUPPORTED) === 0;\n  const isPassive = isPassiveEvent || !isPassiveSupported; // Trigger event responders in this order:\n  // - Bubble target responder phase\n  // - Root responder phase\n\n  const visitedResponders = new Set();\n  const responderEvent = createDOMResponderEvent(topLevelType, nativeEvent, nativeEventTarget, isPassiveEvent);\n  let node = targetFiber;\n  let insidePortal = false;\n\n  while (node !== null) {\n    const {\n      dependencies,\n      tag\n    } = node;\n\n    if (tag === HostPortal) {\n      insidePortal = true;\n    } else if ((tag === HostComponent || tag === ScopeComponent) && dependencies !== null) {\n      const respondersMap = dependencies.responders;\n\n      if (respondersMap !== null) {\n        const responderInstances = Array.from(respondersMap.values());\n\n        for (let i = 0, length = responderInstances.length; i < length; i++) {\n          const responderInstance = responderInstances[i];\n          const {\n            props,\n            responder,\n            state\n          } = responderInstance;\n\n          if (!visitedResponders.has(responder) && validateResponderTargetEventTypes(topLevelType, responder, isPassive) && (!insidePortal || responder.targetPortalPropagation)) {\n            visitedResponders.add(responder);\n            const onEvent = responder.onEvent;\n\n            if (onEvent !== null) {\n              currentInstance = responderInstance;\n              onEvent(responderEvent, eventResponderContext, props, state);\n\n              if (currentPropagationBehavior === PropagateToNextResponder) {\n                visitedResponders.delete(responder);\n                currentPropagationBehavior = DoNotPropagateToNextResponder;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    node = node.return;\n  } // Root phase\n\n\n  const passive = rootEventTypesToEventResponderInstances.get(topLevelType);\n  const rootEventResponderInstances = [];\n\n  if (passive !== undefined) {\n    rootEventResponderInstances.push(...Array.from(passive));\n  }\n\n  if (!isPassive) {\n    const active = rootEventTypesToEventResponderInstances.get(topLevelType + '_active');\n\n    if (active !== undefined) {\n      rootEventResponderInstances.push(...Array.from(active));\n    }\n  }\n\n  if (rootEventResponderInstances.length > 0) {\n    const responderInstances = Array.from(rootEventResponderInstances);\n\n    for (let i = 0; i < responderInstances.length; i++) {\n      const responderInstance = responderInstances[i];\n      const {\n        props,\n        responder,\n        state\n      } = responderInstance;\n      const onRootEvent = responder.onRootEvent;\n\n      if (onRootEvent !== null) {\n        currentInstance = responderInstance;\n        onRootEvent(responderEvent, eventResponderContext, props, state);\n      }\n    }\n  }\n}\n\nexport function mountEventResponder(responder, responderInstance, props, state) {\n  const onMount = responder.onMount;\n\n  if (onMount !== null) {\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n\n    try {\n      onMount(eventResponderContext, props, state);\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n}\nexport function unmountEventResponder(responderInstance) {\n  const responder = responderInstance.responder;\n  const onUnmount = responder.onUnmount;\n\n  if (onUnmount !== null) {\n    let {\n      props,\n      state\n    } = responderInstance;\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n\n    try {\n      onUnmount(eventResponderContext, props, state);\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n\n  const rootEventTypesSet = responderInstance.rootEventTypes;\n\n  if (rootEventTypesSet !== null) {\n    const rootEventTypes = Array.from(rootEventTypesSet);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const topLevelEventType = rootEventTypes[i];\n      let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(topLevelEventType);\n\n      if (rootEventResponderInstances !== undefined) {\n        rootEventResponderInstances.delete(responderInstance);\n      }\n    }\n  }\n}\n\nfunction validateResponderContext() {\n  invariant(currentInstance !== null, 'An event responder context was used outside of an event cycle.');\n}\n\nexport function DEPRECATED_dispatchEventForResponderEventSystem(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags) {\n  if (enableDeprecatedFlareAPI) {\n    const previousInstance = currentInstance;\n    const previousTimeStamp = currentTimeStamp;\n    const previousDocument = currentDocument;\n    const previousPropagationBehavior = currentPropagationBehavior;\n    currentPropagationBehavior = DoNotPropagateToNextResponder; // nodeType 9 is DOCUMENT_NODE\n\n    currentDocument = nativeEventTarget.nodeType === 9 ? nativeEventTarget : nativeEventTarget.ownerDocument; // We might want to control timeStamp another way here\n\n    currentTimeStamp = nativeEvent.timeStamp;\n\n    try {\n      batchedEventUpdates(() => {\n        traverseAndHandleEventResponderInstances(topLevelType, targetFiber, nativeEvent, nativeEventTarget, eventSystemFlags);\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimeStamp = previousTimeStamp;\n      currentDocument = previousDocument;\n      currentPropagationBehavior = previousPropagationBehavior;\n    }\n  }\n}\nexport function addRootEventTypesForResponderInstance(responderInstance, rootEventTypes) {\n  for (let i = 0; i < rootEventTypes.length; i++) {\n    const rootEventType = rootEventTypes[i];\n    DEPRECATED_registerRootEventType(rootEventType, responderInstance);\n  }\n}\n\nfunction DEPRECATED_registerRootEventType(rootEventType, eventResponderInstance) {\n  let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(rootEventType);\n\n  if (rootEventResponderInstances === undefined) {\n    rootEventResponderInstances = new Set();\n    rootEventTypesToEventResponderInstances.set(rootEventType, rootEventResponderInstances);\n  }\n\n  let rootEventTypesSet = eventResponderInstance.rootEventTypes;\n\n  if (rootEventTypesSet === null) {\n    rootEventTypesSet = eventResponderInstance.rootEventTypes = new Set();\n  }\n\n  invariant(!rootEventTypesSet.has(rootEventType), 'addRootEventTypes() found a duplicate root event ' + 'type of \"%s\". This might be because the event type exists in the event responder \"rootEventTypes\" ' + 'array or because of a previous addRootEventTypes() using this root event type.', rootEventType);\n  rootEventTypesSet.add(rootEventType);\n  rootEventResponderInstances.add(eventResponderInstance);\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-dom/src/events/DeprecatedDOMEventResponderSystem.js"],"names":["IS_PASSIVE","PASSIVE_NOT_SUPPORTED","HostComponent","ScopeComponent","HostPortal","batchedEventUpdates","discreteUpdates","flushDiscreteUpdatesIfNeeded","executeUserEventHandler","enqueueStateRestore","enableDeprecatedFlareAPI","invariant","getClosestInstanceFromNode","ContinuousEvent","UserBlockingEvent","DiscreteEvent","Scheduler","unstable_UserBlockingPriority","UserBlockingPriority","unstable_runWithPriority","runWithPriority","listenToResponderEventTypesImpl","setListenToResponderEventTypes","_listenToResponderEventTypesImpl","rootEventTypesToEventResponderInstances","Map","DoNotPropagateToNextResponder","PropagateToNextResponder","currentTimeStamp","currentInstance","currentDocument","currentPropagationBehavior","eventResponderContext","dispatchEvent","eventValue","eventListener","eventPriority","validateResponderContext","validateEventValue","isTargetWithinResponder","target","fiber","responderFiber","alternate","return","isTargetWithinResponderScope","componentInstance","responder","doesFiberHaveResponder","isTargetWithinNode","childTarget","parentTarget","childFiber","parentFiber","parentAlternateFiber","node","contains","addRootEventTypes","rootEventTypes","i","length","rootEventType","eventResponderInstance","DEPRECATED_registerRootEventType","removeRootEventTypes","rootEventResponders","get","rootEventTypesSet","delete","undefined","getActiveDocument","objectAssign","Object","assign","getTimeStamp","isTargetWithinHostComponent","elementType","tag","type","continuePropagation","getResponderNode","stateNode","timeStamp","Error","showWarning","name","__DEV__","console","error","isDefaultPrevented","isPropagationStopped","defineProperty","dependencies","respondersMap","responders","has","createDOMResponderEvent","topLevelType","nativeEvent","nativeEventTarget","passive","buttons","pointerType","eventPointerType","key","changedTouches","responderEventTypesContainType","eventTypes","isPassive","len","eventType","validateResponderTargetEventTypes","targetEventTypes","traverseAndHandleEventResponderInstances","targetFiber","eventSystemFlags","isPassiveEvent","isPassiveSupported","visitedResponders","Set","responderEvent","insidePortal","responderInstances","Array","from","values","responderInstance","props","state","targetPortalPropagation","add","onEvent","rootEventResponderInstances","push","active","onRootEvent","mountEventResponder","onMount","previousInstance","unmountEventResponder","onUnmount","topLevelEventType","DEPRECATED_dispatchEventForResponderEventSystem","previousTimeStamp","previousDocument","previousPropagationBehavior","nodeType","ownerDocument","addRootEventTypesForResponderInstance","set"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport {\n  type EventSystemFlags,\n  IS_PASSIVE,\n  PASSIVE_NOT_SUPPORTED,\n} from 'legacy-events/EventSystemFlags';\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport {HostComponent, ScopeComponent, HostPortal} from 'shared/ReactWorkTags';\nimport type {EventPriority} from 'shared/ReactTypes';\nimport type {\n  ReactDOMEventResponder,\n  ReactDOMEventResponderInstance,\n  ReactDOMResponderContext,\n  ReactDOMResponderEvent,\n} from 'shared/ReactDOMTypes';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport {\n  batchedEventUpdates,\n  discreteUpdates,\n  flushDiscreteUpdatesIfNeeded,\n  executeUserEventHandler,\n} from 'legacy-events/ReactGenericBatching';\nimport {enqueueStateRestore} from 'legacy-events/ReactControlledComponent';\nimport type {Fiber} from 'react-reconciler/src/ReactFiber';\nimport {enableDeprecatedFlareAPI} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\n\nimport {getClosestInstanceFromNode} from '../client/ReactDOMComponentTree';\nimport {\n  ContinuousEvent,\n  UserBlockingEvent,\n  DiscreteEvent,\n} from 'shared/ReactTypes';\n\n// Intentionally not named imports because Rollup would use dynamic dispatch for\n// CommonJS interop named imports.\nimport * as Scheduler from 'scheduler';\nconst {\n  unstable_UserBlockingPriority: UserBlockingPriority,\n  unstable_runWithPriority: runWithPriority,\n} = Scheduler;\n\nexport let listenToResponderEventTypesImpl;\n\nexport function setListenToResponderEventTypes(\n  _listenToResponderEventTypesImpl: Function,\n) {\n  listenToResponderEventTypesImpl = _listenToResponderEventTypesImpl;\n}\n\nconst rootEventTypesToEventResponderInstances: Map<\n  DOMTopLevelEventType | string,\n  Set<ReactDOMEventResponderInstance>,\n> = new Map();\n\ntype PropagationBehavior = 0 | 1;\n\nconst DoNotPropagateToNextResponder = 0;\nconst PropagateToNextResponder = 1;\n\nlet currentTimeStamp = 0;\nlet currentInstance: null | ReactDOMEventResponderInstance = null;\nlet currentDocument: null | Document = null;\nlet currentPropagationBehavior: PropagationBehavior = DoNotPropagateToNextResponder;\n\nconst eventResponderContext: ReactDOMResponderContext = {\n  dispatchEvent(\n    eventValue: any,\n    eventListener: any => void,\n    eventPriority: EventPriority,\n  ): void {\n    validateResponderContext();\n    validateEventValue(eventValue);\n    switch (eventPriority) {\n      case DiscreteEvent: {\n        flushDiscreteUpdatesIfNeeded(currentTimeStamp);\n        discreteUpdates(() =>\n          executeUserEventHandler(eventListener, eventValue),\n        );\n        break;\n      }\n      case UserBlockingEvent: {\n        runWithPriority(UserBlockingPriority, () =>\n          executeUserEventHandler(eventListener, eventValue),\n        );\n        break;\n      }\n      case ContinuousEvent: {\n        executeUserEventHandler(eventListener, eventValue);\n        break;\n      }\n    }\n  },\n  isTargetWithinResponder(target: null | Element | Document): boolean {\n    validateResponderContext();\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n        fiber = fiber.return;\n      }\n    }\n    return false;\n  },\n  isTargetWithinResponderScope(target: null | Element | Document): boolean {\n    validateResponderContext();\n    const componentInstance = ((currentInstance: any): ReactDOMEventResponderInstance);\n    const responder = componentInstance.responder;\n\n    if (target != null) {\n      let fiber = getClosestInstanceFromNode(target);\n      const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .fiber;\n\n      while (fiber !== null) {\n        if (fiber === responderFiber || fiber.alternate === responderFiber) {\n          return true;\n        }\n        if (doesFiberHaveResponder(fiber, responder)) {\n          return false;\n        }\n        fiber = fiber.return;\n      }\n    }\n    return false;\n  },\n  isTargetWithinNode(\n    childTarget: Element | Document,\n    parentTarget: Element | Document,\n  ): boolean {\n    validateResponderContext();\n    const childFiber = getClosestInstanceFromNode(childTarget);\n    const parentFiber = getClosestInstanceFromNode(parentTarget);\n\n    if (childFiber != null && parentFiber != null) {\n      const parentAlternateFiber = parentFiber.alternate;\n      let node = childFiber;\n      while (node !== null) {\n        if (node === parentFiber || node === parentAlternateFiber) {\n          return true;\n        }\n        node = node.return;\n      }\n      return false;\n    }\n    // Fallback to DOM APIs\n    return parentTarget.contains(childTarget);\n  },\n  addRootEventTypes(rootEventTypes: Array<string>): void {\n    validateResponderContext();\n    listenToResponderEventTypesImpl(rootEventTypes, currentDocument);\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      const eventResponderInstance = ((currentInstance: any): ReactDOMEventResponderInstance);\n      DEPRECATED_registerRootEventType(rootEventType, eventResponderInstance);\n    }\n  },\n  removeRootEventTypes(rootEventTypes: Array<string>): void {\n    validateResponderContext();\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const rootEventType = rootEventTypes[i];\n      let rootEventResponders = rootEventTypesToEventResponderInstances.get(\n        rootEventType,\n      );\n      let rootEventTypesSet = ((currentInstance: any): ReactDOMEventResponderInstance)\n        .rootEventTypes;\n      if (rootEventTypesSet !== null) {\n        rootEventTypesSet.delete(rootEventType);\n      }\n      if (rootEventResponders !== undefined) {\n        rootEventResponders.delete(\n          ((currentInstance: any): ReactDOMEventResponderInstance),\n        );\n      }\n    }\n  },\n  getActiveDocument,\n  objectAssign: Object.assign,\n  getTimeStamp(): number {\n    validateResponderContext();\n    return currentTimeStamp;\n  },\n  isTargetWithinHostComponent(\n    target: Element | Document,\n    elementType: string,\n  ): boolean {\n    validateResponderContext();\n    let fiber = getClosestInstanceFromNode(target);\n\n    while (fiber !== null) {\n      if (fiber.tag === HostComponent && fiber.type === elementType) {\n        return true;\n      }\n      fiber = fiber.return;\n    }\n    return false;\n  },\n  continuePropagation() {\n    currentPropagationBehavior = PropagateToNextResponder;\n  },\n  enqueueStateRestore,\n  getResponderNode(): Element | null {\n    validateResponderContext();\n    const responderFiber = ((currentInstance: any): ReactDOMEventResponderInstance)\n      .fiber;\n    if (responderFiber.tag === ScopeComponent) {\n      return null;\n    }\n    return responderFiber.stateNode;\n  },\n};\n\nfunction validateEventValue(eventValue: any): void {\n  if (typeof eventValue === 'object' && eventValue !== null) {\n    const {target, type, timeStamp} = eventValue;\n\n    if (target == null || type == null || timeStamp == null) {\n      throw new Error(\n        'context.dispatchEvent: \"target\", \"timeStamp\", and \"type\" fields on event object are required.',\n      );\n    }\n    const showWarning = name => {\n      if (__DEV__) {\n        console.error(\n          '%s is not available on event objects created from event responder modules (React Flare). ' +\n            'Try wrapping in a conditional, i.e. `if (event.type !== \"press\") { event.%s }`',\n          name,\n          name,\n        );\n      }\n    };\n    eventValue.isDefaultPrevented = () => {\n      if (__DEV__) {\n        showWarning('isDefaultPrevented()');\n      }\n    };\n    eventValue.isPropagationStopped = () => {\n      if (__DEV__) {\n        showWarning('isPropagationStopped()');\n      }\n    };\n    // $FlowFixMe: we don't need value, Flow thinks we do\n    Object.defineProperty(eventValue, 'nativeEvent', {\n      get() {\n        if (__DEV__) {\n          showWarning('nativeEvent');\n        }\n      },\n    });\n  }\n}\n\nfunction doesFiberHaveResponder(\n  fiber: Fiber,\n  responder: ReactDOMEventResponder,\n): boolean {\n  const tag = fiber.tag;\n  if (tag === HostComponent || tag === ScopeComponent) {\n    const dependencies = fiber.dependencies;\n    if (dependencies !== null) {\n      const respondersMap = dependencies.responders;\n      if (respondersMap !== null && respondersMap.has(responder)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction getActiveDocument(): Document {\n  return ((currentDocument: any): Document);\n}\n\nfunction createDOMResponderEvent(\n  topLevelType: string,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Element | Document,\n  passive: boolean,\n): ReactDOMResponderEvent {\n  const {buttons, pointerType} = (nativeEvent: any);\n  let eventPointerType = '';\n\n  if (pointerType !== undefined) {\n    eventPointerType = pointerType;\n  } else if (nativeEvent.key !== undefined) {\n    eventPointerType = 'keyboard';\n  } else if (buttons !== undefined) {\n    eventPointerType = 'mouse';\n  } else if ((nativeEvent: any).changedTouches !== undefined) {\n    eventPointerType = 'touch';\n  }\n\n  return {\n    nativeEvent: nativeEvent,\n    passive,\n    pointerType: eventPointerType,\n    target: nativeEventTarget,\n    type: topLevelType,\n  };\n}\n\nfunction responderEventTypesContainType(\n  eventTypes: Array<string>,\n  type: string,\n  isPassive: boolean,\n): boolean {\n  for (let i = 0, len = eventTypes.length; i < len; i++) {\n    const eventType = eventTypes[i];\n    if (eventType === type || (!isPassive && eventType === type + '_active')) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction validateResponderTargetEventTypes(\n  eventType: string,\n  responder: ReactDOMEventResponder,\n  isPassive: boolean,\n): boolean {\n  const {targetEventTypes} = responder;\n  // Validate the target event type exists on the responder\n  if (targetEventTypes !== null) {\n    return responderEventTypesContainType(\n      targetEventTypes,\n      eventType,\n      isPassive,\n    );\n  }\n  return false;\n}\n\nfunction traverseAndHandleEventResponderInstances(\n  topLevelType: string,\n  targetFiber: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Document | Element,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  const isPassiveEvent = (eventSystemFlags & IS_PASSIVE) !== 0;\n  const isPassiveSupported = (eventSystemFlags & PASSIVE_NOT_SUPPORTED) === 0;\n  const isPassive = isPassiveEvent || !isPassiveSupported;\n\n  // Trigger event responders in this order:\n  // - Bubble target responder phase\n  // - Root responder phase\n\n  const visitedResponders = new Set();\n  const responderEvent = createDOMResponderEvent(\n    topLevelType,\n    nativeEvent,\n    nativeEventTarget,\n    isPassiveEvent,\n  );\n  let node = targetFiber;\n  let insidePortal = false;\n  while (node !== null) {\n    const {dependencies, tag} = node;\n    if (tag === HostPortal) {\n      insidePortal = true;\n    } else if (\n      (tag === HostComponent || tag === ScopeComponent) &&\n      dependencies !== null\n    ) {\n      const respondersMap = dependencies.responders;\n      if (respondersMap !== null) {\n        const responderInstances = Array.from(respondersMap.values());\n        for (let i = 0, length = responderInstances.length; i < length; i++) {\n          const responderInstance = responderInstances[i];\n          const {props, responder, state} = responderInstance;\n          if (\n            !visitedResponders.has(responder) &&\n            validateResponderTargetEventTypes(\n              topLevelType,\n              responder,\n              isPassive,\n            ) &&\n            (!insidePortal || responder.targetPortalPropagation)\n          ) {\n            visitedResponders.add(responder);\n            const onEvent = responder.onEvent;\n            if (onEvent !== null) {\n              currentInstance = responderInstance;\n              onEvent(responderEvent, eventResponderContext, props, state);\n              if (currentPropagationBehavior === PropagateToNextResponder) {\n                visitedResponders.delete(responder);\n                currentPropagationBehavior = DoNotPropagateToNextResponder;\n              }\n            }\n          }\n        }\n      }\n    }\n    node = node.return;\n  }\n  // Root phase\n  const passive = rootEventTypesToEventResponderInstances.get(topLevelType);\n  const rootEventResponderInstances = [];\n  if (passive !== undefined) {\n    rootEventResponderInstances.push(...Array.from(passive));\n  }\n  if (!isPassive) {\n    const active = rootEventTypesToEventResponderInstances.get(\n      topLevelType + '_active',\n    );\n    if (active !== undefined) {\n      rootEventResponderInstances.push(...Array.from(active));\n    }\n  }\n  if (rootEventResponderInstances.length > 0) {\n    const responderInstances = Array.from(rootEventResponderInstances);\n\n    for (let i = 0; i < responderInstances.length; i++) {\n      const responderInstance = responderInstances[i];\n      const {props, responder, state} = responderInstance;\n      const onRootEvent = responder.onRootEvent;\n      if (onRootEvent !== null) {\n        currentInstance = responderInstance;\n        onRootEvent(responderEvent, eventResponderContext, props, state);\n      }\n    }\n  }\n}\n\nexport function mountEventResponder(\n  responder: ReactDOMEventResponder,\n  responderInstance: ReactDOMEventResponderInstance,\n  props: Object,\n  state: Object,\n) {\n  const onMount = responder.onMount;\n  if (onMount !== null) {\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n    try {\n      onMount(eventResponderContext, props, state);\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n}\n\nexport function unmountEventResponder(\n  responderInstance: ReactDOMEventResponderInstance,\n): void {\n  const responder = ((responderInstance.responder: any): ReactDOMEventResponder);\n  const onUnmount = responder.onUnmount;\n  if (onUnmount !== null) {\n    let {props, state} = responderInstance;\n    const previousInstance = currentInstance;\n    currentInstance = responderInstance;\n    try {\n      onUnmount(eventResponderContext, props, state);\n    } finally {\n      currentInstance = previousInstance;\n    }\n  }\n  const rootEventTypesSet = responderInstance.rootEventTypes;\n  if (rootEventTypesSet !== null) {\n    const rootEventTypes = Array.from(rootEventTypesSet);\n\n    for (let i = 0; i < rootEventTypes.length; i++) {\n      const topLevelEventType = rootEventTypes[i];\n      let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n        topLevelEventType,\n      );\n      if (rootEventResponderInstances !== undefined) {\n        rootEventResponderInstances.delete(responderInstance);\n      }\n    }\n  }\n}\n\nfunction validateResponderContext(): void {\n  invariant(\n    currentInstance !== null,\n    'An event responder context was used outside of an event cycle.',\n  );\n}\n\nexport function DEPRECATED_dispatchEventForResponderEventSystem(\n  topLevelType: string,\n  targetFiber: null | Fiber,\n  nativeEvent: AnyNativeEvent,\n  nativeEventTarget: Document | Element,\n  eventSystemFlags: EventSystemFlags,\n): void {\n  if (enableDeprecatedFlareAPI) {\n    const previousInstance = currentInstance;\n    const previousTimeStamp = currentTimeStamp;\n    const previousDocument = currentDocument;\n    const previousPropagationBehavior = currentPropagationBehavior;\n    currentPropagationBehavior = DoNotPropagateToNextResponder;\n    // nodeType 9 is DOCUMENT_NODE\n    currentDocument =\n      (nativeEventTarget: any).nodeType === 9\n        ? ((nativeEventTarget: any): Document)\n        : (nativeEventTarget: any).ownerDocument;\n    // We might want to control timeStamp another way here\n    currentTimeStamp = (nativeEvent: any).timeStamp;\n    try {\n      batchedEventUpdates(() => {\n        traverseAndHandleEventResponderInstances(\n          topLevelType,\n          targetFiber,\n          nativeEvent,\n          nativeEventTarget,\n          eventSystemFlags,\n        );\n      });\n    } finally {\n      currentInstance = previousInstance;\n      currentTimeStamp = previousTimeStamp;\n      currentDocument = previousDocument;\n      currentPropagationBehavior = previousPropagationBehavior;\n    }\n  }\n}\n\nexport function addRootEventTypesForResponderInstance(\n  responderInstance: ReactDOMEventResponderInstance,\n  rootEventTypes: Array<string>,\n): void {\n  for (let i = 0; i < rootEventTypes.length; i++) {\n    const rootEventType = rootEventTypes[i];\n    DEPRECATED_registerRootEventType(rootEventType, responderInstance);\n  }\n}\n\nfunction DEPRECATED_registerRootEventType(\n  rootEventType: string,\n  eventResponderInstance: ReactDOMEventResponderInstance,\n): void {\n  let rootEventResponderInstances = rootEventTypesToEventResponderInstances.get(\n    rootEventType,\n  );\n  if (rootEventResponderInstances === undefined) {\n    rootEventResponderInstances = new Set();\n    rootEventTypesToEventResponderInstances.set(\n      rootEventType,\n      rootEventResponderInstances,\n    );\n  }\n  let rootEventTypesSet = eventResponderInstance.rootEventTypes;\n  if (rootEventTypesSet === null) {\n    rootEventTypesSet = eventResponderInstance.rootEventTypes = new Set();\n  }\n  invariant(\n    !rootEventTypesSet.has(rootEventType),\n    'addRootEventTypes() found a duplicate root event ' +\n      'type of \"%s\". This might be because the event type exists in the event responder \"rootEventTypes\" ' +\n      'array or because of a previous addRootEventTypes() using this root event type.',\n    rootEventType,\n  );\n  rootEventTypesSet.add(rootEventType);\n  rootEventResponderInstances.add(eventResponderInstance);\n}\n"]},"metadata":{},"sourceType":"module"}