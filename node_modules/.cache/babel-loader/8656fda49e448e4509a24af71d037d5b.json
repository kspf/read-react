{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { FundamentalComponent } from 'shared/ReactWorkTags';\nimport { findCurrentHostFiber, findCurrentHostFiberWithNoPortals } from 'react-reconciler/reflection';\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport { HostComponent, ClassComponent, HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { getPublicInstance } from './ReactFiberHostConfig';\nimport { findCurrentUnmaskedContext, processChildContext, emptyContextObject, isContextProvider as isLegacyContextProvider } from './ReactFiberContext';\nimport { createFiberRoot } from './ReactFiberRoot';\nimport { injectInternals, onScheduleRoot } from './ReactFiberDevToolsHook';\nimport { requestCurrentTimeForUpdate, computeExpirationForFiber, scheduleWork, flushRoot, batchedEventUpdates, batchedUpdates, unbatchedUpdates, flushSync, flushControlled, deferredUpdates, syncUpdates, discreteUpdates, flushDiscreteUpdates, flushPassiveEffects, warnIfNotScopedWithMatchingAct, warnIfUnmockedScheduler, IsThisRendererActing } from './ReactFiberWorkLoop';\nimport { createUpdate, enqueueUpdate } from './ReactUpdateQueue';\nimport { getStackByFiberInDevAndProd, isRendering as ReactCurrentFiberIsRendering, current as ReactCurrentFiberCurrent } from './ReactCurrentFiber';\nimport { StrictMode } from './ReactTypeOfMode';\nimport { Sync, ContinuousHydration, computeInteractiveExpiration } from './ReactFiberExpirationTime';\nimport { requestCurrentSuspenseConfig } from './ReactFiberSuspenseConfig';\nimport { scheduleRefresh, scheduleRoot, setRefreshHandler, findHostInstancesForRefresh } from './ReactFiberHotReloading'; // used by isTestEnvironment builds\n\nimport enqueueTask from 'shared/enqueueTask';\nimport * as Scheduler from 'scheduler'; // end isTestEnvironment imports\n\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  const fiber = getInstance(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n    }\n  }\n\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n      }\n    }\n\n    const hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictMode) {\n      const componentName = getComponentName(fiber.type) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n\n        if (fiber.mode & StrictMode) {\n          console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-find-node%s', methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));\n        } else {\n          console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-find-node%s', methodName, methodName, componentName, getStackByFiberInDevAndProd(hostFiber));\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n\n  return findHostInstance(component);\n}\n\nexport function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {\n  // containerInfo => <div id=\"root\"></div>\n  // tag: 0\n  // hydrate: false\n  // hydrationCallbacks: null\n  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);\n}\n/**\n * 计算任务的过期时间\n * 再根据任务过期时间创建 Update 任务\n * 通过任务的过期时间还可以计算出任务的优先级\n */\n\nexport function updateContainer( // element 要渲染的 ReactElement\nelement, // container Fiber Root 对象\ncontainer, // parentComponent 父组件 初始渲染为 null\nparentComponent, // ReactElement 渲染完成执行的回调函数\ncallback) {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  } // container 获取 rootFiber\n\n\n  const current = container.current; // 获取当前距离 react 应用初始化的时间 1073741805\n\n  const currentTime = requestCurrentTimeForUpdate();\n\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfUnmockedScheduler(current);\n      warnIfNotScopedWithMatchingAct(current);\n    }\n  } // 异步加载设置\n\n\n  const suspenseConfig = requestCurrentSuspenseConfig(); // 计算过期时间\n  // 为防止任务因为优先级的原因一直被打断而未能执行\n  // react 会设置一个过期时间, 当时间到了过期时间的时候\n  // 如果任务还未执行的话, react 将会强制执行该任务\n  // 初始化渲染时, 任务同步执行不涉及被打断的问题\n  // 过期时间被设置成了 1073741823, 这个数值表示当前任务为同步任务\n\n  const expirationTime = computeExpirationForFiber(currentTime, current, suspenseConfig); // 设置FiberRoot.context, 首次执行返回一个emptyContext, 是一个 {}\n\n  const context = getContextForSubtree(parentComponent); // 初始渲染时 Fiber Root 对象中的 context 属性值为 null\n  // 所以会进入到 if 中\n\n  if (container.context === null) {\n    // 初始渲染时将 context 属性值设置为 {}\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (ReactCurrentFiberIsRendering && ReactCurrentFiberCurrent !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      console.error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactCurrentFiberCurrent.type) || 'Unknown');\n    }\n  } // 创建一个待执行任务\n\n\n  const update = createUpdate(expirationTime, suspenseConfig); // 将要更新的内容挂载到更新对象中的 payload 中\n  // 将要更新的组件存储在 payload 对象中, 方便后期获取\n\n  update.payload = {\n    element\n  }; // 判断 callback 是否存在\n\n  callback = callback === undefined ? null : callback; // 如果 callback 存在\n\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    } // 将 callback 挂载到 update 对象中\n    // 其实就是一层层传递 方便 ReactElement 元素渲染完成调用\n    // 回调函数执行完成后会被清除 可以在代码的后面加上 return 进行验证\n\n\n    update.callback = callback;\n  } // 将 update 对象加入到当前 Fiber 的更新队列当中 (updateQueue)\n  // 待执行的任务都会被存储在 fiber.updateQueue.shared.pending 中\n\n\n  enqueueUpdate(current, update); // 调度和更新 current 对象\n\n  scheduleWork(current, expirationTime); // 返回过期时间\n\n  return expirationTime;\n}\nexport { batchedEventUpdates, batchedUpdates, unbatchedUpdates, deferredUpdates, syncUpdates, discreteUpdates, flushDiscreteUpdates, flushControlled, flushSync, flushPassiveEffects, IsThisRendererActing };\n/**\n * 获取 container 的第一个子元素的实例对象\n */\n\nexport function getPublicRootInstance( // FiberRoot\ncontainer) {\n  // 获取 rootFiber\n  const containerFiber = container.current; // 如果 rootFiber 没有子元素\n  // 指的就是 id=\"root\" 的 div 没有子元素\n\n  if (!containerFiber.child) {\n    // 返回 null\n    return null;\n  } // 匹配子元素的类型\n\n\n  switch (containerFiber.child.tag) {\n    // 普通\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      // 返回子元素的真实 DOM 对象\n      return containerFiber.child.stateNode;\n  }\n}\nexport function attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      let root = fiber.stateNode;\n\n      if (root.hydrate) {\n        // Flush the first scheduled \"update\".\n        flushRoot(root, root.firstPendingTime);\n      }\n\n      break;\n\n    case SuspenseComponent:\n      flushSync(() => scheduleWork(fiber, Sync)); // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n\n      let retryExpTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());\n      markRetryTimeIfNotHydrated(fiber, retryExpTime);\n      break;\n  }\n}\n\nfunction markRetryTimeImpl(fiber, retryTime) {\n  let suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    if (suspenseState.retryTime < retryTime) {\n      suspenseState.retryTime = retryTime;\n    }\n  }\n} // Increases the priority of thennables when they resolve within this boundary.\n\n\nfunction markRetryTimeIfNotHydrated(fiber, retryTime) {\n  markRetryTimeImpl(fiber, retryTime);\n  let alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryTimeImpl(alternate, retryTime);\n  }\n}\n\nexport function attemptUserBlockingHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  let expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\nexport function attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  scheduleWork(fiber, ContinuousHydration);\n  markRetryTimeIfNotHydrated(fiber, ContinuousHydration);\n}\nexport function attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  const currentTime = requestCurrentTimeForUpdate();\n  const expTime = computeExpirationForFiber(currentTime, fiber, null);\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\nexport { findHostInstance };\nexport { findHostInstanceWithWarning };\nexport function findHostInstanceWithNoPortals(fiber) {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  if (hostFiber.tag === FundamentalComponent) {\n    return hostFiber.stateNode.instance;\n  }\n\n  return hostFiber.stateNode;\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nlet overrideHookState = null;\nlet overrideProps = null;\nlet scheduleUpdate = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithSetImpl = (obj, path, idx, value) => {\n    if (idx >= path.length) {\n      return value;\n    }\n\n    const key = path[idx];\n    const updated = Array.isArray(obj) ? obj.slice() : { ...obj\n    }; // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (obj, path, value) => {\n    return copyWithSetImpl(obj, path, 0, value);\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = (fiber, id, path, value) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    if (currentHook !== null) {\n      const newState = copyWithSet(currentHook.memoizedState, path, value);\n      currentHook.memoizedState = newState;\n      currentHook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      scheduleWork(fiber, Sync);\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = (fiber, path, value) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleWork(fiber, Sync);\n  };\n\n  scheduleUpdate = fiber => {\n    scheduleWork(fiber, Sync);\n  };\n\n  setSuspenseHandler = newShouldSuspendImpl => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nexport function injectIntoDevTools(devToolsConfig) {\n  const {\n    findFiberByHostInstance\n  } = devToolsConfig;\n  const {\n    ReactCurrentDispatcher\n  } = ReactSharedInternals;\n  return injectInternals({ ...devToolsConfig,\n    overrideHookState,\n    overrideProps,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n\n    findHostInstanceByFiber(fiber) {\n      const hostFiber = findCurrentHostFiber(fiber);\n\n      if (hostFiber === null) {\n        return null;\n      }\n\n      return hostFiber.stateNode;\n    },\n\n    findFiberByHostInstance(instance) {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n\n      return findFiberByHostInstance(instance);\n    },\n\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? () => ReactCurrentFiberCurrent : null\n  });\n}\nconst {\n  IsSomeRendererActing\n} = ReactSharedInternals;\nconst isSchedulerMocked = typeof Scheduler.unstable_flushAllWithoutAsserting === 'function';\n\nconst flushWork = Scheduler.unstable_flushAllWithoutAsserting || function () {\n  let didFlushWork = false;\n\n  while (flushPassiveEffects()) {\n    didFlushWork = true;\n  }\n\n  return didFlushWork;\n};\n\nfunction flushWorkAndMicroTasks(onDone) {\n  try {\n    flushWork();\n    enqueueTask(() => {\n      if (flushWork()) {\n        flushWorkAndMicroTasks(onDone);\n      } else {\n        onDone();\n      }\n    });\n  } catch (err) {\n    onDone(err);\n  }\n} // we track the 'depth' of the act() calls with this counter,\n// so we can tell if any async act() calls try to run in parallel.\n\n\nlet actingUpdatesScopeDepth = 0;\nlet didWarnAboutUsingActInProd = false; // eslint-disable-next-line no-inner-declarations\n\nexport function act(callback) {\n  if (!__DEV__) {\n    if (didWarnAboutUsingActInProd === false) {\n      didWarnAboutUsingActInProd = true; // eslint-disable-next-line react-internal/no-production-logging\n\n      console.error('act(...) is not supported in production builds of React, and might not behave as expected.');\n    }\n  }\n\n  let previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\n  let previousIsSomeRendererActing;\n  let previousIsThisRendererActing;\n  actingUpdatesScopeDepth++;\n  previousIsSomeRendererActing = IsSomeRendererActing.current;\n  previousIsThisRendererActing = IsThisRendererActing.current;\n  IsSomeRendererActing.current = true;\n  IsThisRendererActing.current = true;\n\n  function onDone() {\n    actingUpdatesScopeDepth--;\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\n    IsThisRendererActing.current = previousIsThisRendererActing;\n\n    if (__DEV__) {\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\n        console.error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n      }\n    }\n  }\n\n  let result;\n\n  try {\n    result = batchedUpdates(callback);\n  } catch (error) {\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\n    onDone();\n    throw error;\n  }\n\n  if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n    // setup a boolean that gets set to true only\n    // once this act() call is await-ed\n    let called = false;\n\n    if (__DEV__) {\n      if (typeof Promise !== 'undefined') {\n        //eslint-disable-next-line no-undef\n        Promise.resolve().then(() => {}).then(() => {\n          if (called === false) {\n            console.error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, interleaving multiple act ' + 'calls and mixing their scopes. You should - await act(async () => ...);');\n          }\n        });\n      }\n    } // in the async case, the returned thenable runs the callback, flushes\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\n    // and cleans up\n\n\n    return {\n      then(resolve, reject) {\n        called = true;\n        result.then(() => {\n          if (actingUpdatesScopeDepth > 1 || isSchedulerMocked === true && previousIsSomeRendererActing === true) {\n            onDone();\n            resolve();\n            return;\n          } // we're about to exit the act() scope,\n          // now's the time to flush tasks/effects\n\n\n          flushWorkAndMicroTasks(err => {\n            onDone();\n\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        }, err => {\n          onDone();\n          reject(err);\n        });\n      }\n\n    };\n  } else {\n    if (__DEV__) {\n      if (result !== undefined) {\n        console.error('The callback passed to act(...) function ' + 'must return undefined, or a Promise. You returned %s', result);\n      }\n    } // flush effects until none remain, and cleanup\n\n\n    try {\n      if (actingUpdatesScopeDepth === 1 && (isSchedulerMocked === false || previousIsSomeRendererActing === false)) {\n        // we're about to exit the act() scope,\n        // now's the time to flush effects\n        flushWork();\n      }\n\n      onDone();\n    } catch (err) {\n      onDone();\n      throw err;\n    } // in the sync case, the returned thenable only warns *if* await-ed\n\n\n    return {\n      then(resolve) {\n        if (__DEV__) {\n          console.error('Do not await the result of calling act(...) with sync logic, it is not a Promise.');\n        }\n\n        resolve();\n      }\n\n    };\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberReconciler.js"],"names":["FundamentalComponent","findCurrentHostFiber","findCurrentHostFiberWithNoPortals","get","getInstance","HostComponent","ClassComponent","HostRoot","SuspenseComponent","getComponentName","invariant","ReactSharedInternals","getPublicInstance","findCurrentUnmaskedContext","processChildContext","emptyContextObject","isContextProvider","isLegacyContextProvider","createFiberRoot","injectInternals","onScheduleRoot","requestCurrentTimeForUpdate","computeExpirationForFiber","scheduleWork","flushRoot","batchedEventUpdates","batchedUpdates","unbatchedUpdates","flushSync","flushControlled","deferredUpdates","syncUpdates","discreteUpdates","flushDiscreteUpdates","flushPassiveEffects","warnIfNotScopedWithMatchingAct","warnIfUnmockedScheduler","IsThisRendererActing","createUpdate","enqueueUpdate","getStackByFiberInDevAndProd","isRendering","ReactCurrentFiberIsRendering","current","ReactCurrentFiberCurrent","StrictMode","Sync","ContinuousHydration","computeInteractiveExpiration","requestCurrentSuspenseConfig","scheduleRefresh","scheduleRoot","setRefreshHandler","findHostInstancesForRefresh","enqueueTask","Scheduler","didWarnAboutNestedUpdates","didWarnAboutFindNodeInStrictMode","__DEV__","getContextForSubtree","parentComponent","fiber","parentContext","tag","Component","type","findHostInstance","component","undefined","render","Object","keys","hostFiber","stateNode","findHostInstanceWithWarning","methodName","mode","componentName","console","error","createContainer","containerInfo","hydrate","hydrationCallbacks","updateContainer","element","container","callback","currentTime","jest","suspenseConfig","expirationTime","context","pendingContext","update","payload","getPublicRootInstance","containerFiber","child","attemptSynchronousHydration","root","firstPendingTime","retryExpTime","markRetryTimeIfNotHydrated","markRetryTimeImpl","retryTime","suspenseState","memoizedState","dehydrated","alternate","attemptUserBlockingHydration","expTime","attemptContinuousHydration","attemptHydrationAtCurrentPriority","findHostInstanceWithNoPortals","instance","shouldSuspendImpl","shouldSuspend","overrideHookState","overrideProps","scheduleUpdate","setSuspenseHandler","copyWithSetImpl","obj","path","idx","value","length","key","updated","Array","isArray","slice","copyWithSet","id","currentHook","next","newState","baseState","memoizedProps","pendingProps","newShouldSuspendImpl","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","ReactCurrentDispatcher","currentDispatcherRef","findHostInstanceByFiber","getCurrentFiber","IsSomeRendererActing","isSchedulerMocked","unstable_flushAllWithoutAsserting","flushWork","didFlushWork","flushWorkAndMicroTasks","onDone","err","actingUpdatesScopeDepth","didWarnAboutUsingActInProd","act","previousActingUpdatesScopeDepth","previousIsSomeRendererActing","previousIsThisRendererActing","result","then","called","Promise","resolve","reject"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {RootTag} from 'shared/ReactRootTags';\nimport type {\n  Instance,\n  TextInstance,\n  Container,\n  PublicInstance,\n} from './ReactFiberHostConfig';\nimport {FundamentalComponent} from 'shared/ReactWorkTags';\nimport type {ReactNodeList} from 'shared/ReactTypes';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {\n  SuspenseHydrationCallbacks,\n  SuspenseState,\n} from './ReactFiberSuspenseComponent';\n\nimport {\n  findCurrentHostFiber,\n  findCurrentHostFiberWithNoPortals,\n} from 'react-reconciler/reflection';\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport {\n  HostComponent,\n  ClassComponent,\n  HostRoot,\n  SuspenseComponent,\n} from 'shared/ReactWorkTags';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {getPublicInstance} from './ReactFiberHostConfig';\nimport {\n  findCurrentUnmaskedContext,\n  processChildContext,\n  emptyContextObject,\n  isContextProvider as isLegacyContextProvider,\n} from './ReactFiberContext';\nimport {createFiberRoot} from './ReactFiberRoot';\nimport {injectInternals, onScheduleRoot} from './ReactFiberDevToolsHook';\nimport {\n  requestCurrentTimeForUpdate,\n  computeExpirationForFiber,\n  scheduleWork,\n  flushRoot,\n  batchedEventUpdates,\n  batchedUpdates,\n  unbatchedUpdates,\n  flushSync,\n  flushControlled,\n  deferredUpdates,\n  syncUpdates,\n  discreteUpdates,\n  flushDiscreteUpdates,\n  flushPassiveEffects,\n  warnIfNotScopedWithMatchingAct,\n  warnIfUnmockedScheduler,\n  IsThisRendererActing,\n} from './ReactFiberWorkLoop';\nimport {createUpdate, enqueueUpdate} from './ReactUpdateQueue';\nimport {\n  getStackByFiberInDevAndProd,\n  isRendering as ReactCurrentFiberIsRendering,\n  current as ReactCurrentFiberCurrent,\n} from './ReactCurrentFiber';\nimport {StrictMode} from './ReactTypeOfMode';\nimport {\n  Sync,\n  ContinuousHydration,\n  computeInteractiveExpiration,\n} from './ReactFiberExpirationTime';\nimport {requestCurrentSuspenseConfig} from './ReactFiberSuspenseConfig';\nimport {\n  scheduleRefresh,\n  scheduleRoot,\n  setRefreshHandler,\n  findHostInstancesForRefresh,\n} from './ReactFiberHotReloading';\n\n// used by isTestEnvironment builds\nimport enqueueTask from 'shared/enqueueTask';\nimport * as Scheduler from 'scheduler';\n// end isTestEnvironment imports\n\ntype OpaqueRoot = FiberRoot;\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\ntype BundleType = 0 | 1;\n\ntype DevToolsConfig = {|\n  bundleType: BundleType,\n  version: string,\n  rendererPackageName: string,\n  // Note: this actually *does* depend on Fiber internal fields.\n  // Used by \"inspect clicked DOM element\" in React DevTools.\n  findFiberByHostInstance?: (instance: Instance | TextInstance) => Fiber,\n  // Used by RN in-app inspector.\n  // This API is unfortunately RN-specific.\n  // TODO: Change it to accept Fiber instead and type it properly.\n  getInspectorDataForViewTag?: (tag: number) => Object,\n|};\n\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(\n  parentComponent: ?React$Component<any, any>,\n): Object {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component: Object): PublicInstance | null {\n  const fiber = getInstance(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(\n        false,\n        'Argument appears to not be a ReactComponent. Keys: %s',\n        Object.keys(component),\n      );\n    }\n  }\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(\n  component: Object,\n  methodName: string,\n): PublicInstance | null {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(\n          false,\n          'Argument appears to not be a ReactComponent. Keys: %s',\n          Object.keys(component),\n        );\n      }\n    }\n    const hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    if (hostFiber.mode & StrictMode) {\n      const componentName = getComponentName(fiber.type) || 'Component';\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        if (fiber.mode & StrictMode) {\n          console.error(\n            '%s is deprecated in StrictMode. ' +\n              '%s was passed an instance of %s which is inside StrictMode. ' +\n              'Instead, add a ref directly to the element you want to reference. ' +\n              'Learn more about using refs safely here: ' +\n              'https://fb.me/react-strict-mode-find-node%s',\n            methodName,\n            methodName,\n            componentName,\n            getStackByFiberInDevAndProd(hostFiber),\n          );\n        } else {\n          console.error(\n            '%s is deprecated in StrictMode. ' +\n              '%s was passed an instance of %s which renders StrictMode children. ' +\n              'Instead, add a ref directly to the element you want to reference. ' +\n              'Learn more about using refs safely here: ' +\n              'https://fb.me/react-strict-mode-find-node%s',\n            methodName,\n            methodName,\n            componentName,\n            getStackByFiberInDevAndProd(hostFiber),\n          );\n        }\n      }\n    }\n    return hostFiber.stateNode;\n  }\n  return findHostInstance(component);\n}\n\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): OpaqueRoot {\n  // containerInfo => <div id=\"root\"></div>\n  // tag: 0\n  // hydrate: false\n  // hydrationCallbacks: null\n  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);\n}\n/**\n * 计算任务的过期时间\n * 再根据任务过期时间创建 Update 任务\n * 通过任务的过期时间还可以计算出任务的优先级\n */\nexport function updateContainer(\n  // element 要渲染的 ReactElement\n  element: ReactNodeList,\n  // container Fiber Root 对象\n  container: OpaqueRoot,\n  // parentComponent 父组件 初始渲染为 null\n  parentComponent: ?React$Component<any, any>,\n  // ReactElement 渲染完成执行的回调函数\n  callback: ?Function,\n): ExpirationTime {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  }\n  // container 获取 rootFiber\n  const current = container.current;\n  // 获取当前距离 react 应用初始化的时间 1073741805\n  const currentTime = requestCurrentTimeForUpdate();\n\n  if (__DEV__) {\n    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests\n    if ('undefined' !== typeof jest) {\n      warnIfUnmockedScheduler(current);\n      warnIfNotScopedWithMatchingAct(current);\n    }\n  }\n  // 异步加载设置\n  const suspenseConfig = requestCurrentSuspenseConfig();\n\n  // 计算过期时间\n  // 为防止任务因为优先级的原因一直被打断而未能执行\n  // react 会设置一个过期时间, 当时间到了过期时间的时候\n  // 如果任务还未执行的话, react 将会强制执行该任务\n  // 初始化渲染时, 任务同步执行不涉及被打断的问题\n  // 过期时间被设置成了 1073741823, 这个数值表示当前任务为同步任务\n  const expirationTime = computeExpirationForFiber(\n    currentTime,\n    current,\n    suspenseConfig,\n  );\n  // 设置FiberRoot.context, 首次执行返回一个emptyContext, 是一个 {}\n  const context = getContextForSubtree(parentComponent);\n  // 初始渲染时 Fiber Root 对象中的 context 属性值为 null\n  // 所以会进入到 if 中\n  if (container.context === null) {\n    // 初始渲染时将 context 属性值设置为 {}\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n  if (__DEV__) {\n    if (\n      ReactCurrentFiberIsRendering &&\n      ReactCurrentFiberCurrent !== null &&\n      !didWarnAboutNestedUpdates\n    ) {\n      didWarnAboutNestedUpdates = true;\n      console.error(\n        'Render methods should be a pure function of props and state; ' +\n          'triggering nested component updates from render is not allowed. ' +\n          'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' +\n          'Check the render method of %s.',\n        getComponentName(ReactCurrentFiberCurrent.type) || 'Unknown',\n      );\n    }\n  }\n\n  // 创建一个待执行任务\n  const update = createUpdate(expirationTime, suspenseConfig);\n  // 将要更新的内容挂载到更新对象中的 payload 中\n  // 将要更新的组件存储在 payload 对象中, 方便后期获取\n  update.payload = {element};\n  // 判断 callback 是否存在\n  callback = callback === undefined ? null : callback;\n  // 如果 callback 存在\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error(\n          'render(...): Expected the last optional `callback` argument to be a ' +\n            'function. Instead received: %s.',\n          callback,\n        );\n      }\n    }\n    // 将 callback 挂载到 update 对象中\n    // 其实就是一层层传递 方便 ReactElement 元素渲染完成调用\n    // 回调函数执行完成后会被清除 可以在代码的后面加上 return 进行验证\n    update.callback = callback;\n  }\n  // 将 update 对象加入到当前 Fiber 的更新队列当中 (updateQueue)\n  // 待执行的任务都会被存储在 fiber.updateQueue.shared.pending 中\n  enqueueUpdate(current, update);\n  // 调度和更新 current 对象\n  scheduleWork(current, expirationTime);\n  // 返回过期时间\n  return expirationTime;\n}\n\nexport {\n  batchedEventUpdates,\n  batchedUpdates,\n  unbatchedUpdates,\n  deferredUpdates,\n  syncUpdates,\n  discreteUpdates,\n  flushDiscreteUpdates,\n  flushControlled,\n  flushSync,\n  flushPassiveEffects,\n  IsThisRendererActing,\n};\n\n/**\n * 获取 container 的第一个子元素的实例对象\n */\nexport function getPublicRootInstance(\n  // FiberRoot\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  // 获取 rootFiber\n  const containerFiber = container.current;\n  // 如果 rootFiber 没有子元素\n  // 指的就是 id=\"root\" 的 div 没有子元素\n  if (!containerFiber.child) {\n    // 返回 null\n    return null;\n  }\n  // 匹配子元素的类型\n  switch (containerFiber.child.tag) {\n    // 普通\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      // 返回子元素的真实 DOM 对象\n      return containerFiber.child.stateNode;\n  }\n}\n\nexport function attemptSynchronousHydration(fiber: Fiber): void {\n  switch (fiber.tag) {\n    case HostRoot:\n      let root: FiberRoot = fiber.stateNode;\n      if (root.hydrate) {\n        // Flush the first scheduled \"update\".\n        flushRoot(root, root.firstPendingTime);\n      }\n      break;\n    case SuspenseComponent:\n      flushSync(() => scheduleWork(fiber, Sync));\n      // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n      let retryExpTime = computeInteractiveExpiration(\n        requestCurrentTimeForUpdate(),\n      );\n      markRetryTimeIfNotHydrated(fiber, retryExpTime);\n      break;\n  }\n}\n\nfunction markRetryTimeImpl(fiber: Fiber, retryTime: ExpirationTime) {\n  let suspenseState: null | SuspenseState = fiber.memoizedState;\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    if (suspenseState.retryTime < retryTime) {\n      suspenseState.retryTime = retryTime;\n    }\n  }\n}\n\n// Increases the priority of thennables when they resolve within this boundary.\nfunction markRetryTimeIfNotHydrated(fiber: Fiber, retryTime: ExpirationTime) {\n  markRetryTimeImpl(fiber, retryTime);\n  let alternate = fiber.alternate;\n  if (alternate) {\n    markRetryTimeImpl(alternate, retryTime);\n  }\n}\n\nexport function attemptUserBlockingHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  let expTime = computeInteractiveExpiration(requestCurrentTimeForUpdate());\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\n\nexport function attemptContinuousHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  scheduleWork(fiber, ContinuousHydration);\n  markRetryTimeIfNotHydrated(fiber, ContinuousHydration);\n}\n\nexport function attemptHydrationAtCurrentPriority(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n  const currentTime = requestCurrentTimeForUpdate();\n  const expTime = computeExpirationForFiber(currentTime, fiber, null);\n  scheduleWork(fiber, expTime);\n  markRetryTimeIfNotHydrated(fiber, expTime);\n}\n\nexport {findHostInstance};\n\nexport {findHostInstanceWithWarning};\n\nexport function findHostInstanceWithNoPortals(\n  fiber: Fiber,\n): PublicInstance | null {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  if (hostFiber.tag === FundamentalComponent) {\n    return hostFiber.stateNode.instance;\n  }\n  return hostFiber.stateNode;\n}\n\nlet shouldSuspendImpl = (fiber) => false;\n\nexport function shouldSuspend(fiber: Fiber): boolean {\n  return shouldSuspendImpl(fiber);\n}\n\nlet overrideHookState = null;\nlet overrideProps = null;\nlet scheduleUpdate = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithSetImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    idx: number,\n    value: any,\n  ) => {\n    if (idx >= path.length) {\n      return value;\n    }\n    const key = path[idx];\n    const updated = Array.isArray(obj) ? obj.slice() : {...obj};\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    value: any,\n  ): Object | Array<any> => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  // Support DevTools editable values for useState and useReducer.\n  overrideHookState = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n    value: any,\n  ) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n    if (currentHook !== null) {\n      const newState = copyWithSet(currentHook.memoizedState, path, value);\n      currentHook.memoizedState = newState;\n      currentHook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      scheduleWork(fiber, Sync);\n    }\n  };\n\n  // Support DevTools props for function components, forwardRef, memo, host components, etc.\n  overrideProps = (fiber: Fiber, path: Array<string | number>, value: any) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    scheduleWork(fiber, Sync);\n  };\n\n  scheduleUpdate = (fiber: Fiber) => {\n    scheduleWork(fiber, Sync);\n  };\n\n  setSuspenseHandler = (newShouldSuspendImpl: (Fiber) => boolean) => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nexport function injectIntoDevTools(devToolsConfig: DevToolsConfig): boolean {\n  const {findFiberByHostInstance} = devToolsConfig;\n  const {ReactCurrentDispatcher} = ReactSharedInternals;\n\n  return injectInternals({\n    ...devToolsConfig,\n    overrideHookState,\n    overrideProps,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | null {\n      const hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findFiberByHostInstance(instance: Instance | TextInstance): Fiber | null {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n      return findFiberByHostInstance(instance);\n    },\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? () => ReactCurrentFiberCurrent : null,\n  });\n}\n\nconst {IsSomeRendererActing} = ReactSharedInternals;\nconst isSchedulerMocked =\n  typeof Scheduler.unstable_flushAllWithoutAsserting === 'function';\nconst flushWork =\n  Scheduler.unstable_flushAllWithoutAsserting ||\n  function () {\n    let didFlushWork = false;\n    while (flushPassiveEffects()) {\n      didFlushWork = true;\n    }\n\n    return didFlushWork;\n  };\n\nfunction flushWorkAndMicroTasks(onDone: (err: ?Error) => void) {\n  try {\n    flushWork();\n    enqueueTask(() => {\n      if (flushWork()) {\n        flushWorkAndMicroTasks(onDone);\n      } else {\n        onDone();\n      }\n    });\n  } catch (err) {\n    onDone(err);\n  }\n}\n\n// we track the 'depth' of the act() calls with this counter,\n// so we can tell if any async act() calls try to run in parallel.\n\nlet actingUpdatesScopeDepth = 0;\nlet didWarnAboutUsingActInProd = false;\n\n// eslint-disable-next-line no-inner-declarations\nexport function act(callback: () => Thenable) {\n  if (!__DEV__) {\n    if (didWarnAboutUsingActInProd === false) {\n      didWarnAboutUsingActInProd = true;\n      // eslint-disable-next-line react-internal/no-production-logging\n      console.error(\n        'act(...) is not supported in production builds of React, and might not behave as expected.',\n      );\n    }\n  }\n\n  let previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;\n  let previousIsSomeRendererActing;\n  let previousIsThisRendererActing;\n  actingUpdatesScopeDepth++;\n\n  previousIsSomeRendererActing = IsSomeRendererActing.current;\n  previousIsThisRendererActing = IsThisRendererActing.current;\n  IsSomeRendererActing.current = true;\n  IsThisRendererActing.current = true;\n\n  function onDone() {\n    actingUpdatesScopeDepth--;\n    IsSomeRendererActing.current = previousIsSomeRendererActing;\n    IsThisRendererActing.current = previousIsThisRendererActing;\n    if (__DEV__) {\n      if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {\n        // if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned\n        console.error(\n          'You seem to have overlapping act() calls, this is not supported. ' +\n            'Be sure to await previous act() calls before making a new one. ',\n        );\n      }\n    }\n  }\n\n  let result;\n  try {\n    result = batchedUpdates(callback);\n  } catch (error) {\n    // on sync errors, we still want to 'cleanup' and decrement actingUpdatesScopeDepth\n    onDone();\n    throw error;\n  }\n\n  if (\n    result !== null &&\n    typeof result === 'object' &&\n    typeof result.then === 'function'\n  ) {\n    // setup a boolean that gets set to true only\n    // once this act() call is await-ed\n    let called = false;\n    if (__DEV__) {\n      if (typeof Promise !== 'undefined') {\n        //eslint-disable-next-line no-undef\n        Promise.resolve()\n          .then(() => {})\n          .then(() => {\n            if (called === false) {\n              console.error(\n                'You called act(async () => ...) without await. ' +\n                  'This could lead to unexpected testing behaviour, interleaving multiple act ' +\n                  'calls and mixing their scopes. You should - await act(async () => ...);',\n              );\n            }\n          });\n      }\n    }\n\n    // in the async case, the returned thenable runs the callback, flushes\n    // effects and  microtasks in a loop until flushPassiveEffects() === false,\n    // and cleans up\n    return {\n      then(resolve: () => void, reject: (?Error) => void) {\n        called = true;\n        result.then(\n          () => {\n            if (\n              actingUpdatesScopeDepth > 1 ||\n              (isSchedulerMocked === true &&\n                previousIsSomeRendererActing === true)\n            ) {\n              onDone();\n              resolve();\n              return;\n            }\n            // we're about to exit the act() scope,\n            // now's the time to flush tasks/effects\n            flushWorkAndMicroTasks((err: ?Error) => {\n              onDone();\n              if (err) {\n                reject(err);\n              } else {\n                resolve();\n              }\n            });\n          },\n          (err) => {\n            onDone();\n            reject(err);\n          },\n        );\n      },\n    };\n  } else {\n    if (__DEV__) {\n      if (result !== undefined) {\n        console.error(\n          'The callback passed to act(...) function ' +\n            'must return undefined, or a Promise. You returned %s',\n          result,\n        );\n      }\n    }\n\n    // flush effects until none remain, and cleanup\n    try {\n      if (\n        actingUpdatesScopeDepth === 1 &&\n        (isSchedulerMocked === false || previousIsSomeRendererActing === false)\n      ) {\n        // we're about to exit the act() scope,\n        // now's the time to flush effects\n        flushWork();\n      }\n      onDone();\n    } catch (err) {\n      onDone();\n      throw err;\n    }\n\n    // in the sync case, the returned thenable only warns *if* await-ed\n    return {\n      then(resolve: () => void) {\n        if (__DEV__) {\n          console.error(\n            'Do not await the result of calling act(...) with sync logic, it is not a Promise.',\n          );\n        }\n        resolve();\n      },\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}