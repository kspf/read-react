{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport * as React from 'react';\nimport { Update, Snapshot } from 'shared/ReactSideEffectTags';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, warnAboutDeprecatedLifecycles } from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { isMounted } from 'react-reconciler/reflection';\nimport { get as getInstance, set as setInstance } from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport { REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE } from 'shared/ReactSymbols';\nimport { startPhaseTimer, stopPhaseTimer } from './ReactDebugFiberPerf';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { StrictMode } from './ReactTypeOfMode';\nimport { enqueueUpdate, processUpdateQueue, checkHasForceUpdateAfterProcessing, resetHasForceUpdateBeforeProcessing, createUpdate, ReplaceState, ForceUpdate, initializeUpdateQueue, cloneUpdateQueue } from './ReactUpdateQueue';\nimport { NoWork } from './ReactFiberExpirationTime';\nimport { cacheContext, getMaskedContext, getUnmaskedContext, hasContextChanged, emptyContextObject } from './ReactFiberContext';\nimport { readContext } from './ReactFiberNewContext';\nimport { requestCurrentTimeForUpdate, computeExpirationForFiber, scheduleWork } from './ReactFiberWorkLoop';\nimport { requestCurrentSuspenseConfig } from './ReactFiberSuspenseConfig';\nconst fakeInternalInstance = {};\nconst isArray = Array.isArray; // React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\n\nexport const emptyRefsObject = new React.Component().refs;\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    const key = `${callerName}_${callback}`;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      console.error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentName(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        console.error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nexport function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  const prevState = workInProgress.memoizedState;\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  const partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  const memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  if (workInProgress.expirationTime === NoWork) {\n    // Queue is always non-null for classes\n    const updateQueue = workInProgress.updateQueue;\n    updateQueue.baseState = memoizedState;\n  }\n}\nconst classComponentUpdater = {\n  isMounted,\n\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(currentTime, fiber, suspenseConfig);\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  }\n\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  const instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    if (__DEV__) {\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        // Invoke the function an extra time to help detect side-effects.\n        instance.shouldComponentUpdate(newProps, newState, nextContext);\n      }\n    }\n\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    const shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n    stopPhaseTimer();\n\n    if (__DEV__) {\n      if (shouldUpdate === undefined) {\n        console.error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  const instance = workInProgress.stateNode;\n\n  if (__DEV__) {\n    const name = getComponentName(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        console.error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        console.error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n      console.error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    }\n\n    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n      console.error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    }\n\n    if (instance.propTypes) {\n      console.error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    }\n\n    if (instance.contextType) {\n      console.error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n    }\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        console.error('%s uses the legacy childContextTypes API which is no longer supported. ' + 'Use React.createContext() instead.', name);\n      }\n\n      if (ctor.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with static contextType instead.', name);\n      }\n    } else {\n      if (instance.contextTypes) {\n        console.error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      }\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        console.error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      console.error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      console.error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');\n    }\n\n    if (typeof instance.componentDidUnmount === 'function') {\n      console.error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    }\n\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      console.error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    }\n\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      console.error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    }\n\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      console.error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    }\n\n    const hasMutatedProps = instance.props !== newProps;\n\n    if (instance.props !== undefined && hasMutatedProps) {\n      console.error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    }\n\n    if (instance.defaultProps) {\n      console.error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      console.error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      console.error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      console.error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      console.error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    }\n\n    const state = instance.state;\n\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      console.error('%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n      console.error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  setInstance(instance, workInProgress);\n\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props) {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      let isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        let addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        console.error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  } // Instantiate twice to help detect side-effects.\n\n\n  if (__DEV__) {\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  const instance = new ctor(props, context);\n  const state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentName(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        console.error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        const componentName = getComponentName(ctor) || 'Component';\n        const newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          console.error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-unsafe-component-lifecycles', componentName, newApiName, foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '', foundWillReceivePropsName !== null ? `\\n  ${foundWillReceivePropsName}` : '', foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      console.error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  const oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName = getComponentName(workInProgress.type) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        console.error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  initializeUpdateQueue(workInProgress);\n  const contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentName(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        console.error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n  instance.state = workInProgress.memoizedState;\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  const instance = workInProgress.stateNode;\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n\n      stopPhaseTimer();\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {\n  const instance = workInProgress.stateNode;\n  cloneUpdateQueue(current, workInProgress);\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = workInProgress.type === workInProgress.elementType ? oldProps : resolveDefaultProps(workInProgress.type, oldProps);\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  const oldState = workInProgress.memoizedState;\n  let newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      stopPhaseTimer();\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\nexport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance };","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberClassComponent.js"],"names":["React","Update","Snapshot","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","warnAboutDeprecatedLifecycles","ReactStrictModeWarnings","isMounted","get","getInstance","set","setInstance","shallowEqual","getComponentName","invariant","REACT_CONTEXT_TYPE","REACT_PROVIDER_TYPE","startPhaseTimer","stopPhaseTimer","resolveDefaultProps","StrictMode","enqueueUpdate","processUpdateQueue","checkHasForceUpdateAfterProcessing","resetHasForceUpdateBeforeProcessing","createUpdate","ReplaceState","ForceUpdate","initializeUpdateQueue","cloneUpdateQueue","NoWork","cacheContext","getMaskedContext","getUnmaskedContext","hasContextChanged","emptyContextObject","readContext","requestCurrentTimeForUpdate","computeExpirationForFiber","scheduleWork","requestCurrentSuspenseConfig","fakeInternalInstance","isArray","Array","emptyRefsObject","Component","refs","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnAboutContextTypeAndContextTypes","didWarnAboutInvalidateContextType","__DEV__","Set","didWarnOnInvalidCallback","callback","callerName","key","has","add","console","error","type","partialState","undefined","componentName","Object","defineProperty","enumerable","value","freeze","applyDerivedStateFromProps","workInProgress","ctor","getDerivedStateFromProps","nextProps","prevState","memoizedState","mode","assign","expirationTime","updateQueue","baseState","classComponentUpdater","enqueueSetState","inst","payload","fiber","currentTime","suspenseConfig","update","enqueueReplaceState","tag","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","nextContext","instance","stateNode","shouldComponentUpdate","shouldUpdate","prototype","isPureReactComponent","checkClassInstance","name","renderPresent","render","getInitialState","isReactClassApproved","state","getDefaultProps","propTypes","contextType","childContextTypes","contextTypes","componentShouldUpdate","componentDidUnmount","componentDidReceiveProps","componentWillRecieveProps","UNSAFE_componentWillRecieveProps","hasMutatedProps","props","defaultProps","getSnapshotBeforeUpdate","componentDidUpdate","getDerivedStateFromError","getChildContext","adoptClassInstance","updater","_reactInternalInstance","constructClassInstance","isLegacyContextConsumer","unmaskedContext","context","isValid","$$typeof","_context","addendum","keys","join","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","componentWillMount","__suppressDeprecationWarning","UNSAFE_componentWillMount","componentWillReceiveProps","UNSAFE_componentWillReceiveProps","componentWillUpdate","UNSAFE_componentWillUpdate","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","renderExpirationTime","recordLegacyContextWarning","recordUnsafeLifecycleWarnings","componentDidMount","effectTag","resumeMountClassInstance","memoizedProps","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","updateClassInstance","current","elementType","nextUnmaskedContext"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactFiber';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {UpdateQueue} from './ReactUpdateQueue';\n\nimport * as React from 'react';\nimport {Update, Snapshot} from 'shared/ReactSideEffectTags';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  warnAboutDeprecatedLifecycles,\n} from 'shared/ReactFeatureFlags';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {isMounted} from 'react-reconciler/reflection';\nimport {get as getInstance, set as setInstance} from 'shared/ReactInstanceMap';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport invariant from 'shared/invariant';\nimport {REACT_CONTEXT_TYPE, REACT_PROVIDER_TYPE} from 'shared/ReactSymbols';\n\nimport {startPhaseTimer, stopPhaseTimer} from './ReactDebugFiberPerf';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {StrictMode} from './ReactTypeOfMode';\n\nimport {\n  enqueueUpdate,\n  processUpdateQueue,\n  checkHasForceUpdateAfterProcessing,\n  resetHasForceUpdateBeforeProcessing,\n  createUpdate,\n  ReplaceState,\n  ForceUpdate,\n  initializeUpdateQueue,\n  cloneUpdateQueue,\n} from './ReactUpdateQueue';\nimport {NoWork} from './ReactFiberExpirationTime';\nimport {\n  cacheContext,\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged,\n  emptyContextObject,\n} from './ReactFiberContext';\nimport {readContext} from './ReactFiberNewContext';\nimport {\n  requestCurrentTimeForUpdate,\n  computeExpirationForFiber,\n  scheduleWork,\n} from './ReactFiberWorkLoop';\nimport {requestCurrentSuspenseConfig} from './ReactFiberSuspenseConfig';\n\nconst fakeInternalInstance = {};\nconst isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nexport const emptyRefsObject = new React.Component().refs;\n\nlet didWarnAboutStateAssignmentForComponent;\nlet didWarnAboutUninitializedState;\nlet didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nlet didWarnAboutLegacyLifecyclesAndDerivedState;\nlet didWarnAboutUndefinedDerivedState;\nlet warnOnUndefinedDerivedState;\nlet warnOnInvalidCallback;\nlet didWarnAboutDirectlyAssigningPropsToState;\nlet didWarnAboutContextTypeAndContextTypes;\nlet didWarnAboutInvalidateContextType;\n\nif (__DEV__) {\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n\n  const didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function(callback: mixed, callerName: string) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    const key = `${callerName}_${(callback: any)}`;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      console.error(\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  };\n\n  warnOnUndefinedDerivedState = function(type, partialState) {\n    if (partialState === undefined) {\n      const componentName = getComponentName(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        console.error(\n          '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' +\n            'You have returned undefined.',\n          componentName,\n        );\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        '_processChildContext is not available in React 16+. This likely ' +\n          'means you have multiple copies of React and are attempting to nest ' +\n          'a React 15 tree inside a React 16 tree using ' +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          'to make sure you have only one copy of React (and ideally, switch ' +\n          'to ReactDOM.createPortal).',\n      );\n    },\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nexport function applyDerivedStateFromProps(\n  workInProgress: Fiber,\n  ctor: any,\n  getDerivedStateFromProps: (props: any, state: any) => any,\n  nextProps: any,\n) {\n  const prevState = workInProgress.memoizedState;\n\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  const partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  if (__DEV__) {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  const memoizedState =\n    partialState === null || partialState === undefined\n      ? prevState\n      : Object.assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  if (workInProgress.expirationTime === NoWork) {\n    // Queue is always non-null for classes\n    const updateQueue: UpdateQueue<any> = (workInProgress.updateQueue: any);\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nconst classComponentUpdater = {\n  isMounted,\n  enqueueSetState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState(inst, payload, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate(inst, callback) {\n    const fiber = getInstance(inst);\n    const currentTime = requestCurrentTimeForUpdate();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n      currentTime,\n      fiber,\n      suspenseConfig,\n    );\n\n    const update = createUpdate(expirationTime, suspenseConfig);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n};\n\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext,\n) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    if (__DEV__) {\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode\n      ) {\n        // Invoke the function an extra time to help detect side-effects.\n        instance.shouldComponentUpdate(newProps, newState, nextContext);\n      }\n    }\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    const shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextContext,\n    );\n    stopPhaseTimer();\n\n    if (__DEV__) {\n      if (shouldUpdate === undefined) {\n        console.error(\n          '%s.shouldComponentUpdate(): Returned undefined instead of a ' +\n            'boolean value. Make sure to return true or false.',\n          getComponentName(ctor) || 'Component',\n        );\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress: Fiber, ctor: any, newProps: any) {\n  const instance = workInProgress.stateNode;\n  if (__DEV__) {\n    const name = getComponentName(ctor) || 'Component';\n    const renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        console.error(\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: did you accidentally return an object from the constructor?',\n          name,\n        );\n      } else {\n        console.error(\n          '%s(...): No `render` method found on the returned component ' +\n            'instance: you may have forgotten to define `render`.',\n          name,\n        );\n      }\n    }\n\n    if (\n      instance.getInitialState &&\n      !instance.getInitialState.isReactClassApproved &&\n      !instance.state\n    ) {\n      console.error(\n        'getInitialState was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Did you mean to define a state property instead?',\n        name,\n      );\n    }\n    if (\n      instance.getDefaultProps &&\n      !instance.getDefaultProps.isReactClassApproved\n    ) {\n      console.error(\n        'getDefaultProps was defined on %s, a plain JavaScript class. ' +\n          'This is only supported for classes created using React.createClass. ' +\n          'Use a static property to define defaultProps instead.',\n        name,\n      );\n    }\n    if (instance.propTypes) {\n      console.error(\n        'propTypes was defined as an instance property on %s. Use a static ' +\n          'property to define propTypes instead.',\n        name,\n      );\n    }\n    if (instance.contextType) {\n      console.error(\n        'contextType was defined as an instance property on %s. Use a static ' +\n          'property to define contextType instead.',\n        name,\n      );\n    }\n\n    if (disableLegacyContext) {\n      if (ctor.childContextTypes) {\n        console.error(\n          '%s uses the legacy childContextTypes API which is no longer supported. ' +\n            'Use React.createContext() instead.',\n          name,\n        );\n      }\n      if (ctor.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with static contextType instead.',\n          name,\n        );\n      }\n    } else {\n      if (instance.contextTypes) {\n        console.error(\n          'contextTypes was defined as an instance property on %s. Use a static ' +\n            'property to define contextTypes instead.',\n          name,\n        );\n      }\n\n      if (\n        ctor.contextType &&\n        ctor.contextTypes &&\n        !didWarnAboutContextTypeAndContextTypes.has(ctor)\n      ) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n        console.error(\n          '%s declares both contextTypes and contextType static properties. ' +\n            'The legacy contextTypes property will be ignored.',\n          name,\n        );\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.',\n        name,\n      );\n    }\n    if (\n      ctor.prototype &&\n      ctor.prototype.isPureReactComponent &&\n      typeof instance.shouldComponentUpdate !== 'undefined'\n    ) {\n      console.error(\n        '%s has a method called shouldComponentUpdate(). ' +\n          'shouldComponentUpdate should not be used when extending React.PureComponent. ' +\n          'Please extend React.Component if shouldComponentUpdate is used.',\n        getComponentName(ctor) || 'A pure component',\n      );\n    }\n    if (typeof instance.componentDidUnmount === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentDidUnmount(). But there is no such lifecycle method. ' +\n          'Did you mean componentWillUnmount()?',\n        name,\n      );\n    }\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentDidReceiveProps(). But there is no such lifecycle method. ' +\n          'If you meant to update the state in response to changing props, ' +\n          'use componentWillReceiveProps(). If you meant to fetch data or ' +\n          'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',\n        name,\n      );\n    }\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',\n        name,\n      );\n    }\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      console.error(\n        '%s has a method called ' +\n          'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',\n        name,\n      );\n    }\n    const hasMutatedProps = instance.props !== newProps;\n    if (instance.props !== undefined && hasMutatedProps) {\n      console.error(\n        '%s(...): When calling super() in `%s`, make sure to pass ' +\n          \"up the same props that your component's constructor was passed.\",\n        name,\n        name,\n      );\n    }\n    if (instance.defaultProps) {\n      console.error(\n        'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +\n          ' Instead, define defaultProps as a static property on %s.',\n        name,\n        name,\n      );\n    }\n\n    if (\n      typeof instance.getSnapshotBeforeUpdate === 'function' &&\n      typeof instance.componentDidUpdate !== 'function' &&\n      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)\n    ) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      console.error(\n        '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' +\n          'This component defines getSnapshotBeforeUpdate() only.',\n        getComponentName(ctor),\n      );\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      console.error(\n        '%s: getDerivedStateFromProps() is defined as an instance method ' +\n          'and will be ignored. Instead, declare it as a static method.',\n        name,\n      );\n    }\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      console.error(\n        '%s: getDerivedStateFromError() is defined as an instance method ' +\n          'and will be ignored. Instead, declare it as a static method.',\n        name,\n      );\n    }\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      console.error(\n        '%s: getSnapshotBeforeUpdate() is defined as a static method ' +\n          'and will be ignored. Instead, declare it as an instance method.',\n        name,\n      );\n    }\n    const state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      console.error('%s.state: must be set to an object or null', name);\n    }\n    if (\n      typeof instance.getChildContext === 'function' &&\n      typeof ctor.childContextTypes !== 'object'\n    ) {\n      console.error(\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n          'use getChildContext().',\n        name,\n      );\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress: Fiber, instance: any): void {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  setInstance(instance, workInProgress);\n  if (__DEV__) {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  props: any,\n): any {\n  let isLegacyContextConsumer = false;\n  let unmaskedContext = emptyContextObject;\n  let context = emptyContextObject;\n  const contextType = ctor.contextType;\n\n  if (__DEV__) {\n    if ('contextType' in ctor) {\n      let isValid =\n        // Allow null for conditional declaration\n        contextType === null ||\n        (contextType !== undefined &&\n          contextType.$$typeof === REACT_CONTEXT_TYPE &&\n          contextType._context === undefined); // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n\n        let addendum = '';\n        if (contextType === undefined) {\n          addendum =\n            ' However, it is set to undefined. ' +\n            'This can be caused by a typo or by mixing up named and default imports. ' +\n            'This can also happen due to a circular dependency, so ' +\n            'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum =\n            ' However, it is set to an object with keys {' +\n            Object.keys(contextType).join(', ') +\n            '}.';\n        }\n        console.error(\n          '%s defines an invalid contextType. ' +\n            'contextType should point to the Context object returned by React.createContext().%s',\n          getComponentName(ctor) || 'Component',\n          addendum,\n        );\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext((contextType: any));\n  } else if (!disableLegacyContext) {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    const contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer =\n      contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyContextObject;\n  }\n\n  // Instantiate twice to help detect side-effects.\n  if (__DEV__) {\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  const instance = new ctor(props, context);\n  const state = (workInProgress.memoizedState =\n    instance.state !== null && instance.state !== undefined\n      ? instance.state\n      : null);\n  adoptClassInstance(workInProgress, instance);\n\n  if (__DEV__) {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      const componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        console.error(\n          '`%s` uses `getDerivedStateFromProps` but its initial state is ' +\n            '%s. This is not recommended. Instead, define the initial state by ' +\n            'assigning an object to `this.state` in the constructor of `%s`. ' +\n            'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',\n          componentName,\n          instance.state === null ? 'null' : 'undefined',\n          componentName,\n        );\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (\n      typeof ctor.getDerivedStateFromProps === 'function' ||\n      typeof instance.getSnapshotBeforeUpdate === 'function'\n    ) {\n      let foundWillMountName = null;\n      let foundWillReceivePropsName = null;\n      let foundWillUpdateName = null;\n      if (\n        typeof instance.componentWillMount === 'function' &&\n        instance.componentWillMount.__suppressDeprecationWarning !== true\n      ) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (\n        typeof instance.componentWillReceiveProps === 'function' &&\n        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true\n      ) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (\n        typeof instance.UNSAFE_componentWillReceiveProps === 'function'\n      ) {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (\n        typeof instance.componentWillUpdate === 'function' &&\n        instance.componentWillUpdate.__suppressDeprecationWarning !== true\n      ) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (\n        foundWillMountName !== null ||\n        foundWillReceivePropsName !== null ||\n        foundWillUpdateName !== null\n      ) {\n        const componentName = getComponentName(ctor) || 'Component';\n        const newApiName =\n          typeof ctor.getDerivedStateFromProps === 'function'\n            ? 'getDerivedStateFromProps()'\n            : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(componentName);\n          console.error(\n            'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' +\n              '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' +\n              'The above lifecycles should be removed. Learn more about this warning here:\\n' +\n              'https://fb.me/react-unsafe-component-lifecycles',\n            componentName,\n            newApiName,\n            foundWillMountName !== null ? `\\n  ${foundWillMountName}` : '',\n            foundWillReceivePropsName !== null\n              ? `\\n  ${foundWillReceivePropsName}`\n              : '',\n            foundWillUpdateName !== null ? `\\n  ${foundWillUpdateName}` : '',\n          );\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  const oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    if (__DEV__) {\n      console.error(\n        '%s.componentWillMount(): Assigning directly to this.state is ' +\n          \"deprecated (except inside a component's \" +\n          'constructor). Use setState instead.',\n        getComponentName(workInProgress.type) || 'Component',\n      );\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext,\n) {\n  const oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    if (__DEV__) {\n      const componentName =\n        getComponentName(workInProgress.type) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        console.error(\n          '%s.componentWillReceiveProps(): Assigning directly to ' +\n            \"this.state is deprecated (except inside a component's \" +\n            'constructor). Use setState instead.',\n          componentName,\n        );\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  if (__DEV__) {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  const instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n\n  initializeUpdateQueue(workInProgress);\n\n  const contextType = ctor.contextType;\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else if (disableLegacyContext) {\n    instance.context = emptyContextObject;\n  } else {\n    const unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  if (__DEV__) {\n    if (instance.state === newProps) {\n      const componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        console.error(\n          '%s: It is not recommended to assign props directly to state ' +\n            \"because updates to props won't be reflected in state. \" +\n            'In most cases, it is better to use props directly.',\n          componentName,\n        );\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(\n        workInProgress,\n        instance,\n      );\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(\n        workInProgress,\n        instance,\n      );\n    }\n  }\n\n  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n  instance.state = workInProgress.memoizedState;\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    typeof ctor.getDerivedStateFromProps !== 'function' &&\n    typeof instance.getSnapshotBeforeUpdate !== 'function' &&\n    (typeof instance.UNSAFE_componentWillMount === 'function' ||\n      typeof instance.componentWillMount === 'function')\n  ) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    processUpdateQueue(\n      workInProgress,\n      newProps,\n      instance,\n      renderExpirationTime,\n    );\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextLegacyUnmaskedContext = getUnmaskedContext(\n      workInProgress,\n      ctor,\n      true,\n    );\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n  newState = workInProgress.memoizedState;\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillMount === 'function' ||\n        typeof instance.componentWillMount === 'function')\n    ) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(\n  current: Fiber,\n  workInProgress: Fiber,\n  ctor: any,\n  newProps: any,\n  renderExpirationTime: ExpirationTime,\n): boolean {\n  const instance = workInProgress.stateNode;\n\n  cloneUpdateQueue(current, workInProgress);\n\n  const oldProps = workInProgress.memoizedProps;\n  instance.props =\n    workInProgress.type === workInProgress.elementType\n      ? oldProps\n      : resolveDefaultProps(workInProgress.type, oldProps);\n\n  const oldContext = instance.context;\n  const contextType = ctor.contextType;\n  let nextContext = emptyContextObject;\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else if (!disableLegacyContext) {\n    const nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  const hasNewLifecycles =\n    typeof getDerivedStateFromProps === 'function' ||\n    typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (\n    !hasNewLifecycles &&\n    (typeof instance.UNSAFE_componentWillReceiveProps === 'function' ||\n      typeof instance.componentWillReceiveProps === 'function')\n  ) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        nextContext,\n      );\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  const oldState = workInProgress.memoizedState;\n  let newState = (instance.state = oldState);\n  processUpdateQueue(workInProgress, newProps, instance, renderExpirationTime);\n  newState = workInProgress.memoizedState;\n\n  if (\n    oldProps === newProps &&\n    oldState === newState &&\n    !hasContextChanged() &&\n    !checkHasForceUpdateAfterProcessing()\n  ) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(\n      workInProgress,\n      ctor,\n      getDerivedStateFromProps,\n      newProps,\n    );\n    newState = workInProgress.memoizedState;\n  }\n\n  const shouldUpdate =\n    checkHasForceUpdateAfterProcessing() ||\n    checkShouldComponentUpdate(\n      workInProgress,\n      ctor,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      nextContext,\n    );\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (\n      !hasNewLifecycles &&\n      (typeof instance.UNSAFE_componentWillUpdate === 'function' ||\n        typeof instance.componentWillUpdate === 'function')\n    ) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (\n        oldProps !== current.memoizedProps ||\n        oldState !== current.memoizedState\n      ) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n\n  return shouldUpdate;\n}\n\nexport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n};\n"]},"metadata":{},"sourceType":"module"}