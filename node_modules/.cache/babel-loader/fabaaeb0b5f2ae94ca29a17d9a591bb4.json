{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableDeprecatedFlareAPI, enableSelectiveHydration } from 'shared/ReactFeatureFlags';\nimport { unstable_runWithPriority as runWithPriority, unstable_scheduleCallback as scheduleCallback, unstable_NormalPriority as NormalPriority, unstable_getCurrentPriorityLevel as getCurrentPriorityLevel } from 'scheduler';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/reflection';\nimport { attemptToDispatchEvent, addResponderEventSystemEvent } from './ReactDOMEventListener';\nimport { getListenerMapForElement } from './DOMEventListenerMap';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { unsafeCastDOMTopLevelTypeToString } from 'legacy-events/TopLevelEventTypes';\nimport { HostRoot, SuspenseComponent } from 'shared/ReactWorkTags';\nlet attemptSynchronousHydration;\nexport function setAttemptSynchronousHydration(fn) {\n  attemptSynchronousHydration = fn;\n}\nlet attemptUserBlockingHydration;\nexport function setAttemptUserBlockingHydration(fn) {\n  attemptUserBlockingHydration = fn;\n}\nlet attemptContinuousHydration;\nexport function setAttemptContinuousHydration(fn) {\n  attemptContinuousHydration = fn;\n}\nlet attemptHydrationAtCurrentPriority;\nexport function setAttemptHydrationAtCurrentPriority(fn) {\n  attemptHydrationAtCurrentPriority = fn;\n} // TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\n\nimport { TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE, TOP_FOCUS, TOP_BLUR } from './DOMTopLevelEventTypes';\nimport { IS_REPLAYED } from 'legacy-events/EventSystemFlags';\nimport { legacyListenToTopLevelEvent } from './DOMLegacyEventPluginSystem';\nlet hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.\n\nlet queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.\n\nlet hasAnyQueuedContinuousEvents = false; // The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\n\nlet queuedFocus = null;\nlet queuedDrag = null;\nlet queuedMouse = null; // For pointer events there can be one latest event per pointerId.\n\nlet queuedPointers = new Map();\nlet queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.\n\nlet queuedExplicitHydrationTargets = [];\nexport function hasQueuedDiscreteEvents() {\n  return queuedDiscreteEvents.length > 0;\n}\nexport function hasQueuedContinuousEvents() {\n  return hasAnyQueuedContinuousEvents;\n}\nconst discreteReplayableEvents = [TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_TOUCH_CANCEL, TOP_TOUCH_END, TOP_TOUCH_START, TOP_AUX_CLICK, TOP_DOUBLE_CLICK, TOP_POINTER_CANCEL, TOP_POINTER_DOWN, TOP_POINTER_UP, TOP_DRAG_END, TOP_DRAG_START, TOP_DROP, TOP_COMPOSITION_END, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_INPUT, TOP_TEXT_INPUT, TOP_CLOSE, TOP_CANCEL, TOP_COPY, TOP_CUT, TOP_PASTE, TOP_CLICK, TOP_CHANGE, TOP_CONTEXT_MENU, TOP_RESET, TOP_SUBMIT];\nconst continuousReplayableEvents = [TOP_FOCUS, TOP_BLUR, TOP_DRAG_ENTER, TOP_DRAG_LEAVE, TOP_MOUSE_OVER, TOP_MOUSE_OUT, TOP_POINTER_OVER, TOP_POINTER_OUT, TOP_GOT_POINTER_CAPTURE, TOP_LOST_POINTER_CAPTURE];\nexport function isReplayableDiscreteEvent(eventType) {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction trapReplayableEventForDocument(topLevelType, document, listenerMap) {\n  legacyListenToTopLevelEvent(topLevelType, document, listenerMap);\n\n  if (enableDeprecatedFlareAPI) {\n    // Trap events for the responder system.\n    const topLevelTypeString = unsafeCastDOMTopLevelTypeToString(topLevelType); // TODO: Ideally we shouldn't need these to be active but\n    // if we only have a passive listener, we at least need it\n    // to still pretend to be active so that Flare gets those\n    // events.\n\n    const activeEventKey = topLevelTypeString + '_active';\n\n    if (!listenerMap.has(activeEventKey)) {\n      const listener = addResponderEventSystemEvent(document, topLevelTypeString, false);\n      listenerMap.set(activeEventKey, listener);\n    }\n  }\n}\n\nexport function eagerlyTrapReplayableEvents(container, document) {\n  const listenerMapForDoc = getListenerMapForElement(document); // Discrete\n\n  discreteReplayableEvents.forEach(topLevelType => {\n    trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);\n  }); // Continuous\n\n  continuousReplayableEvents.forEach(topLevelType => {\n    trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);\n  });\n}\n\nfunction createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {\n  return {\n    blockedOn,\n    topLevelType,\n    eventSystemFlags: eventSystemFlags | IS_REPLAYED,\n    nativeEvent,\n    container\n  };\n}\n\nexport function queueDiscreteEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {\n  const queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);\n  queuedDiscreteEvents.push(queuedEvent);\n\n  if (enableSelectiveHydration) {\n    if (queuedDiscreteEvents.length === 1) {\n      // If this was the first discrete event, we might be able to\n      // synchronously unblock it so that preventDefault still works.\n      while (queuedEvent.blockedOn !== null) {\n        let fiber = getInstanceFromNode(queuedEvent.blockedOn);\n\n        if (fiber === null) {\n          break;\n        }\n\n        attemptSynchronousHydration(fiber);\n\n        if (queuedEvent.blockedOn === null) {\n          // We got unblocked by hydration. Let's try again.\n          replayUnblockedEvents(); // If we're reblocked, on an inner boundary, we might need\n          // to attempt hydrating that one.\n\n          continue;\n        } else {\n          // We're still blocked from hydration, we have to give up\n          // and replay later.\n          break;\n        }\n      }\n    }\n  }\n} // Resets the replaying for this type of continuous event to no event.\n\nexport function clearIfContinuousEvent(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_FOCUS:\n    case TOP_BLUR:\n      queuedFocus = null;\n      break;\n\n    case TOP_DRAG_ENTER:\n    case TOP_DRAG_LEAVE:\n      queuedDrag = null;\n      break;\n\n    case TOP_MOUSE_OVER:\n    case TOP_MOUSE_OUT:\n      queuedMouse = null;\n      break;\n\n    case TOP_POINTER_OVER:\n    case TOP_POINTER_OUT:\n      {\n        let pointerId = nativeEvent.pointerId;\n        queuedPointers.delete(pointerId);\n        break;\n      }\n\n    case TOP_GOT_POINTER_CAPTURE:\n    case TOP_LOST_POINTER_CAPTURE:\n      {\n        let pointerId = nativeEvent.pointerId;\n        queuedPointerCaptures.delete(pointerId);\n        break;\n      }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {\n  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n    let queuedEvent = createQueuedReplayableEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent);\n\n    if (blockedOn !== null) {\n      let fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n\n    return queuedEvent;\n  } // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags and store a single event to be\n  // replayed.\n\n\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(blockedOn, topLevelType, eventSystemFlags, container, nativeEvent) {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (topLevelType) {\n    case TOP_FOCUS:\n      {\n        const focusEvent = nativeEvent;\n        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, topLevelType, eventSystemFlags, container, focusEvent);\n        return true;\n      }\n\n    case TOP_DRAG_ENTER:\n      {\n        const dragEvent = nativeEvent;\n        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, topLevelType, eventSystemFlags, container, dragEvent);\n        return true;\n      }\n\n    case TOP_MOUSE_OVER:\n      {\n        const mouseEvent = nativeEvent;\n        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, topLevelType, eventSystemFlags, container, mouseEvent);\n        return true;\n      }\n\n    case TOP_POINTER_OVER:\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, topLevelType, eventSystemFlags, container, pointerEvent));\n        return true;\n      }\n\n    case TOP_GOT_POINTER_CAPTURE:\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, topLevelType, eventSystemFlags, container, pointerEvent));\n        return true;\n      }\n  }\n\n  return false;\n} // Check if this target is unblocked. Returns true if it's unblocked.\n\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  // TODO: This function shares a lot of logic with attemptToDispatchEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  let targetInst = getClosestInstanceFromNode(queuedTarget.target);\n\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          runWithPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (root.hydrate) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of\n          // a root other than sync.\n\n          return;\n        }\n      }\n    }\n  }\n\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target) {\n  if (enableSelectiveHydration) {\n    let priority = getCurrentPriorityLevel();\n    const queuedTarget = {\n      blockedOn: null,\n      target: target,\n      priority: priority\n    };\n    let i = 0;\n\n    for (; i < queuedExplicitHydrationTargets.length; i++) {\n      if (priority <= queuedExplicitHydrationTargets[i].priority) {\n        break;\n      }\n    }\n\n    queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n\n    if (i === 0) {\n      attemptExplicitHydrationTarget(queuedTarget);\n    }\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n\n  let nextBlockedOn = attemptToDispatchEvent(queuedEvent.topLevelType, queuedEvent.eventSystemFlags, queuedEvent.container, queuedEvent.nativeEvent);\n\n  if (nextBlockedOn !== null) {\n    // We're still blocked. Try again later.\n    let fiber = getInstanceFromNode(nextBlockedOn);\n\n    if (fiber !== null) {\n      attemptContinuousHydration(fiber);\n    }\n\n    queuedEvent.blockedOn = nextBlockedOn;\n    return false;\n  }\n\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false; // First replay discrete events.\n\n  while (queuedDiscreteEvents.length > 0) {\n    let nextDiscreteEvent = queuedDiscreteEvents[0];\n\n    if (nextDiscreteEvent.blockedOn !== null) {\n      // We're still blocked.\n      // Increase the priority of this boundary to unblock\n      // the next discrete event.\n      let fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n\n      if (fiber !== null) {\n        attemptUserBlockingHydration(fiber);\n      }\n\n      break;\n    }\n\n    let nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.topLevelType, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.container, nextDiscreteEvent.nativeEvent);\n\n    if (nextBlockedOn !== null) {\n      // We're still blocked. Try again later.\n      nextDiscreteEvent.blockedOn = nextBlockedOn;\n    } else {\n      // We've successfully replayed the first event. Let's try the next one.\n      queuedDiscreteEvents.shift();\n    }\n  } // Next replay any continuous events.\n\n\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(unblocked) {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      let queuedEvent = queuedDiscreteEvents[i];\n\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n\n  const unblock = queuedEvent => scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    let queuedTarget = queuedExplicitHydrationTargets[i];\n\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    let nextExplicitTarget = queuedExplicitHydrationTargets[0];\n\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-dom/src/events/ReactDOMEventReplaying.js"],"names":["enableDeprecatedFlareAPI","enableSelectiveHydration","unstable_runWithPriority","runWithPriority","unstable_scheduleCallback","scheduleCallback","unstable_NormalPriority","NormalPriority","unstable_getCurrentPriorityLevel","getCurrentPriorityLevel","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","attemptToDispatchEvent","addResponderEventSystemEvent","getListenerMapForElement","getInstanceFromNode","getClosestInstanceFromNode","unsafeCastDOMTopLevelTypeToString","HostRoot","SuspenseComponent","attemptSynchronousHydration","setAttemptSynchronousHydration","fn","attemptUserBlockingHydration","setAttemptUserBlockingHydration","attemptContinuousHydration","setAttemptContinuousHydration","attemptHydrationAtCurrentPriority","setAttemptHydrationAtCurrentPriority","TOP_MOUSE_DOWN","TOP_MOUSE_UP","TOP_TOUCH_CANCEL","TOP_TOUCH_END","TOP_TOUCH_START","TOP_AUX_CLICK","TOP_DOUBLE_CLICK","TOP_POINTER_CANCEL","TOP_POINTER_DOWN","TOP_POINTER_UP","TOP_DRAG_END","TOP_DRAG_START","TOP_DROP","TOP_COMPOSITION_END","TOP_COMPOSITION_START","TOP_KEY_DOWN","TOP_KEY_PRESS","TOP_KEY_UP","TOP_INPUT","TOP_TEXT_INPUT","TOP_CLOSE","TOP_CANCEL","TOP_COPY","TOP_CUT","TOP_PASTE","TOP_CLICK","TOP_CHANGE","TOP_CONTEXT_MENU","TOP_RESET","TOP_SUBMIT","TOP_DRAG_ENTER","TOP_DRAG_LEAVE","TOP_MOUSE_OVER","TOP_MOUSE_OUT","TOP_POINTER_OVER","TOP_POINTER_OUT","TOP_GOT_POINTER_CAPTURE","TOP_LOST_POINTER_CAPTURE","TOP_FOCUS","TOP_BLUR","IS_REPLAYED","legacyListenToTopLevelEvent","hasScheduledReplayAttempt","queuedDiscreteEvents","hasAnyQueuedContinuousEvents","queuedFocus","queuedDrag","queuedMouse","queuedPointers","Map","queuedPointerCaptures","queuedExplicitHydrationTargets","hasQueuedDiscreteEvents","length","hasQueuedContinuousEvents","discreteReplayableEvents","continuousReplayableEvents","isReplayableDiscreteEvent","eventType","indexOf","trapReplayableEventForDocument","topLevelType","document","listenerMap","topLevelTypeString","activeEventKey","has","listener","set","eagerlyTrapReplayableEvents","container","listenerMapForDoc","forEach","createQueuedReplayableEvent","blockedOn","eventSystemFlags","nativeEvent","queueDiscreteEvent","queuedEvent","push","fiber","replayUnblockedEvents","clearIfContinuousEvent","pointerId","delete","accumulateOrCreateContinuousQueuedReplayableEvent","existingQueuedEvent","queueIfContinuousEvent","focusEvent","dragEvent","mouseEvent","pointerEvent","get","attemptExplicitHydrationTarget","queuedTarget","targetInst","target","nearestMounted","tag","instance","priority","root","stateNode","hydrate","queueExplicitHydrationTarget","i","splice","attemptReplayContinuousQueuedEvent","nextBlockedOn","attemptReplayContinuousQueuedEventInMap","key","map","nextDiscreteEvent","shift","scheduleCallbackIfUnblocked","unblocked","retryIfBlockedOn","unblock","nextExplicitTarget"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from 'legacy-events/PluginModuleType';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMTopLevelEventType} from 'legacy-events/TopLevelEventTypes';\nimport type {EventSystemFlags} from 'legacy-events/EventSystemFlags';\nimport type {FiberRoot} from 'react-reconciler/src/ReactFiberRoot';\n\nimport {\n  enableDeprecatedFlareAPI,\n  enableSelectiveHydration,\n} from 'shared/ReactFeatureFlags';\nimport {\n  unstable_runWithPriority as runWithPriority,\n  unstable_scheduleCallback as scheduleCallback,\n  unstable_NormalPriority as NormalPriority,\n  unstable_getCurrentPriorityLevel as getCurrentPriorityLevel,\n} from 'scheduler';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/reflection';\nimport {\n  attemptToDispatchEvent,\n  addResponderEventSystemEvent,\n} from './ReactDOMEventListener';\nimport {getListenerMapForElement} from './DOMEventListenerMap';\nimport {\n  getInstanceFromNode,\n  getClosestInstanceFromNode,\n} from '../client/ReactDOMComponentTree';\nimport {unsafeCastDOMTopLevelTypeToString} from 'legacy-events/TopLevelEventTypes';\nimport {HostRoot, SuspenseComponent} from 'shared/ReactWorkTags';\n\nlet attemptSynchronousHydration: (fiber: Object) => void;\n\nexport function setAttemptSynchronousHydration(fn: (fiber: Object) => void) {\n  attemptSynchronousHydration = fn;\n}\n\nlet attemptUserBlockingHydration: (fiber: Object) => void;\n\nexport function setAttemptUserBlockingHydration(fn: (fiber: Object) => void) {\n  attemptUserBlockingHydration = fn;\n}\n\nlet attemptContinuousHydration: (fiber: Object) => void;\n\nexport function setAttemptContinuousHydration(fn: (fiber: Object) => void) {\n  attemptContinuousHydration = fn;\n}\n\nlet attemptHydrationAtCurrentPriority: (fiber: Object) => void;\n\nexport function setAttemptHydrationAtCurrentPriority(\n  fn: (fiber: Object) => void,\n) {\n  attemptHydrationAtCurrentPriority = fn;\n}\n\n// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\ntype PointerEvent = Event & {\n  pointerId: number,\n  relatedTarget: EventTarget | null,\n  ...\n};\n\nimport {\n  TOP_MOUSE_DOWN,\n  TOP_MOUSE_UP,\n  TOP_TOUCH_CANCEL,\n  TOP_TOUCH_END,\n  TOP_TOUCH_START,\n  TOP_AUX_CLICK,\n  TOP_DOUBLE_CLICK,\n  TOP_POINTER_CANCEL,\n  TOP_POINTER_DOWN,\n  TOP_POINTER_UP,\n  TOP_DRAG_END,\n  TOP_DRAG_START,\n  TOP_DROP,\n  TOP_COMPOSITION_END,\n  TOP_COMPOSITION_START,\n  TOP_KEY_DOWN,\n  TOP_KEY_PRESS,\n  TOP_KEY_UP,\n  TOP_INPUT,\n  TOP_TEXT_INPUT,\n  TOP_CLOSE,\n  TOP_CANCEL,\n  TOP_COPY,\n  TOP_CUT,\n  TOP_PASTE,\n  TOP_CLICK,\n  TOP_CHANGE,\n  TOP_CONTEXT_MENU,\n  TOP_RESET,\n  TOP_SUBMIT,\n  TOP_DRAG_ENTER,\n  TOP_DRAG_LEAVE,\n  TOP_MOUSE_OVER,\n  TOP_MOUSE_OUT,\n  TOP_POINTER_OVER,\n  TOP_POINTER_OUT,\n  TOP_GOT_POINTER_CAPTURE,\n  TOP_LOST_POINTER_CAPTURE,\n  TOP_FOCUS,\n  TOP_BLUR,\n} from './DOMTopLevelEventTypes';\nimport {IS_REPLAYED} from 'legacy-events/EventSystemFlags';\nimport {legacyListenToTopLevelEvent} from './DOMLegacyEventPluginSystem';\n\ntype QueuedReplayableEvent = {|\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  container: Document | Element | Node,\n|};\n\nlet hasScheduledReplayAttempt = false;\n\n// The queue of discrete events to be replayed.\nlet queuedDiscreteEvents: Array<QueuedReplayableEvent> = [];\n\n// Indicates if any continuous event targets are non-null for early bailout.\nlet hasAnyQueuedContinuousEvents: boolean = false;\n// The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\nlet queuedFocus: null | QueuedReplayableEvent = null;\nlet queuedDrag: null | QueuedReplayableEvent = null;\nlet queuedMouse: null | QueuedReplayableEvent = null;\n// For pointer events there can be one latest event per pointerId.\nlet queuedPointers: Map<number, QueuedReplayableEvent> = new Map();\nlet queuedPointerCaptures: Map<number, QueuedReplayableEvent> = new Map();\n// We could consider replaying selectionchange and touchmoves too.\n\ntype QueuedHydrationTarget = {|\n  blockedOn: null | Container | SuspenseInstance,\n  target: Node,\n  priority: number,\n|};\nlet queuedExplicitHydrationTargets: Array<QueuedHydrationTarget> = [];\n\nexport function hasQueuedDiscreteEvents(): boolean {\n  return queuedDiscreteEvents.length > 0;\n}\n\nexport function hasQueuedContinuousEvents(): boolean {\n  return hasAnyQueuedContinuousEvents;\n}\n\nconst discreteReplayableEvents = [\n  TOP_MOUSE_DOWN,\n  TOP_MOUSE_UP,\n  TOP_TOUCH_CANCEL,\n  TOP_TOUCH_END,\n  TOP_TOUCH_START,\n  TOP_AUX_CLICK,\n  TOP_DOUBLE_CLICK,\n  TOP_POINTER_CANCEL,\n  TOP_POINTER_DOWN,\n  TOP_POINTER_UP,\n  TOP_DRAG_END,\n  TOP_DRAG_START,\n  TOP_DROP,\n  TOP_COMPOSITION_END,\n  TOP_COMPOSITION_START,\n  TOP_KEY_DOWN,\n  TOP_KEY_PRESS,\n  TOP_KEY_UP,\n  TOP_INPUT,\n  TOP_TEXT_INPUT,\n  TOP_CLOSE,\n  TOP_CANCEL,\n  TOP_COPY,\n  TOP_CUT,\n  TOP_PASTE,\n  TOP_CLICK,\n  TOP_CHANGE,\n  TOP_CONTEXT_MENU,\n  TOP_RESET,\n  TOP_SUBMIT,\n];\n\nconst continuousReplayableEvents = [\n  TOP_FOCUS,\n  TOP_BLUR,\n  TOP_DRAG_ENTER,\n  TOP_DRAG_LEAVE,\n  TOP_MOUSE_OVER,\n  TOP_MOUSE_OUT,\n  TOP_POINTER_OVER,\n  TOP_POINTER_OUT,\n  TOP_GOT_POINTER_CAPTURE,\n  TOP_LOST_POINTER_CAPTURE,\n];\n\nexport function isReplayableDiscreteEvent(\n  eventType: DOMTopLevelEventType,\n): boolean {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction trapReplayableEventForDocument(\n  topLevelType: DOMTopLevelEventType,\n  document: Document,\n  listenerMap: Map<DOMTopLevelEventType | string, null | (any => void)>,\n) {\n  legacyListenToTopLevelEvent(topLevelType, document, listenerMap);\n  if (enableDeprecatedFlareAPI) {\n    // Trap events for the responder system.\n    const topLevelTypeString = unsafeCastDOMTopLevelTypeToString(topLevelType);\n    // TODO: Ideally we shouldn't need these to be active but\n    // if we only have a passive listener, we at least need it\n    // to still pretend to be active so that Flare gets those\n    // events.\n    const activeEventKey = topLevelTypeString + '_active';\n    if (!listenerMap.has(activeEventKey)) {\n      const listener = addResponderEventSystemEvent(\n        document,\n        topLevelTypeString,\n        false,\n      );\n      listenerMap.set(activeEventKey, listener);\n    }\n  }\n}\n\nexport function eagerlyTrapReplayableEvents(\n  container: Container,\n  document: Document,\n) {\n  const listenerMapForDoc = getListenerMapForElement(document);\n  // Discrete\n  discreteReplayableEvents.forEach(topLevelType => {\n    trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);\n  });\n  // Continuous\n  continuousReplayableEvents.forEach(topLevelType => {\n    trapReplayableEventForDocument(topLevelType, document, listenerMapForDoc);\n  });\n}\n\nfunction createQueuedReplayableEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  container: Document | Element | Node,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  return {\n    blockedOn,\n    topLevelType,\n    eventSystemFlags: eventSystemFlags | IS_REPLAYED,\n    nativeEvent,\n    container,\n  };\n}\n\nexport function queueDiscreteEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  container: Document | Element | Node,\n  nativeEvent: AnyNativeEvent,\n): void {\n  const queuedEvent = createQueuedReplayableEvent(\n    blockedOn,\n    topLevelType,\n    eventSystemFlags,\n    container,\n    nativeEvent,\n  );\n  queuedDiscreteEvents.push(queuedEvent);\n  if (enableSelectiveHydration) {\n    if (queuedDiscreteEvents.length === 1) {\n      // If this was the first discrete event, we might be able to\n      // synchronously unblock it so that preventDefault still works.\n      while (queuedEvent.blockedOn !== null) {\n        let fiber = getInstanceFromNode(queuedEvent.blockedOn);\n        if (fiber === null) {\n          break;\n        }\n        attemptSynchronousHydration(fiber);\n        if (queuedEvent.blockedOn === null) {\n          // We got unblocked by hydration. Let's try again.\n          replayUnblockedEvents();\n          // If we're reblocked, on an inner boundary, we might need\n          // to attempt hydrating that one.\n          continue;\n        } else {\n          // We're still blocked from hydration, we have to give up\n          // and replay later.\n          break;\n        }\n      }\n    }\n  }\n}\n\n// Resets the replaying for this type of continuous event to no event.\nexport function clearIfContinuousEvent(\n  topLevelType: DOMTopLevelEventType,\n  nativeEvent: AnyNativeEvent,\n): void {\n  switch (topLevelType) {\n    case TOP_FOCUS:\n    case TOP_BLUR:\n      queuedFocus = null;\n      break;\n    case TOP_DRAG_ENTER:\n    case TOP_DRAG_LEAVE:\n      queuedDrag = null;\n      break;\n    case TOP_MOUSE_OVER:\n    case TOP_MOUSE_OUT:\n      queuedMouse = null;\n      break;\n    case TOP_POINTER_OVER:\n    case TOP_POINTER_OUT: {\n      let pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointers.delete(pointerId);\n      break;\n    }\n    case TOP_GOT_POINTER_CAPTURE:\n    case TOP_LOST_POINTER_CAPTURE: {\n      let pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointerCaptures.delete(pointerId);\n      break;\n    }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent: null | QueuedReplayableEvent,\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  container: Document | Element | Node,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  if (\n    existingQueuedEvent === null ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  ) {\n    let queuedEvent = createQueuedReplayableEvent(\n      blockedOn,\n      topLevelType,\n      eventSystemFlags,\n      container,\n      nativeEvent,\n    );\n    if (blockedOn !== null) {\n      let fiber = getInstanceFromNode(blockedOn);\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n    return queuedEvent;\n  }\n  // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags and store a single event to be\n  // replayed.\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  topLevelType: DOMTopLevelEventType,\n  eventSystemFlags: EventSystemFlags,\n  container: Document | Element | Node,\n  nativeEvent: AnyNativeEvent,\n): boolean {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (topLevelType) {\n    case TOP_FOCUS: {\n      const focusEvent = ((nativeEvent: any): FocusEvent);\n      queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedFocus,\n        blockedOn,\n        topLevelType,\n        eventSystemFlags,\n        container,\n        focusEvent,\n      );\n      return true;\n    }\n    case TOP_DRAG_ENTER: {\n      const dragEvent = ((nativeEvent: any): DragEvent);\n      queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedDrag,\n        blockedOn,\n        topLevelType,\n        eventSystemFlags,\n        container,\n        dragEvent,\n      );\n      return true;\n    }\n    case TOP_MOUSE_OVER: {\n      const mouseEvent = ((nativeEvent: any): MouseEvent);\n      queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedMouse,\n        blockedOn,\n        topLevelType,\n        eventSystemFlags,\n        container,\n        mouseEvent,\n      );\n      return true;\n    }\n    case TOP_POINTER_OVER: {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          topLevelType,\n          eventSystemFlags,\n          container,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n    case TOP_GOT_POINTER_CAPTURE: {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointerCaptures.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointerCaptures.get(pointerId) || null,\n          blockedOn,\n          topLevelType,\n          eventSystemFlags,\n          container,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n  }\n  return false;\n}\n\n// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(\n  queuedTarget: QueuedHydrationTarget,\n): void {\n  // TODO: This function shares a lot of logic with attemptToDispatchEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  let targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (targetInst !== null) {\n    let nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        let instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          runWithPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (root.hydrate) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n          // We don't currently have a way to increase the priority of\n          // a root other than sync.\n          return;\n        }\n      }\n    }\n  }\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target: Node): void {\n  if (enableSelectiveHydration) {\n    let priority = getCurrentPriorityLevel();\n    const queuedTarget: QueuedHydrationTarget = {\n      blockedOn: null,\n      target: target,\n      priority: priority,\n    };\n    let i = 0;\n    for (; i < queuedExplicitHydrationTargets.length; i++) {\n      if (priority <= queuedExplicitHydrationTargets[i].priority) {\n        break;\n      }\n    }\n    queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n    if (i === 0) {\n      attemptExplicitHydrationTarget(queuedTarget);\n    }\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(\n  queuedEvent: QueuedReplayableEvent,\n): boolean {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n  let nextBlockedOn = attemptToDispatchEvent(\n    queuedEvent.topLevelType,\n    queuedEvent.eventSystemFlags,\n    queuedEvent.container,\n    queuedEvent.nativeEvent,\n  );\n  if (nextBlockedOn !== null) {\n    // We're still blocked. Try again later.\n    let fiber = getInstanceFromNode(nextBlockedOn);\n    if (fiber !== null) {\n      attemptContinuousHydration(fiber);\n    }\n    queuedEvent.blockedOn = nextBlockedOn;\n    return false;\n  }\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(\n  queuedEvent: QueuedReplayableEvent,\n  key: number,\n  map: Map<number, QueuedReplayableEvent>,\n): void {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n  // First replay discrete events.\n  while (queuedDiscreteEvents.length > 0) {\n    let nextDiscreteEvent = queuedDiscreteEvents[0];\n    if (nextDiscreteEvent.blockedOn !== null) {\n      // We're still blocked.\n      // Increase the priority of this boundary to unblock\n      // the next discrete event.\n      let fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n      if (fiber !== null) {\n        attemptUserBlockingHydration(fiber);\n      }\n      break;\n    }\n    let nextBlockedOn = attemptToDispatchEvent(\n      nextDiscreteEvent.topLevelType,\n      nextDiscreteEvent.eventSystemFlags,\n      nextDiscreteEvent.container,\n      nextDiscreteEvent.nativeEvent,\n    );\n    if (nextBlockedOn !== null) {\n      // We're still blocked. Try again later.\n      nextDiscreteEvent.blockedOn = nextBlockedOn;\n    } else {\n      // We've successfully replayed the first event. Let's try the next one.\n      queuedDiscreteEvents.shift();\n    }\n  }\n  // Next replay any continuous events.\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(\n  queuedEvent: QueuedReplayableEvent,\n  unblocked: Container | SuspenseInstance,\n) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true;\n      // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(\n  unblocked: Container | SuspenseInstance,\n): void {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n    // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      let queuedEvent = queuedDiscreteEvents[i];\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n  const unblock = queuedEvent =>\n    scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    let queuedTarget = queuedExplicitHydrationTargets[i];\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    let nextExplicitTarget = queuedExplicitHydrationTargets[0];\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}