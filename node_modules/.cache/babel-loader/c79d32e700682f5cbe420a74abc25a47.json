{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport checkPropTypes from 'prop-types/checkPropTypes';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostText, HostPortal, ForwardRef, Fragment, Mode, ContextProvider, ContextConsumer, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, FundamentalComponent, ScopeComponent, Block } from 'shared/ReactWorkTags';\nimport { NoEffect, PerformedWork, Placement, Hydrating, ContentReset, DidCapture, Update, Ref, Deletion } from 'shared/ReactSideEffectTags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, enableProfilerTimer, enableSchedulerTracing, enableSuspenseServerRenderer, enableFundamentalAPI, warnAboutDefaultPropsOnFunctionComponents, enableScopeAPI, enableBlocksAPI } from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { refineResolvedLazyComponent } from 'shared/ReactLazyComponent';\nimport { REACT_LAZY_TYPE, getIteratorFn } from 'shared/ReactSymbols';\nimport { getCurrentFiberOwnerNameInDevOrNull, getCurrentFiberStackInDev, setIsRendering } from './ReactCurrentFiber';\nimport { startWorkTimer, cancelWorkTimer } from './ReactDebugFiberPerf';\nimport { resolveFunctionForHotReloading, resolveForwardRefForHotReloading, resolveClassForHotReloading } from './ReactFiberHotReloading';\nimport { mountChildFibers, reconcileChildFibers, cloneChildFibers } from './ReactChildFiber';\nimport { processUpdateQueue, cloneUpdateQueue, initializeUpdateQueue } from './ReactUpdateQueue';\nimport { NoWork, Never, Sync, computeAsyncExpiration } from './ReactFiberExpirationTime';\nimport { ConcurrentMode, NoMode, ProfileMode, StrictMode, BlockingMode } from './ReactTypeOfMode';\nimport { shouldSetTextContent, shouldDeprioritizeSubtree, isSuspenseInstancePending, isSuspenseInstanceFallback, registerSuspenseInstanceRetry } from './ReactFiberHostConfig';\nimport { shouldSuspend } from './ReactFiberReconciler';\nimport { pushHostContext, pushHostContainer } from './ReactFiberHostContext';\nimport { suspenseStackCursor, pushSuspenseContext, InvisibleParentSuspenseContext, ForceSuspenseFallback, hasSuspenseContext, setDefaultShallowSuspenseContext, addSubtreeSuspenseContext, setShallowSuspenseContext } from './ReactFiberSuspenseContext';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent';\nimport { pushProvider, propagateContextChange, readContext, prepareToReadContext, calculateChangedBits, scheduleWorkOnParentPath } from './ReactFiberNewContext';\nimport { renderWithHooks, bailoutHooks } from './ReactFiberHooks';\nimport { stopProfilerTimerIfRunning } from './ReactProfilerTimer';\nimport { getMaskedContext, getUnmaskedContext, hasContextChanged as hasLegacyContextChanged, pushContextProvider as pushLegacyContextProvider, isContextProvider as isLegacyContextProvider, pushTopLevelContextObject, invalidateContextProvider } from './ReactFiberContext';\nimport { enterHydrationState, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, tryToClaimNextHydratableInstance, warnIfHydrating } from './ReactFiberHydrationContext';\nimport { adoptClassInstance, applyDerivedStateFromProps, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance } from './ReactFiberClassComponent';\nimport { readLazyComponentType, resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { resolveLazyComponentTag, createFiberFromTypeAndProps, createFiberFromFragment, createWorkInProgress, isSimpleFunctionComponent } from './ReactFiber';\nimport { markSpawnedWork, requestCurrentTimeForUpdate, retryDehydratedSuspenseBoundary, scheduleWork, renderDidSuspendDelayIfPossible, markUnprocessedUpdateTime } from './ReactFiberWorkLoop';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet didReceiveUpdate = false;\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n} // 构建子级 Fiber 对象\n\n\nexport function reconcileChildren( // 旧 Fiber\ncurrent, // 父级 Fiber\nworkInProgress, // 子级 vdom 对象\nnextChildren, // 初始渲染 整型最大值 代表同步任务\nrenderExpirationTime) {\n  /**\n   * 为什么要传递 current ?\n   * 如果不是初始渲染的情况, 要进行新旧 Fiber 对比\n   * 初始渲染时则用不到 current\n   */\n  // 如果就 Fiber 为 null 表示初始渲染\n  if (current === null) {\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // 否则就是更新\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderExpirationTime); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderExpirationTime) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(Component), getCurrentFiberStackInDev);\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderExpirationTime);\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {\n  if (current === null) {\n    let type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      let resolvedType = type;\n\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateExpirationTime, renderExpirationTime);\n    }\n\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(type), getCurrentFiberStackInDev);\n      }\n    }\n\n    let child = createFiberFromTypeAndProps(Component.type, null, nextProps, null, workInProgress.mode, renderExpirationTime);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentName(type), getCurrentFiberStackInDev);\n    }\n  }\n\n  let currentChild = current.child; // This is always exactly one child\n\n  if (updateExpirationTime < renderExpirationTime) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  let newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        outerMemoType = refineResolvedLazyComponent(outerMemoType);\n      }\n\n      const outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n      if (outerPropTypes) {\n        checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n        'prop', getComponentName(outerMemoType), getCurrentFiberStackInDev);\n      } // Inner propTypes will be validated in the function component path.\n\n    }\n  }\n\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n    __DEV__ ? workInProgress.type === current.type : true)) {\n      didReceiveUpdate = false;\n\n      if (updateExpirationTime < renderExpirationTime) {\n        // The pending update priority was cleared at the beginning of\n        // beginWork. We're about to bail out, but there might be additional\n        // updates at a lower priority. Usually, the priority level of the\n        // remaining updates is accumlated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.expirationTime = current.expirationTime;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime);\n}\n\nfunction updateFragment(current, workInProgress, renderExpirationTime) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderExpirationTime) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  const ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(Component), getCurrentFiberStackInDev);\n      }\n    }\n  }\n\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderExpirationTime);\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateBlock(current, workInProgress, block, nextProps, renderExpirationTime) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  const render = block.render;\n  const data = block.query(); // The rest is a fork of updateFunctionComponent\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, data, renderExpirationTime);\n\n    if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, data, renderExpirationTime);\n      }\n    }\n\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, data, renderExpirationTime);\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderExpirationTime) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentName(Component), getCurrentFiberStackInDev);\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n\n  if (instance === null) {\n    if (current !== null) {\n      // A class component without an instance only mounts if it suspended\n      // inside a non-concurrent tree, in an inconsistent state. We want to\n      // treat it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.effectTag |= Placement;\n    } // In the initial pass we might need to construct the instance.\n\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime);\n  }\n\n  const nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);\n\n  if (__DEV__) {\n    let inst = workInProgress.stateNode;\n\n    if (inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  const didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  }\n\n  const instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        instance.render();\n      }\n\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderExpirationTime);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n} // 更新 hostRoot\n// <div id=\"root\"></div> 对应的 Fiber 对象\n\n\nfunction updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress); // 获取更新队列\n\n  const updateQueue = workInProgress.updateQueue;\n  invariant(current !== null && updateQueue !== null, 'If the root does not have an updateQueue, we should have already ' + 'bailed out. This error is likely caused by a bug in React. Please ' + 'file an issue.'); // 获取新的 props 对象 null\n\n  const nextProps = workInProgress.pendingProps; // 获取上一次渲染使用的 state null\n\n  const prevState = workInProgress.memoizedState; // 获取上一次渲染使用的 children null\n\n  const prevChildren = prevState !== null ? prevState.element : null; // 浅复制更新队列, 防止引用属性互相影响\n  // workInProgress.updateQueue 浅拷贝 current.updateQueue\n\n  cloneUpdateQueue(current, workInProgress); // 获取 updateQueue.payload 并赋值到 workInProgress.memoizedState\n  // 要更新的内容就是 element 就是 rootFiber 的子元素\n\n  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime); // 获取 element 所在对象\n\n  const nextState = workInProgress.memoizedState; // 从对象中获取 element\n\n  const nextChildren = nextState.element; // 在计算 state 后如果前后两个 Children 相同的情况\n  // prevChildren => null\n  // nextState => App\n  // false\n\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n  } // 获取 fiberRoot 对象\n\n\n  const root = workInProgress.stateNode; // 服务器端渲染走 if\n\n  if (root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n    let child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    workInProgress.child = child;\n    let node = child;\n\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag = node.effectTag & ~Placement | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // 客户端渲染走 else\n    // 构建子节点 fiber 对象\n    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n    resetHydrationState();\n  } // 返回子节点 fiber 对象\n\n\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.\n\n  if (workInProgress.mode & ConcurrentMode && renderExpirationTime !== Never && shouldDeprioritizeSubtree(type, nextProps)) {\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n    return null;\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, updateExpirationTime, renderExpirationTime) {\n  if (_current !== null) {\n    // A lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.effectTag |= Placement;\n  }\n\n  const props = workInProgress.pendingProps; // We can't start a User Timing measurement with correct label yet.\n  // Cancel and resume right after we know the tag.\n\n  cancelWorkTimer(workInProgress);\n  let Component = readLazyComponentType(elementType); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  const resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  startWorkTimer(workInProgress);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        if (__DEV__) {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderExpirationTime);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderExpirationTime);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentName(Component), getCurrentFiberStackInDev);\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        updateExpirationTime, renderExpirationTime);\n        return child;\n      }\n\n    case Block:\n      {\n        if (enableBlocksAPI) {\n          // TODO: Resolve for Hot Reloading.\n          child = updateBlock(null, workInProgress, Component, props, renderExpirationTime);\n          return child;\n        }\n\n        break;\n      }\n  }\n\n  let hint = '';\n\n  if (__DEV__) {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  invariant(false, 'Element type is invalid. Received a promise that resolves to: %s. ' + 'Lazy element type must resolve to a class or function.%s', Component, hint);\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderExpirationTime) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.effectTag |= Placement;\n  } // Promote the fiber to a class and try rendering again.\n\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);\n}\n\nfunction mountIndeterminateComponent( // 旧 Fiber\n_current, // 新 Fiber\nworkInProgress, // 新 Fiber 的 type 属性值 初始渲染时 是 App 组件函数\nComponent, // 整数最大值 表示同步任务\nrenderExpirationTime) {\n  // _current => null\n  // false\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.effectTag |= Placement;\n  } // 为组件添加的 props <App test=\"test\"/>\n\n\n  const props = workInProgress.pendingProps;\n  let context; // disableLegacyContext 常量 默认值 false\n  // true\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime); // 函数组件被调用后的返回值\n\n  let value;\n\n  if (__DEV__) {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);\n    setIsRendering(false);\n  } else {\n    // 获取 Children 内部会调用 Component()\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork; // 判断 value 是函数组件还是类组件\n  // 条件成立就是类组件 不成立就是函数组件\n\n  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    if (__DEV__) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    } // 类组件\n    // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    let hasContext = false;\n\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    const getDerivedStateFromProps = Component.getDerivedStateFromProps;\n\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderExpirationTime);\n  } else {\n    // 函数组件\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentName(Component) || 'Unknown');\n      }\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        // Only double-render components with Hooks\n        if (workInProgress.memoizedState !== null) {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderExpirationTime);\n        }\n      }\n    }\n\n    reconcileChildren(null, workInProgress, value, renderExpirationTime);\n\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || workInProgress._debugID || '';\n      const debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if (warnAboutDefaultPropsOnFunctionComponents && Component.defaultProps !== undefined) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support getDerivedStateFromProps.', componentName);\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support contextType.', componentName);\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER = {\n  dehydrated: null,\n  retryTime: NoWork\n};\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress) {\n  // If the context is telling us that we should show a fallback, and we're not\n  // already showing content, then we should show the fallback instead.\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback) && (current === null || current.memoizedState !== null);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderExpirationTime) {\n  const mode = workInProgress.mode;\n  const nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.effectTag |= DidCapture;\n    }\n  }\n\n  let suspenseContext = suspenseStackCursor.current;\n  let nextDidTimeout = false;\n  const didSuspend = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current, workInProgress)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    nextDidTimeout = true;\n    workInProgress.effectTag &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Boundaries without fallbacks or should be avoided are not considered since\n      // they cannot handle preferred fallback states.\n      if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext); // This next part is a bit confusing. If the children timeout, we switch to\n  // showing the fallback children in place of the \"primary\" children.\n  // However, we don't want to delete the primary children because then their\n  // state will be lost (both the React state and the host state, e.g.\n  // uncontrolled form inputs). Instead we keep them mounted and hide them.\n  // Both the fallback children AND the primary children are rendered at the\n  // same time. Once the primary children are un-suspended, we can delete\n  // the fallback children — don't need to preserve their state.\n  //\n  // The two sets of children are siblings in the host environment, but\n  // semantically, for purposes of reconciliation, they are two separate sets.\n  // So we store them using two fragment fibers.\n  //\n  // However, we want to avoid allocating extra fibers for every placeholder.\n  // They're only necessary when the children time out, because that's the\n  // only time when both sets are mounted.\n  //\n  // So, the extra fragment fibers are only used if the children time out.\n  // Otherwise, we render the primary children directly. This requires some\n  // custom reconciliation logic to preserve the state of the primary\n  // children. It's essentially a very basic form of re-parenting.\n\n  if (current === null) {\n    // If we're currently hydrating, try to hydrate this boundary.\n    // But only if this has a fallback.\n    if (nextProps.fallback !== undefined) {\n      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n      if (enableSuspenseServerRenderer) {\n        const suspenseState = workInProgress.memoizedState;\n\n        if (suspenseState !== null) {\n          const dehydrated = suspenseState.dehydrated;\n\n          if (dehydrated !== null) {\n            return mountDehydratedSuspenseComponent(workInProgress, dehydrated, renderExpirationTime);\n          }\n        }\n      }\n    } // This is the initial mount. This branch is pretty simple because there's\n    // no previous state that needs to be preserved.\n\n\n    if (nextDidTimeout) {\n      // Mount separate fragments for primary and fallback children.\n      const nextFallbackChildren = nextProps.fallback;\n      const primaryChildFragment = createFiberFromFragment(null, mode, NoWork, null);\n      primaryChildFragment.return = workInProgress;\n\n      if ((workInProgress.mode & BlockingMode) === NoMode) {\n        // Outside of blocking mode, we commit the effects from the\n        // partially completed, timed-out tree, too.\n        const progressedState = workInProgress.memoizedState;\n        const progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;\n        primaryChildFragment.child = progressedPrimaryChild;\n        let progressedChild = progressedPrimaryChild;\n\n        while (progressedChild !== null) {\n          progressedChild.return = primaryChildFragment;\n          progressedChild = progressedChild.sibling;\n        }\n      }\n\n      const fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);\n      fallbackChildFragment.return = workInProgress;\n      primaryChildFragment.sibling = fallbackChildFragment; // Skip the primary children, and continue working on the\n      // fallback children.\n\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      workInProgress.child = primaryChildFragment;\n      return fallbackChildFragment;\n    } else {\n      // Mount the primary children without an intermediate fragment fiber.\n      const nextPrimaryChildren = nextProps.children;\n      workInProgress.memoizedState = null;\n      return workInProgress.child = mountChildFibers(workInProgress, null, nextPrimaryChildren, renderExpirationTime);\n    }\n  } else {\n    // This is an update. This branch is more complicated because we need to\n    // ensure the state of the primary children is preserved.\n    const prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      if (enableSuspenseServerRenderer) {\n        const dehydrated = prevState.dehydrated;\n\n        if (dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(current, workInProgress, dehydrated, prevState, renderExpirationTime);\n          } else if (workInProgress.memoizedState !== null) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n\n            workInProgress.effectTag |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback. Wrap the children\n            // in a fragment fiber to keep them separate from the fallback\n            // children.\n            const nextFallbackChildren = nextProps.fallback;\n            const primaryChildFragment = createFiberFromFragment( // It shouldn't matter what the pending props are because we aren't\n            // going to render this fragment.\n            null, mode, NoWork, null);\n            primaryChildFragment.return = workInProgress; // This is always null since we never want the previous child\n            // that we're not going to hydrate.\n\n            primaryChildFragment.child = null;\n\n            if ((workInProgress.mode & BlockingMode) === NoMode) {\n              // Outside of blocking mode, we commit the effects from the\n              // partially completed, timed-out tree, too.\n              let progressedChild = primaryChildFragment.child = workInProgress.child;\n\n              while (progressedChild !== null) {\n                progressedChild.return = primaryChildFragment;\n                progressedChild = progressedChild.sibling;\n              }\n            } else {\n              // We will have dropped the effect list which contains the deletion.\n              // We need to reconcile to delete the current child.\n              reconcileChildFibers(workInProgress, current.child, null, renderExpirationTime);\n            } // Because primaryChildFragment is a new fiber that we're inserting as the\n            // parent of a new tree, we need to set its treeBaseDuration.\n\n\n            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n              // treeBaseDuration is the sum of all the child tree base durations.\n              let treeBaseDuration = 0;\n              let hiddenChild = primaryChildFragment.child;\n\n              while (hiddenChild !== null) {\n                treeBaseDuration += hiddenChild.treeBaseDuration;\n                hiddenChild = hiddenChild.sibling;\n              }\n\n              primaryChildFragment.treeBaseDuration = treeBaseDuration;\n            } // Create a fragment from the fallback children, too.\n\n\n            const fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            fallbackChildFragment.effectTag |= Placement;\n            primaryChildFragment.childExpirationTime = NoWork;\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            workInProgress.child = primaryChildFragment; // Skip the primary children, and continue working on the\n            // fallback children.\n\n            return fallbackChildFragment;\n          }\n        }\n      } // The current tree already timed out. That means each child set is\n      // wrapped in a fragment fiber.\n\n\n      const currentPrimaryChildFragment = current.child;\n      const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n\n      if (nextDidTimeout) {\n        // Still timed out. Reuse the current primary children by cloning\n        // its fragment. We're going to skip over these entirely.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createWorkInProgress(currentPrimaryChildFragment, currentPrimaryChildFragment.pendingProps);\n        primaryChildFragment.return = workInProgress;\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState = workInProgress.memoizedState;\n          const progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;\n\n          if (progressedPrimaryChild !== currentPrimaryChildFragment.child) {\n            primaryChildFragment.child = progressedPrimaryChild;\n            let progressedChild = progressedPrimaryChild;\n\n            while (progressedChild !== null) {\n              progressedChild.return = primaryChildFragment;\n              progressedChild = progressedChild.sibling;\n            }\n          }\n        } // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n\n\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        } // Clone the fallback child fragment, too. These we'll continue\n        // working on.\n\n\n        const fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, nextFallbackChildren);\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        primaryChildFragment.childExpirationTime = NoWork; // Skip the primary children, and continue working on the\n        // fallback children.\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // No longer suspended. Switch back to showing the primary children,\n        // and remove the intermediate fragment fiber.\n        const nextPrimaryChildren = nextProps.children;\n        const currentPrimaryChild = currentPrimaryChildFragment.child;\n        const primaryChild = reconcileChildFibers(workInProgress, currentPrimaryChild, nextPrimaryChildren, renderExpirationTime); // If this render doesn't suspend, we need to delete the fallback\n        // children. Wait until the complete phase, after we've confirmed the\n        // fallback is no longer needed.\n        // TODO: Would it be better to store the fallback fragment on\n        // the stateNode?\n        // Continue rendering the children, like we normally do.\n\n        workInProgress.memoizedState = null;\n        return workInProgress.child = primaryChild;\n      }\n    } else {\n      // The current tree has not already timed out. That means the primary\n      // children are not wrapped in a fragment fiber.\n      const currentPrimaryChild = current.child;\n\n      if (nextDidTimeout) {\n        // Timed out. Wrap the children in a fragment fiber to keep them\n        // separate from the fallback children.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createFiberFromFragment( // It shouldn't matter what the pending props are because we aren't\n        // going to render this fragment.\n        null, mode, NoWork, null);\n        primaryChildFragment.return = workInProgress;\n        primaryChildFragment.child = currentPrimaryChild;\n\n        if (currentPrimaryChild !== null) {\n          currentPrimaryChild.return = primaryChildFragment;\n        } // Even though we're creating a new fiber, there are no new children,\n        // because we're reusing an already mounted tree. So we don't need to\n        // schedule a placement.\n        // primaryChildFragment.effectTag |= Placement;\n\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState = workInProgress.memoizedState;\n          const progressedPrimaryChild = progressedState !== null ? workInProgress.child.child : workInProgress.child;\n          primaryChildFragment.child = progressedPrimaryChild;\n          let progressedChild = progressedPrimaryChild;\n\n          while (progressedChild !== null) {\n            progressedChild.return = primaryChildFragment;\n            progressedChild = progressedChild.sibling;\n          }\n        } // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n\n\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        } // Create a fragment from the fallback children, too.\n\n\n        const fallbackChildFragment = createFiberFromFragment(nextFallbackChildren, mode, renderExpirationTime, null);\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        fallbackChildFragment.effectTag |= Placement;\n        primaryChildFragment.childExpirationTime = NoWork; // Skip the primary children, and continue working on the\n        // fallback children.\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out. Continue rendering the children, like we\n        // normally do.\n        workInProgress.memoizedState = null;\n        const nextPrimaryChildren = nextProps.children;\n        return workInProgress.child = reconcileChildFibers(workInProgress, currentPrimaryChild, nextPrimaryChildren, renderExpirationTime);\n      }\n    }\n  }\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime) {\n  // We're now not suspended nor dehydrated.\n  workInProgress.memoizedState = null; // Retry with the full children.\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children; // This will ensure that the children get Placement effects and\n  // that the old child gets a Deletion effect.\n  // We could also call forceUnmountCurrentAndReconcile.\n\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderExpirationTime) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    if (__DEV__) {\n      console.error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOM.createBlockingRoot(container, { hydrate: true })' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.expirationTime = Sync;\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    let serverDisplayTime = requestCurrentTimeForUpdate(); // Schedule a normal pri update to render this content.\n\n    let newExpirationTime = computeAsyncExpiration(serverDisplayTime);\n\n    if (enableSchedulerTracing) {\n      markSpawnedWork(newExpirationTime);\n    }\n\n    workInProgress.expirationTime = newExpirationTime;\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.expirationTime = Never;\n\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    }\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderExpirationTime) {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime);\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime);\n  } // We use childExpirationTime to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n\n\n  const hasContextChanged = current.childExpirationTime >= renderExpirationTime;\n\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using an earlier expiration time, if\n    // we are rendering at lower expiration than sync.\n    if (renderExpirationTime < Sync) {\n      if (suspenseState.retryTime <= renderExpirationTime) {\n        // This render is even higher pri than we've seen before, let's try again\n        // at even higher pri.\n        let attemptHydrationAtExpirationTime = renderExpirationTime + 1;\n        suspenseState.retryTime = attemptHydrationAtExpirationTime;\n        scheduleWork(current, attemptHydrationAtExpirationTime); // TODO: Early abort this render.\n      } else {// We have already tried to ping at a higher priority than we're rendering with\n          // so if we got here, we must have failed to hydrate at those levels. We must\n          // now give up. Instead, we're going to delete the whole subtree and instead inject\n          // a new real Suspense boundary to take its place, which may render content\n          // or fallback. This might suspend for a while and if it does we might still have\n          // an opportunity to hydrate before this pass commits.\n        }\n    } // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n\n\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderExpirationTime);\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.effectTag |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n    registerSuspenseInstanceRetry(suspenseInstance, retryDehydratedSuspenseBoundary.bind(null, current));\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance);\n    const nextProps = workInProgress.pendingProps;\n    const nextChildren = nextProps.children;\n    const child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    let node = child;\n\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag |= Hydrating;\n      node = node.sibling;\n    }\n\n    workInProgress.child = child;\n    return workInProgress.child;\n  }\n}\n\nfunction scheduleWorkOnFiber(fiber, renderExpirationTime) {\n  if (fiber.expirationTime < renderExpirationTime) {\n    fiber.expirationTime = renderExpirationTime;\n  }\n\n  let alternate = fiber.alternate;\n\n  if (alternate !== null && alternate.expirationTime < renderExpirationTime) {\n    alternate.expirationTime = renderExpirationTime;\n  }\n\n  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderExpirationTime) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleWorkOnFiber(node, renderExpirationTime);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleWorkOnFiber(node, renderExpirationTime);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow = null;\n\n  while (row !== null) {\n    let currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  if (__DEV__) {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          default:\n            console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n            break;\n        }\n      } else {\n        console.error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  if (__DEV__) {\n    let isArray = Array.isArray(childSlot);\n    let isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isArray || isIterable) {\n      let type = isArray ? 'array' : 'iterable';\n      console.error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  if (__DEV__) {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (Array.isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        let iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n\n              i++;\n            }\n          }\n        } else {\n          console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {\n  let renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailExpiration: 0,\n      tailMode: tailMode,\n      lastEffect: lastEffectBeforeRendering\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailExpiration = 0;\n    renderState.tailMode = tailMode;\n    renderState.lastEffect = lastEffectBeforeRendering;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderExpirationTime) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder = nextProps.revealOrder;\n  const tailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  let suspenseContext = suspenseStackCursor.current;\n  let shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.effectTag |= DidCapture;\n  } else {\n    const didSuspendBefore = current !== null && (current.effectTag & DidCapture) !== NoEffect;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderExpirationTime);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    // Outside of blocking mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          let lastContentRow = findLastContentRow(workInProgress.child);\n          let tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode, workInProgress.lastEffect);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          let tail = null;\n          let row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            let currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            let nextRow = row.sibling;\n            row.sibling = tail;\n            tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          tail, null, // last\n          tailMode, workInProgress.lastEffect);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined, workInProgress.lastEffect);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  }\n\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(current, workInProgress, renderExpirationTime) {\n  const providerType = workInProgress.type;\n  const context = providerType._context;\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev);\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    const oldValue = oldProps.value;\n    const changedBits = calculateChangedBits(context, newValue, oldValue);\n\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && !hasLegacyContextChanged()) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderExpirationTime) {\n  let context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  if (__DEV__) {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  const newValue = readContext(context, newProps.unstable_observedBits);\n  let newChildren;\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateFundamentalComponent(current, workInProgress, renderExpirationTime) {\n  const fundamentalImpl = workInProgress.type.impl;\n\n  if (fundamentalImpl.reconcileChildren === false) {\n    return null;\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderExpirationTime) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime) {\n  cancelWorkTimer(workInProgress);\n\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (updateExpirationTime !== NoWork) {\n    markUnprocessedUpdateTime(updateExpirationTime);\n  } // Check if the children have any pending work.\n\n\n  const childExpirationTime = workInProgress.childExpirationTime;\n\n  if (childExpirationTime < renderExpirationTime) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    const last = returnFiber.lastEffect;\n\n    if (last !== null) {\n      last.nextEffect = current;\n      returnFiber.lastEffect = current;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = current;\n    }\n\n    current.nextEffect = null;\n    current.effectTag = Deletion;\n    newWorkInProgress.effectTag |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  } else {\n    throw new Error('Did not expect this call in production. ' + 'This is a bug in React. Please file an issue.');\n  }\n} // 从父到子, 构建 Fiber 节点对象\n\n\nfunction beginWork(current, workInProgress, renderExpirationTime) {\n  // 1073741823\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.expirationTime));\n    }\n  } // 判断是否有旧的 Fiber 对象\n  // 初始渲染时 只有 rootFiber 节点存在 current\n\n\n  if (current !== null) {\n    // 获取旧的 props 对象\n    const oldProps = current.memoizedProps; // 获取新的 props 对象\n\n    const newProps = workInProgress.pendingProps; // 初始渲染时 false\n\n    if (oldProps !== newProps || hasLegacyContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n    __DEV__ ? workInProgress.type !== current.type : false)) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true; // 初始渲染时 false 两个值相同\n    } else if (updateExpirationTime < renderExpirationTime) {\n      // 初始渲染时 false\n      // 可以直接复用前一次更新的子Fiber, 不需要新建子Fiber\n      didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n\n        case HostComponent:\n          pushHostContext(workInProgress);\n\n          if (workInProgress.mode & ConcurrentMode && renderExpirationTime !== Never && shouldDeprioritizeSubtree(workInProgress.type, newProps)) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n\n          break;\n\n        case ClassComponent:\n          {\n            const Component = workInProgress.type;\n\n            if (isLegacyContextProvider(Component)) {\n              pushLegacyContextProvider(workInProgress);\n            }\n\n            break;\n          }\n\n        case HostPortal:\n          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n          break;\n\n        case ContextProvider:\n          {\n            const newValue = workInProgress.memoizedProps.value;\n            pushProvider(workInProgress, newValue);\n            break;\n          }\n\n        case Profiler:\n          if (enableProfilerTimer) {\n            // Profiler should only call onRender when one of its descendants actually rendered.\n            const hasChildWork = workInProgress.childExpirationTime >= renderExpirationTime;\n\n            if (hasChildWork) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n\n          break;\n\n        case SuspenseComponent:\n          {\n            const state = workInProgress.memoizedState;\n\n            if (state !== null) {\n              if (enableSuspenseServerRenderer) {\n                if (state.dehydrated !== null) {\n                  pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n                  // been unsuspended it has committed as a resolved Suspense component.\n                  // If it needs to be retried, it should have work scheduled on it.\n\n                  workInProgress.effectTag |= DidCapture;\n                  break;\n                }\n              } // If this boundary is currently timed out, we need to decide\n              // whether to retry the primary children, or to skip over it and\n              // go straight to the fallback. Check the priority of the primary\n              // child fragment.\n\n\n              const primaryChildFragment = workInProgress.child;\n              const primaryChildExpirationTime = primaryChildFragment.childExpirationTime;\n\n              if (primaryChildExpirationTime !== NoWork && primaryChildExpirationTime >= renderExpirationTime) {\n                // The primary children have pending work. Use the normal path\n                // to attempt to render the primary children again.\n                return updateSuspenseComponent(current, workInProgress, renderExpirationTime);\n              } else {\n                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n                // priority. Bailout.\n\n                const child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n\n                if (child !== null) {\n                  // The fallback children have pending work. Skip over the\n                  // primary children and work on the fallback.\n                  return child.sibling;\n                } else {\n                  return null;\n                }\n              }\n            } else {\n              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n            }\n\n            break;\n          }\n\n        case SuspenseListComponent:\n          {\n            const didSuspendBefore = (current.effectTag & DidCapture) !== NoEffect;\n            const hasChildWork = workInProgress.childExpirationTime >= renderExpirationTime;\n\n            if (didSuspendBefore) {\n              if (hasChildWork) {\n                // If something was in fallback state last time, and we have all the\n                // same children then we're still in progressive loading state.\n                // Something might get unblocked by state updates or retries in the\n                // tree which will affect the tail. So we need to use the normal\n                // path to compute the correct tail.\n                return updateSuspenseListComponent(current, workInProgress, renderExpirationTime);\n              } // If none of the children had any work, that means that none of\n              // them got retried so they'll still be blocked in the same way\n              // as before. We can fast bail out.\n\n\n              workInProgress.effectTag |= DidCapture;\n            } // If nothing suspended before and we're rendering the same children,\n            // then the tail doesn't matter. Anything new that suspends will work\n            // in the \"together\" mode, so we can continue from the state we had.\n\n\n            let renderState = workInProgress.memoizedState;\n\n            if (renderState !== null) {\n              // Reset to the \"together\" mode in case we've started a different\n              // update in the past but didn't complete it.\n              renderState.rendering = null;\n              renderState.tail = null;\n            }\n\n            pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n            if (hasChildWork) {\n              break;\n            } else {\n              // If none of the children had any work, that means that none of\n              // them got retried so they'll still be blocked in the same way\n              // as before. We can fast bail out.\n              return null;\n            }\n          }\n      } // 复用 current\n\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderExpirationTime);\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  } // NoWork 常量 值为0 清空过期时间\n\n\n  workInProgress.expirationTime = NoWork; // 根据当前 Fiber 的类型决定如何构建起子级 Fiber 对象\n  // 文件位置: shared/ReactWorkTags.js\n\n  switch (workInProgress.tag) {\n    // 2\n    // 函数组件在第一次被渲染时使用\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent( // 旧 Fiber\n        current, // 新 Fiber\n        workInProgress, // 新 Fiber 的 type 值 初始渲染时是App组件函数\n        workInProgress.type, // 同步 整数最大值 1073741823\n        renderExpirationTime);\n      }\n    // 16\n\n    case LazyComponent:\n      {\n        const elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, updateExpirationTime, renderExpirationTime);\n      }\n    // 0\n\n    case FunctionComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderExpirationTime);\n      }\n    // 1\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateClassComponent(current, workInProgress, Component, resolvedProps, renderExpirationTime);\n      }\n    // 3\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    // 5\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    // 6\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n    // 13\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderExpirationTime);\n    // 4\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderExpirationTime);\n    // 11\n\n    case ForwardRef:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps);\n        return updateForwardRef(current, workInProgress, type, resolvedProps, renderExpirationTime);\n      }\n    // 7\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n    // 8\n\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n    // 12\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n    // 10\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderExpirationTime);\n    // 9\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderExpirationTime);\n    // 14\n\n    case MemoComponent:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = type.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentName(type), getCurrentFiberStackInDev);\n            }\n          }\n        }\n\n        resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n        return updateMemoComponent(current, workInProgress, type, resolvedProps, updateExpirationTime, renderExpirationTime);\n      }\n    // 15\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);\n      }\n    // 17\n\n    case IncompleteClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return mountIncompleteClassComponent(current, workInProgress, Component, resolvedProps, renderExpirationTime);\n      }\n    // 19\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderExpirationTime);\n      }\n    // 20\n\n    case FundamentalComponent:\n      {\n        if (enableFundamentalAPI) {\n          return updateFundamentalComponent(current, workInProgress, renderExpirationTime);\n        }\n\n        break;\n      }\n    // 21\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          return updateScopeComponent(current, workInProgress, renderExpirationTime);\n        }\n\n        break;\n      }\n    // 22\n\n    case Block:\n      {\n        if (enableBlocksAPI) {\n          const block = workInProgress.type;\n          const props = workInProgress.pendingProps;\n          return updateBlock(current, workInProgress, block, props, renderExpirationTime);\n        }\n\n        break;\n      }\n  }\n\n  invariant(false, 'Unknown unit of work tag (%s). This error is likely caused by a bug in ' + 'React. Please file an issue.', workInProgress.tag);\n}\n\nexport { beginWork };","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/react-reconciler/src/ReactFiberBeginWork.js"],"names":["checkPropTypes","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostText","HostPortal","ForwardRef","Fragment","Mode","ContextProvider","ContextConsumer","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","FundamentalComponent","ScopeComponent","Block","NoEffect","PerformedWork","Placement","Hydrating","ContentReset","DidCapture","Update","Ref","Deletion","ReactSharedInternals","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","enableProfilerTimer","enableSchedulerTracing","enableSuspenseServerRenderer","enableFundamentalAPI","warnAboutDefaultPropsOnFunctionComponents","enableScopeAPI","enableBlocksAPI","invariant","shallowEqual","getComponentName","ReactStrictModeWarnings","refineResolvedLazyComponent","REACT_LAZY_TYPE","getIteratorFn","getCurrentFiberOwnerNameInDevOrNull","getCurrentFiberStackInDev","setIsRendering","startWorkTimer","cancelWorkTimer","resolveFunctionForHotReloading","resolveForwardRefForHotReloading","resolveClassForHotReloading","mountChildFibers","reconcileChildFibers","cloneChildFibers","processUpdateQueue","cloneUpdateQueue","initializeUpdateQueue","NoWork","Never","Sync","computeAsyncExpiration","ConcurrentMode","NoMode","ProfileMode","StrictMode","BlockingMode","shouldSetTextContent","shouldDeprioritizeSubtree","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","shouldSuspend","pushHostContext","pushHostContainer","suspenseStackCursor","pushSuspenseContext","InvisibleParentSuspenseContext","ForceSuspenseFallback","hasSuspenseContext","setDefaultShallowSuspenseContext","addSubtreeSuspenseContext","setShallowSuspenseContext","findFirstSuspended","pushProvider","propagateContextChange","readContext","prepareToReadContext","calculateChangedBits","scheduleWorkOnParentPath","renderWithHooks","bailoutHooks","stopProfilerTimerIfRunning","getMaskedContext","getUnmaskedContext","hasContextChanged","hasLegacyContextChanged","pushContextProvider","pushLegacyContextProvider","isContextProvider","isLegacyContextProvider","pushTopLevelContextObject","invalidateContextProvider","enterHydrationState","reenterHydrationStateFromDehydratedSuspenseInstance","resetHydrationState","tryToClaimNextHydratableInstance","warnIfHydrating","adoptClassInstance","applyDerivedStateFromProps","constructClassInstance","mountClassInstance","resumeMountClassInstance","updateClassInstance","readLazyComponentType","resolveDefaultProps","resolveLazyComponentTag","createFiberFromTypeAndProps","createFiberFromFragment","createWorkInProgress","isSimpleFunctionComponent","markSpawnedWork","requestCurrentTimeForUpdate","retryDehydratedSuspenseBoundary","scheduleWork","renderDidSuspendDelayIfPossible","markUnprocessedUpdateTime","ReactCurrentOwner","didReceiveUpdate","didWarnAboutBadClass","didWarnAboutModulePatternComponent","didWarnAboutContextTypeOnFunctionComponent","didWarnAboutGetDerivedStateOnFunctionComponent","didWarnAboutFunctionRefs","didWarnAboutReassigningProps","didWarnAboutRevealOrder","didWarnAboutTailOptions","didWarnAboutDefaultPropsOnFunctionComponent","__DEV__","reconcileChildren","current","workInProgress","nextChildren","renderExpirationTime","child","forceUnmountCurrentAndReconcile","updateForwardRef","Component","nextProps","type","elementType","innerPropTypes","propTypes","render","ref","mode","memoizedState","bailoutOnAlreadyFinishedWork","effectTag","updateMemoComponent","updateExpirationTime","compare","defaultProps","undefined","resolvedType","tag","validateFunctionComponentInDev","updateSimpleMemoComponent","return","currentChild","prevProps","memoizedProps","newChild","outerMemoType","$$typeof","outerPropTypes","expirationTime","updateFunctionComponent","updateFragment","pendingProps","updateMode","children","updateProfiler","markRef","context","unmaskedContext","updateBlock","block","data","query","updateClassComponent","hasContext","instance","stateNode","shouldUpdate","alternate","nextUnitOfWork","finishClassComponent","inst","props","console","error","didCaptureError","getDerivedStateFromError","state","pushHostRootContext","root","pendingContext","containerInfo","updateHostRoot","updateQueue","prevState","prevChildren","element","nextState","hydrate","node","sibling","updateHostComponent","isDirectTextChild","childExpirationTime","updateHostText","mountLazyComponent","_current","resolvedTag","resolvedProps","hint","mountIncompleteClassComponent","mountIndeterminateComponent","value","prototype","componentName","recordLegacyContextWarning","getDerivedStateFromProps","contextTypes","childContextTypes","displayName","name","info","ownerName","warningKey","_debugID","debugSource","_debugSource","fileName","lineNumber","contextType","SUSPENDED_MARKER","dehydrated","retryTime","shouldRemainOnFallback","suspenseContext","updateSuspenseComponent","nextDidTimeout","didSuspend","fallback","unstable_avoidThisFallback","suspenseState","mountDehydratedSuspenseComponent","nextFallbackChildren","primaryChildFragment","progressedState","progressedPrimaryChild","progressedChild","fallbackChildFragment","nextPrimaryChildren","updateDehydratedSuspenseComponent","treeBaseDuration","hiddenChild","currentPrimaryChildFragment","currentFallbackChildFragment","currentPrimaryChild","primaryChild","retrySuspenseComponentWithoutHydrating","suspenseInstance","serverDisplayTime","newExpirationTime","attemptHydrationAtExpirationTime","bind","scheduleWorkOnFiber","fiber","propagateSuspenseContextChange","firstChild","findLastContentRow","row","lastContentRow","currentRow","validateRevealOrder","revealOrder","toLowerCase","validateTailOptions","tailMode","validateSuspenseListNestedChild","childSlot","index","isArray","Array","isIterable","validateSuspenseListChildren","i","length","iteratorFn","childrenIterator","call","step","next","done","initSuspenseListRenderState","isBackwards","tail","lastEffectBeforeRendering","renderState","rendering","renderingStartTime","last","tailExpiration","lastEffect","updateSuspenseListComponent","newChildren","shouldForceFallback","didSuspendBefore","nextRow","updatePortalComponent","updateContextProvider","providerType","_context","newProps","oldProps","newValue","providerPropTypes","oldValue","changedBits","hasWarnedAboutUsingContextAsConsumer","updateContextConsumer","Consumer","unstable_observedBits","updateFundamentalComponent","fundamentalImpl","impl","updateScopeComponent","markWorkInProgressReceivedUpdate","dependencies","remountFiber","oldWorkInProgress","newWorkInProgress","returnFiber","Error","prevSibling","nextEffect","firstEffect","beginWork","_debugNeedsRemount","key","_debugOwner","hasChildWork","primaryChildExpirationTime","unresolvedProps"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactProviderType, ReactContext} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactFiber';\nimport type {FiberRoot} from './ReactFiberRoot';\nimport type {ExpirationTime} from './ReactFiberExpirationTime';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n  SuspenseListTailMode,\n} from './ReactFiberSuspenseComponent';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext';\n\nimport checkPropTypes from 'prop-types/checkPropTypes';\n\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostText,\n  HostPortal,\n  ForwardRef,\n  Fragment,\n  Mode,\n  ContextProvider,\n  ContextConsumer,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  FundamentalComponent,\n  ScopeComponent,\n  Block,\n} from 'shared/ReactWorkTags';\nimport {\n  NoEffect,\n  PerformedWork,\n  Placement,\n  Hydrating,\n  ContentReset,\n  DidCapture,\n  Update,\n  Ref,\n  Deletion,\n} from 'shared/ReactSideEffectTags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  enableProfilerTimer,\n  enableSchedulerTracing,\n  enableSuspenseServerRenderer,\n  enableFundamentalAPI,\n  warnAboutDefaultPropsOnFunctionComponents,\n  enableScopeAPI,\n  enableBlocksAPI,\n} from 'shared/ReactFeatureFlags';\nimport invariant from 'shared/invariant';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentName from 'shared/getComponentName';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {refineResolvedLazyComponent} from 'shared/ReactLazyComponent';\nimport {REACT_LAZY_TYPE, getIteratorFn} from 'shared/ReactSymbols';\nimport {\n  getCurrentFiberOwnerNameInDevOrNull,\n  getCurrentFiberStackInDev,\n  setIsRendering,\n} from './ReactCurrentFiber';\nimport {startWorkTimer, cancelWorkTimer} from './ReactDebugFiberPerf';\nimport {\n  resolveFunctionForHotReloading,\n  resolveForwardRefForHotReloading,\n  resolveClassForHotReloading,\n} from './ReactFiberHotReloading';\n\nimport {\n  mountChildFibers,\n  reconcileChildFibers,\n  cloneChildFibers,\n} from './ReactChildFiber';\nimport {\n  processUpdateQueue,\n  cloneUpdateQueue,\n  initializeUpdateQueue,\n} from './ReactUpdateQueue';\nimport {\n  NoWork,\n  Never,\n  Sync,\n  computeAsyncExpiration,\n} from './ReactFiberExpirationTime';\nimport {\n  ConcurrentMode,\n  NoMode,\n  ProfileMode,\n  StrictMode,\n  BlockingMode,\n} from './ReactTypeOfMode';\nimport {\n  shouldSetTextContent,\n  shouldDeprioritizeSubtree,\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n  registerSuspenseInstanceRetry,\n} from './ReactFiberHostConfig';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport {shouldSuspend} from './ReactFiberReconciler';\nimport {pushHostContext, pushHostContainer} from './ReactFiberHostContext';\nimport {\n  suspenseStackCursor,\n  pushSuspenseContext,\n  InvisibleParentSuspenseContext,\n  ForceSuspenseFallback,\n  hasSuspenseContext,\n  setDefaultShallowSuspenseContext,\n  addSubtreeSuspenseContext,\n  setShallowSuspenseContext,\n} from './ReactFiberSuspenseContext';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent';\nimport {\n  pushProvider,\n  propagateContextChange,\n  readContext,\n  prepareToReadContext,\n  calculateChangedBits,\n  scheduleWorkOnParentPath,\n} from './ReactFiberNewContext';\nimport {renderWithHooks, bailoutHooks} from './ReactFiberHooks';\nimport {stopProfilerTimerIfRunning} from './ReactProfilerTimer';\nimport {\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged as hasLegacyContextChanged,\n  pushContextProvider as pushLegacyContextProvider,\n  isContextProvider as isLegacyContextProvider,\n  pushTopLevelContextObject,\n  invalidateContextProvider,\n} from './ReactFiberContext';\nimport {\n  enterHydrationState,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  tryToClaimNextHydratableInstance,\n  warnIfHydrating,\n} from './ReactFiberHydrationContext';\nimport {\n  adoptClassInstance,\n  applyDerivedStateFromProps,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n} from './ReactFiberClassComponent';\nimport {\n  readLazyComponentType,\n  resolveDefaultProps,\n} from './ReactFiberLazyComponent';\nimport {\n  resolveLazyComponentTag,\n  createFiberFromTypeAndProps,\n  createFiberFromFragment,\n  createWorkInProgress,\n  isSimpleFunctionComponent,\n} from './ReactFiber';\nimport {\n  markSpawnedWork,\n  requestCurrentTimeForUpdate,\n  retryDehydratedSuspenseBoundary,\n  scheduleWork,\n  renderDidSuspendDelayIfPossible,\n  markUnprocessedUpdateTime,\n} from './ReactFiberWorkLoop';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nlet didReceiveUpdate: boolean = false;\n\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n// 构建子级 Fiber 对象\nexport function reconcileChildren(\n  // 旧 Fiber\n  current: Fiber | null,\n  // 父级 Fiber\n  workInProgress: Fiber,\n  // 子级 vdom 对象\n  nextChildren: any,\n  // 初始渲染 整型最大值 代表同步任务\n  renderExpirationTime: ExpirationTime,\n) {\n  /**\n   * 为什么要传递 current ?\n   * 如果不是初始渲染的情况, 要进行新旧 Fiber 对比\n   * 初始渲染时则用不到 current\n   */\n  // 如果就 Fiber 为 null 表示初始渲染\n  if (current === null) {\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    // 否则就是更新\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(\n  current: Fiber,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    current.child,\n    null,\n    renderExpirationTime,\n  );\n  // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    null,\n    nextChildren,\n    renderExpirationTime,\n  );\n}\n\nfunction updateForwardRef(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(Component),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref;\n\n  // The rest is a fork of updateFunctionComponent\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderExpirationTime,\n    );\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          render,\n          nextProps,\n          ref,\n          renderExpirationTime,\n        );\n      }\n    }\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderExpirationTime,\n    );\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  updateExpirationTime,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  if (current === null) {\n    let type = Component.type;\n    if (\n      isSimpleFunctionComponent(type) &&\n      Component.compare === null &&\n      // SimpleMemoComponent codepath doesn't resolve outer props either.\n      Component.defaultProps === undefined\n    ) {\n      let resolvedType = type;\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      }\n      // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        resolvedType,\n        nextProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(type),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n    let child = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      null,\n      workInProgress.mode,\n      renderExpirationTime,\n    );\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(\n        innerPropTypes,\n        nextProps, // Resolved props\n        'prop',\n        getComponentName(type),\n        getCurrentFiberStackInDev,\n      );\n    }\n  }\n  let currentChild = ((current.child: any): Fiber); // This is always exactly one child\n  if (updateExpirationTime < renderExpirationTime) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps;\n    // Default to shallow comparison\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  let newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  updateExpirationTime,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        outerMemoType = refineResolvedLazyComponent(outerMemoType);\n      }\n      const outerPropTypes = outerMemoType && (outerMemoType: any).propTypes;\n      if (outerPropTypes) {\n        checkPropTypes(\n          outerPropTypes,\n          nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop',\n          getComponentName(outerMemoType),\n          getCurrentFiberStackInDev,\n        );\n      }\n      // Inner propTypes will be validated in the function component path.\n    }\n  }\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref &&\n      // Prevent bailout if the implementation changed due to hot reload.\n      (__DEV__ ? workInProgress.type === current.type : true)\n    ) {\n      didReceiveUpdate = false;\n      if (updateExpirationTime < renderExpirationTime) {\n        // The pending update priority was cleared at the beginning of\n        // beginWork. We're about to bail out, but there might be additional\n        // updates at a lower priority. Usually, the priority level of the\n        // remaining updates is accumlated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.expirationTime = current.expirationTime;\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n    }\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderExpirationTime,\n  );\n}\n\nfunction updateFragment(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateMode(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateProfiler(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction markRef(current: Fiber | null, workInProgress: Fiber) {\n  const ref = workInProgress.ref;\n  if (\n    (current === null && ref !== null) ||\n    (current !== null && current.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderExpirationTime,\n) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(Component),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n  }\n\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderExpirationTime,\n    );\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          Component,\n          nextProps,\n          context,\n          renderExpirationTime,\n        );\n      }\n    }\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderExpirationTime,\n    );\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateBlock(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  block: any,\n  nextProps: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  const render = block.render;\n  const data = block.query();\n\n  // The rest is a fork of updateFunctionComponent\n  let nextChildren;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      data,\n      renderExpirationTime,\n    );\n    if (\n      debugRenderPhaseSideEffectsForStrictMode &&\n      workInProgress.mode & StrictMode\n    ) {\n      // Only double-render components with Hooks\n      if (workInProgress.memoizedState !== null) {\n        nextChildren = renderWithHooks(\n          current,\n          workInProgress,\n          render,\n          nextProps,\n          data,\n          renderExpirationTime,\n        );\n      }\n    }\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      data,\n      renderExpirationTime,\n    );\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderExpirationTime);\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentName(Component),\n          getCurrentFiberStackInDev,\n        );\n      }\n    }\n  }\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n  if (instance === null) {\n    if (current !== null) {\n      // A class component without an instance only mounts if it suspended\n      // inside a non-concurrent tree, in an inconsistent state. We want to\n      // treat it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null;\n      // Since this is conceptually a new fiber, schedule a Placement effect\n      workInProgress.effectTag |= Placement;\n    }\n    // In the initial pass we might need to construct the instance.\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n  } else {\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderExpirationTime,\n    );\n  }\n  const nextUnitOfWork = finishClassComponent(\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderExpirationTime,\n  );\n  if (__DEV__) {\n    let inst = workInProgress.stateNode;\n    if (inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error(\n          'It looks like %s is reassigning its own `this.props` while rendering. ' +\n            'This is not supported and can lead to confusing bugs.',\n          getComponentName(workInProgress.type) || 'a component',\n        );\n      }\n      didWarnAboutReassigningProps = true;\n    }\n  }\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  shouldUpdate: boolean,\n  hasContext: boolean,\n  renderExpirationTime: ExpirationTime,\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n\n  const didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  const instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n  if (\n    didCaptureError &&\n    typeof Component.getDerivedStateFromError !== 'function'\n  ) {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode\n      ) {\n        instance.render();\n      }\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n\n  // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  workInProgress.memoizedState = instance.state;\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = (workInProgress.stateNode: FiberRoot);\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context,\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\n// 更新 hostRoot\n// <div id=\"root\"></div> 对应的 Fiber 对象\nfunction updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  // 获取更新队列\n  const updateQueue = workInProgress.updateQueue;\n\n  invariant(\n    current !== null && updateQueue !== null,\n    'If the root does not have an updateQueue, we should have already ' +\n      'bailed out. This error is likely caused by a bug in React. Please ' +\n      'file an issue.',\n  );\n\n  // 获取新的 props 对象 null\n  const nextProps = workInProgress.pendingProps;\n  // 获取上一次渲染使用的 state null\n  const prevState = workInProgress.memoizedState;\n  // 获取上一次渲染使用的 children null\n  const prevChildren = prevState !== null ? prevState.element : null;\n  // 浅复制更新队列, 防止引用属性互相影响\n  // workInProgress.updateQueue 浅拷贝 current.updateQueue\n  cloneUpdateQueue(current, workInProgress);\n  // 获取 updateQueue.payload 并赋值到 workInProgress.memoizedState\n  // 要更新的内容就是 element 就是 rootFiber 的子元素\n  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);\n  // 获取 element 所在对象\n  const nextState = workInProgress.memoizedState;\n  // 从对象中获取 element\n  const nextChildren = nextState.element;\n  // 在计算 state 后如果前后两个 Children 相同的情况\n  // prevChildren => null\n  // nextState => App\n  // false\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n  // 获取 fiberRoot 对象\n  const root: FiberRoot = workInProgress.stateNode;\n  // 服务器端渲染走 if\n  if (root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    let child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n\n    workInProgress.child = child;\n\n    let node = child;\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag = (node.effectTag & ~Placement) | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // 客户端渲染走 else\n    // 构建子节点 fiber 对象\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n    resetHydrationState();\n  }\n\n  // 返回子节点 fiber 对象\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (\n    workInProgress.mode & ConcurrentMode &&\n    renderExpirationTime !== Never &&\n    shouldDeprioritizeSubtree(type, nextProps)\n  ) {\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    }\n    // Schedule this fiber to re-render at offscreen priority. Then bailout.\n    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n    return null;\n  }\n\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction mountLazyComponent(\n  _current,\n  workInProgress,\n  elementType,\n  updateExpirationTime,\n  renderExpirationTime,\n) {\n  if (_current !== null) {\n    // A lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.effectTag |= Placement;\n  }\n\n  const props = workInProgress.pendingProps;\n  // We can't start a User Timing measurement with correct label yet.\n  // Cancel and resume right after we know the tag.\n  cancelWorkTimer(workInProgress);\n  let Component = readLazyComponentType(elementType);\n  // Store the unwrapped component in the type.\n  workInProgress.type = Component;\n  const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));\n  startWorkTimer(workInProgress);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n  switch (resolvedTag) {\n    case FunctionComponent: {\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, Component);\n        workInProgress.type = Component = resolveFunctionForHotReloading(\n          Component,\n        );\n      }\n      child = updateFunctionComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n      return child;\n    }\n    case ClassComponent: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveClassForHotReloading(\n          Component,\n        );\n      }\n      child = updateClassComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n      return child;\n    }\n    case ForwardRef: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveForwardRefForHotReloading(\n          Component,\n        );\n      }\n      child = updateForwardRef(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n      return child;\n    }\n    case MemoComponent: {\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = Component.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(Component),\n              getCurrentFiberStackInDev,\n            );\n          }\n        }\n      }\n      child = updateMemoComponent(\n        null,\n        workInProgress,\n        Component,\n        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n      return child;\n    }\n    case Block: {\n      if (enableBlocksAPI) {\n        // TODO: Resolve for Hot Reloading.\n        child = updateBlock(\n          null,\n          workInProgress,\n          Component,\n          props,\n          renderExpirationTime,\n        );\n        return child;\n      }\n      break;\n    }\n  }\n  let hint = '';\n  if (__DEV__) {\n    if (\n      Component !== null &&\n      typeof Component === 'object' &&\n      Component.$$typeof === REACT_LAZY_TYPE\n    ) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  }\n  // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n  invariant(\n    false,\n    'Element type is invalid. Received a promise that resolves to: %s. ' +\n      'Lazy element type must resolve to a class or function.%s',\n    Component,\n    hint,\n  );\n}\n\nfunction mountIncompleteClassComponent(\n  _current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderExpirationTime,\n) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.effectTag |= Placement;\n  }\n\n  // Promote the fiber to a class and try rendering again.\n  workInProgress.tag = ClassComponent;\n\n  // The rest of this function is a fork of `updateClassComponent`\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(\n    workInProgress,\n    Component,\n    nextProps,\n    renderExpirationTime,\n  );\n\n  return finishClassComponent(\n    null,\n    workInProgress,\n    Component,\n    true,\n    hasContext,\n    renderExpirationTime,\n  );\n}\n\nfunction mountIndeterminateComponent(\n  // 旧 Fiber\n  _current,\n  // 新 Fiber\n  workInProgress,\n  // 新 Fiber 的 type 属性值 初始渲染时 是 App 组件函数\n  Component,\n  // 整数最大值 表示同步任务\n  renderExpirationTime,\n) {\n  // _current => null\n  // false\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null;\n    // Since this is conceptually a new fiber, schedule a Placement effect\n    workInProgress.effectTag |= Placement;\n  }\n  // 为组件添加的 props <App test=\"test\"/>\n  const props = workInProgress.pendingProps;\n  let context;\n  // disableLegacyContext 常量 默认值 false\n  // true\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(\n      workInProgress,\n      Component,\n      false,\n    );\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  // 函数组件被调用后的返回值\n  let value;\n\n  if (__DEV__) {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === 'function'\n    ) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            'This is likely to cause errors. Change %s to extend React.Component instead.',\n          componentName,\n          componentName,\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderExpirationTime,\n    );\n    setIsRendering(false);\n  } else {\n    // 获取 Children 内部会调用 Component()\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderExpirationTime,\n    );\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  // 判断 value 是函数组件还是类组件\n  // 条件成立就是类组件 不成立就是函数组件\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    if (__DEV__) {\n      const componentName = getComponentName(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n    // 类组件\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Throw out any hooks that were used.\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    let hasContext = false;\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    initializeUpdateQueue(workInProgress);\n\n    const getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        getDerivedStateFromProps,\n        props,\n      );\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(\n      null,\n      workInProgress,\n      Component,\n      true,\n      hasContext,\n      renderExpirationTime,\n    );\n  } else {\n    // 函数组件\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with React.useContext() instead.',\n          getComponentName(Component) || 'Unknown',\n        );\n      }\n\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictMode\n      ) {\n        // Only double-render components with Hooks\n        if (workInProgress.memoizedState !== null) {\n          value = renderWithHooks(\n            null,\n            workInProgress,\n            Component,\n            props,\n            context,\n            renderExpirationTime,\n          );\n        }\n      }\n    }\n    reconcileChildren(null, workInProgress, value, renderExpirationTime);\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress: Fiber, Component: any) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error(\n          '%s(...): childContextTypes cannot be defined on a function component.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || workInProgress._debugID || '';\n      const debugSource = workInProgress._debugSource;\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error(\n          'Function components cannot be given refs. ' +\n            'Attempts to access this ref will fail. ' +\n            'Did you mean to use React.forwardRef()?%s',\n          info,\n        );\n      }\n    }\n\n    if (\n      warnAboutDefaultPropsOnFunctionComponents &&\n      Component.defaultProps !== undefined\n    ) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Support for defaultProps will be removed from function components ' +\n            'in a future major release. Use JavaScript default parameters instead.',\n          componentName,\n        );\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support getDerivedStateFromProps.',\n          componentName,\n        );\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (\n      typeof Component.contextType === 'object' &&\n      Component.contextType !== null\n    ) {\n      const componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support contextType.',\n          componentName,\n        );\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER: SuspenseState = {\n  dehydrated: null,\n  retryTime: NoWork,\n};\n\nfunction shouldRemainOnFallback(\n  suspenseContext: SuspenseContext,\n  current: null | Fiber,\n  workInProgress: Fiber,\n) {\n  // If the context is telling us that we should show a fallback, and we're not\n  // already showing content, then we should show the fallback instead.\n  return (\n    hasSuspenseContext(\n      suspenseContext,\n      (ForceSuspenseFallback: SuspenseContext),\n    ) &&\n    (current === null || current.memoizedState !== null)\n  );\n}\n\nfunction updateSuspenseComponent(\n  current,\n  workInProgress,\n  renderExpirationTime,\n) {\n  const mode = workInProgress.mode;\n  const nextProps = workInProgress.pendingProps;\n\n  // This is used by DevTools to force a boundary to suspend.\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.effectTag |= DidCapture;\n    }\n  }\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  let nextDidTimeout = false;\n  const didSuspend = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (\n    didSuspend ||\n    shouldRemainOnFallback(suspenseContext, current, workInProgress)\n  ) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    nextDidTimeout = true;\n    workInProgress.effectTag &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (\n      current === null ||\n      (current.memoizedState: null | SuspenseState) !== null\n    ) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Boundaries without fallbacks or should be avoided are not considered since\n      // they cannot handle preferred fallback states.\n      if (\n        nextProps.fallback !== undefined &&\n        nextProps.unstable_avoidThisFallback !== true\n      ) {\n        suspenseContext = addSubtreeSuspenseContext(\n          suspenseContext,\n          InvisibleParentSuspenseContext,\n        );\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  // This next part is a bit confusing. If the children timeout, we switch to\n  // showing the fallback children in place of the \"primary\" children.\n  // However, we don't want to delete the primary children because then their\n  // state will be lost (both the React state and the host state, e.g.\n  // uncontrolled form inputs). Instead we keep them mounted and hide them.\n  // Both the fallback children AND the primary children are rendered at the\n  // same time. Once the primary children are un-suspended, we can delete\n  // the fallback children — don't need to preserve their state.\n  //\n  // The two sets of children are siblings in the host environment, but\n  // semantically, for purposes of reconciliation, they are two separate sets.\n  // So we store them using two fragment fibers.\n  //\n  // However, we want to avoid allocating extra fibers for every placeholder.\n  // They're only necessary when the children time out, because that's the\n  // only time when both sets are mounted.\n  //\n  // So, the extra fragment fibers are only used if the children time out.\n  // Otherwise, we render the primary children directly. This requires some\n  // custom reconciliation logic to preserve the state of the primary\n  // children. It's essentially a very basic form of re-parenting.\n\n  if (current === null) {\n    // If we're currently hydrating, try to hydrate this boundary.\n    // But only if this has a fallback.\n    if (nextProps.fallback !== undefined) {\n      tryToClaimNextHydratableInstance(workInProgress);\n      // This could've been a dehydrated suspense component.\n      if (enableSuspenseServerRenderer) {\n        const suspenseState: null | SuspenseState =\n          workInProgress.memoizedState;\n        if (suspenseState !== null) {\n          const dehydrated = suspenseState.dehydrated;\n          if (dehydrated !== null) {\n            return mountDehydratedSuspenseComponent(\n              workInProgress,\n              dehydrated,\n              renderExpirationTime,\n            );\n          }\n        }\n      }\n    }\n\n    // This is the initial mount. This branch is pretty simple because there's\n    // no previous state that needs to be preserved.\n    if (nextDidTimeout) {\n      // Mount separate fragments for primary and fallback children.\n      const nextFallbackChildren = nextProps.fallback;\n      const primaryChildFragment = createFiberFromFragment(\n        null,\n        mode,\n        NoWork,\n        null,\n      );\n      primaryChildFragment.return = workInProgress;\n\n      if ((workInProgress.mode & BlockingMode) === NoMode) {\n        // Outside of blocking mode, we commit the effects from the\n        // partially completed, timed-out tree, too.\n        const progressedState: SuspenseState = workInProgress.memoizedState;\n        const progressedPrimaryChild: Fiber | null =\n          progressedState !== null\n            ? (workInProgress.child: any).child\n            : (workInProgress.child: any);\n        primaryChildFragment.child = progressedPrimaryChild;\n        let progressedChild = progressedPrimaryChild;\n        while (progressedChild !== null) {\n          progressedChild.return = primaryChildFragment;\n          progressedChild = progressedChild.sibling;\n        }\n      }\n\n      const fallbackChildFragment = createFiberFromFragment(\n        nextFallbackChildren,\n        mode,\n        renderExpirationTime,\n        null,\n      );\n      fallbackChildFragment.return = workInProgress;\n      primaryChildFragment.sibling = fallbackChildFragment;\n      // Skip the primary children, and continue working on the\n      // fallback children.\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      workInProgress.child = primaryChildFragment;\n      return fallbackChildFragment;\n    } else {\n      // Mount the primary children without an intermediate fragment fiber.\n      const nextPrimaryChildren = nextProps.children;\n      workInProgress.memoizedState = null;\n      return (workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextPrimaryChildren,\n        renderExpirationTime,\n      ));\n    }\n  } else {\n    // This is an update. This branch is more complicated because we need to\n    // ensure the state of the primary children is preserved.\n    const prevState: null | SuspenseState = current.memoizedState;\n    if (prevState !== null) {\n      if (enableSuspenseServerRenderer) {\n        const dehydrated = prevState.dehydrated;\n        if (dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(\n              current,\n              workInProgress,\n              dehydrated,\n              prevState,\n              renderExpirationTime,\n            );\n          } else if (\n            (workInProgress.memoizedState: null | SuspenseState) !== null\n          ) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child;\n            // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n            workInProgress.effectTag |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback. Wrap the children\n            // in a fragment fiber to keep them separate from the fallback\n            // children.\n            const nextFallbackChildren = nextProps.fallback;\n            const primaryChildFragment = createFiberFromFragment(\n              // It shouldn't matter what the pending props are because we aren't\n              // going to render this fragment.\n              null,\n              mode,\n              NoWork,\n              null,\n            );\n            primaryChildFragment.return = workInProgress;\n\n            // This is always null since we never want the previous child\n            // that we're not going to hydrate.\n            primaryChildFragment.child = null;\n\n            if ((workInProgress.mode & BlockingMode) === NoMode) {\n              // Outside of blocking mode, we commit the effects from the\n              // partially completed, timed-out tree, too.\n              let progressedChild = (primaryChildFragment.child =\n                workInProgress.child);\n              while (progressedChild !== null) {\n                progressedChild.return = primaryChildFragment;\n                progressedChild = progressedChild.sibling;\n              }\n            } else {\n              // We will have dropped the effect list which contains the deletion.\n              // We need to reconcile to delete the current child.\n              reconcileChildFibers(\n                workInProgress,\n                current.child,\n                null,\n                renderExpirationTime,\n              );\n            }\n\n            // Because primaryChildFragment is a new fiber that we're inserting as the\n            // parent of a new tree, we need to set its treeBaseDuration.\n            if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n              // treeBaseDuration is the sum of all the child tree base durations.\n              let treeBaseDuration = 0;\n              let hiddenChild = primaryChildFragment.child;\n              while (hiddenChild !== null) {\n                treeBaseDuration += hiddenChild.treeBaseDuration;\n                hiddenChild = hiddenChild.sibling;\n              }\n              primaryChildFragment.treeBaseDuration = treeBaseDuration;\n            }\n\n            // Create a fragment from the fallback children, too.\n            const fallbackChildFragment = createFiberFromFragment(\n              nextFallbackChildren,\n              mode,\n              renderExpirationTime,\n              null,\n            );\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            fallbackChildFragment.effectTag |= Placement;\n            primaryChildFragment.childExpirationTime = NoWork;\n\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            workInProgress.child = primaryChildFragment;\n\n            // Skip the primary children, and continue working on the\n            // fallback children.\n            return fallbackChildFragment;\n          }\n        }\n      }\n      // The current tree already timed out. That means each child set is\n      // wrapped in a fragment fiber.\n      const currentPrimaryChildFragment: Fiber = (current.child: any);\n      const currentFallbackChildFragment: Fiber = (currentPrimaryChildFragment.sibling: any);\n      if (nextDidTimeout) {\n        // Still timed out. Reuse the current primary children by cloning\n        // its fragment. We're going to skip over these entirely.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createWorkInProgress(\n          currentPrimaryChildFragment,\n          currentPrimaryChildFragment.pendingProps,\n        );\n        primaryChildFragment.return = workInProgress;\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState: SuspenseState = workInProgress.memoizedState;\n          const progressedPrimaryChild: Fiber | null =\n            progressedState !== null\n              ? (workInProgress.child: any).child\n              : (workInProgress.child: any);\n          if (progressedPrimaryChild !== currentPrimaryChildFragment.child) {\n            primaryChildFragment.child = progressedPrimaryChild;\n            let progressedChild = progressedPrimaryChild;\n            while (progressedChild !== null) {\n              progressedChild.return = primaryChildFragment;\n              progressedChild = progressedChild.sibling;\n            }\n          }\n        }\n\n        // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        }\n\n        // Clone the fallback child fragment, too. These we'll continue\n        // working on.\n        const fallbackChildFragment = createWorkInProgress(\n          currentFallbackChildFragment,\n          nextFallbackChildren,\n        );\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        primaryChildFragment.childExpirationTime = NoWork;\n        // Skip the primary children, and continue working on the\n        // fallback children.\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // No longer suspended. Switch back to showing the primary children,\n        // and remove the intermediate fragment fiber.\n        const nextPrimaryChildren = nextProps.children;\n        const currentPrimaryChild = currentPrimaryChildFragment.child;\n        const primaryChild = reconcileChildFibers(\n          workInProgress,\n          currentPrimaryChild,\n          nextPrimaryChildren,\n          renderExpirationTime,\n        );\n\n        // If this render doesn't suspend, we need to delete the fallback\n        // children. Wait until the complete phase, after we've confirmed the\n        // fallback is no longer needed.\n        // TODO: Would it be better to store the fallback fragment on\n        // the stateNode?\n\n        // Continue rendering the children, like we normally do.\n        workInProgress.memoizedState = null;\n        return (workInProgress.child = primaryChild);\n      }\n    } else {\n      // The current tree has not already timed out. That means the primary\n      // children are not wrapped in a fragment fiber.\n      const currentPrimaryChild = current.child;\n      if (nextDidTimeout) {\n        // Timed out. Wrap the children in a fragment fiber to keep them\n        // separate from the fallback children.\n        const nextFallbackChildren = nextProps.fallback;\n        const primaryChildFragment = createFiberFromFragment(\n          // It shouldn't matter what the pending props are because we aren't\n          // going to render this fragment.\n          null,\n          mode,\n          NoWork,\n          null,\n        );\n        primaryChildFragment.return = workInProgress;\n        primaryChildFragment.child = currentPrimaryChild;\n        if (currentPrimaryChild !== null) {\n          currentPrimaryChild.return = primaryChildFragment;\n        }\n\n        // Even though we're creating a new fiber, there are no new children,\n        // because we're reusing an already mounted tree. So we don't need to\n        // schedule a placement.\n        // primaryChildFragment.effectTag |= Placement;\n\n        if ((workInProgress.mode & BlockingMode) === NoMode) {\n          // Outside of blocking mode, we commit the effects from the\n          // partially completed, timed-out tree, too.\n          const progressedState: SuspenseState = workInProgress.memoizedState;\n          const progressedPrimaryChild: Fiber | null =\n            progressedState !== null\n              ? (workInProgress.child: any).child\n              : (workInProgress.child: any);\n          primaryChildFragment.child = progressedPrimaryChild;\n          let progressedChild = progressedPrimaryChild;\n          while (progressedChild !== null) {\n            progressedChild.return = primaryChildFragment;\n            progressedChild = progressedChild.sibling;\n          }\n        }\n\n        // Because primaryChildFragment is a new fiber that we're inserting as the\n        // parent of a new tree, we need to set its treeBaseDuration.\n        if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n          // treeBaseDuration is the sum of all the child tree base durations.\n          let treeBaseDuration = 0;\n          let hiddenChild = primaryChildFragment.child;\n          while (hiddenChild !== null) {\n            treeBaseDuration += hiddenChild.treeBaseDuration;\n            hiddenChild = hiddenChild.sibling;\n          }\n          primaryChildFragment.treeBaseDuration = treeBaseDuration;\n        }\n\n        // Create a fragment from the fallback children, too.\n        const fallbackChildFragment = createFiberFromFragment(\n          nextFallbackChildren,\n          mode,\n          renderExpirationTime,\n          null,\n        );\n        fallbackChildFragment.return = workInProgress;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        fallbackChildFragment.effectTag |= Placement;\n        primaryChildFragment.childExpirationTime = NoWork;\n        // Skip the primary children, and continue working on the\n        // fallback children.\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        workInProgress.child = primaryChildFragment;\n        return fallbackChildFragment;\n      } else {\n        // Still haven't timed out. Continue rendering the children, like we\n        // normally do.\n        workInProgress.memoizedState = null;\n        const nextPrimaryChildren = nextProps.children;\n        return (workInProgress.child = reconcileChildFibers(\n          workInProgress,\n          currentPrimaryChild,\n          nextPrimaryChildren,\n          renderExpirationTime,\n        ));\n      }\n    }\n  }\n}\n\nfunction retrySuspenseComponentWithoutHydrating(\n  current: Fiber,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  // We're now not suspended nor dehydrated.\n  workInProgress.memoizedState = null;\n  // Retry with the full children.\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  // This will ensure that the children get Placement effects and\n  // that the old child gets a Deletion effect.\n  // We could also call forceUnmountCurrentAndReconcile.\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction mountDehydratedSuspenseComponent(\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    if (__DEV__) {\n      console.error(\n        'Cannot hydrate Suspense in legacy mode. Switch from ' +\n          'ReactDOM.hydrate(element, container) to ' +\n          'ReactDOM.createBlockingRoot(container, { hydrate: true })' +\n          '.render(element) or remove the Suspense components from ' +\n          'the server rendered components.',\n      );\n    }\n    workInProgress.expirationTime = Sync;\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    let serverDisplayTime = requestCurrentTimeForUpdate();\n    // Schedule a normal pri update to render this content.\n    let newExpirationTime = computeAsyncExpiration(serverDisplayTime);\n    if (enableSchedulerTracing) {\n      markSpawnedWork(newExpirationTime);\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.expirationTime = Never;\n    if (enableSchedulerTracing) {\n      markSpawnedWork(Never);\n    }\n  }\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(\n  current: Fiber,\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  suspenseState: SuspenseState,\n  renderExpirationTime: ExpirationTime,\n): null | Fiber {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n  // We use childExpirationTime to indicate that a child might depend on context, so if\n  // any context has changed, we need to treat is as if the input might have changed.\n  const hasContextChanged = current.childExpirationTime >= renderExpirationTime;\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using an earlier expiration time, if\n    // we are rendering at lower expiration than sync.\n    if (renderExpirationTime < Sync) {\n      if (suspenseState.retryTime <= renderExpirationTime) {\n        // This render is even higher pri than we've seen before, let's try again\n        // at even higher pri.\n        let attemptHydrationAtExpirationTime = renderExpirationTime + 1;\n        suspenseState.retryTime = attemptHydrationAtExpirationTime;\n        scheduleWork(current, attemptHydrationAtExpirationTime);\n        // TODO: Early abort this render.\n      } else {\n        // We have already tried to ping at a higher priority than we're rendering with\n        // so if we got here, we must have failed to hydrate at those levels. We must\n        // now give up. Instead, we're going to delete the whole subtree and instead inject\n        // a new real Suspense boundary to take its place, which may render content\n        // or fallback. This might suspend for a while and if it does we might still have\n        // an opportunity to hydrate before this pass commits.\n      }\n    }\n    // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.effectTag |= DidCapture;\n    // Leave the child in place. I.e. the dehydrated fragment.\n    workInProgress.child = current.child;\n    // Register a callback to retry this boundary once the server has sent the result.\n    registerSuspenseInstanceRetry(\n      suspenseInstance,\n      retryDehydratedSuspenseBoundary.bind(null, current),\n    );\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(\n      workInProgress,\n      suspenseInstance,\n    );\n    const nextProps = workInProgress.pendingProps;\n    const nextChildren = nextProps.children;\n    const child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n    let node = child;\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag |= Hydrating;\n      node = node.sibling;\n    }\n    workInProgress.child = child;\n    return workInProgress.child;\n  }\n}\n\nfunction scheduleWorkOnFiber(\n  fiber: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (fiber.expirationTime < renderExpirationTime) {\n    fiber.expirationTime = renderExpirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < renderExpirationTime) {\n    alternate.expirationTime = renderExpirationTime;\n  }\n  scheduleWorkOnParentPath(fiber.return, renderExpirationTime);\n}\n\nfunction propagateSuspenseContextChange(\n  workInProgress: Fiber,\n  firstChild: null | Fiber,\n  renderExpirationTime: ExpirationTime,\n): void {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        scheduleWorkOnFiber(node, renderExpirationTime);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleWorkOnFiber(node, renderExpirationTime);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild: null | Fiber): null | Fiber {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow: null | Fiber = null;\n  while (row !== null) {\n    let currentRow = row.alternate;\n    // New rows can't be content rows.\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n    row = row.sibling;\n  }\n  return lastContentRow;\n}\n\ntype SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void;\n\nfunction validateRevealOrder(revealOrder: SuspenseListRevealOrder) {\n  if (__DEV__) {\n    if (\n      revealOrder !== undefined &&\n      revealOrder !== 'forwards' &&\n      revealOrder !== 'backwards' &&\n      revealOrder !== 'together' &&\n      !didWarnAboutRevealOrder[revealOrder]\n    ) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards': {\n            console.error(\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'Use lowercase \"%s\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          case 'forward':\n          case 'backward': {\n            console.error(\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'React uses the -s suffix in the spelling. Use \"%ss\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          default:\n            console.error(\n              '\"%s\" is not a supported revealOrder on <SuspenseList />. ' +\n                'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n              revealOrder,\n            );\n            break;\n        }\n      } else {\n        console.error(\n          '%s is not a supported value for revealOrder on <SuspenseList />. ' +\n            'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n          revealOrder,\n        );\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(\n  tailMode: SuspenseListTailMode,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error(\n          '\"%s\" is not a supported value for tail on <SuspenseList />. ' +\n            'Did you mean \"collapsed\" or \"hidden\"?',\n          tailMode,\n        );\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error(\n          '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' +\n            '\"forwards\" or \"backwards\". ' +\n            'Did you mean to specify revealOrder=\"forwards\"?',\n          tailMode,\n        );\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot: mixed, index: number) {\n  if (__DEV__) {\n    let isArray = Array.isArray(childSlot);\n    let isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';\n    if (isArray || isIterable) {\n      let type = isArray ? 'array' : 'iterable';\n      console.error(\n        'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +\n          'an additional SuspenseList to configure its revealOrder: ' +\n          '<SuspenseList revealOrder=...> ... ' +\n          '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +\n          '</SuspenseList>',\n        type,\n        index,\n        type,\n      );\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction validateSuspenseListChildren(\n  children: mixed,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (\n      (revealOrder === 'forwards' || revealOrder === 'backwards') &&\n      children !== undefined &&\n      children !== null &&\n      children !== false\n    ) {\n      if (Array.isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        let iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n              i++;\n            }\n          }\n        } else {\n          console.error(\n            'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' +\n              'This is not useful since it needs multiple rows. ' +\n              'Did you mean to pass multiple children or an array?',\n            revealOrder,\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(\n  workInProgress: Fiber,\n  isBackwards: boolean,\n  tail: null | Fiber,\n  lastContentRow: null | Fiber,\n  tailMode: SuspenseListTailMode,\n  lastEffectBeforeRendering: null | Fiber,\n): void {\n  let renderState: null | SuspenseListRenderState =\n    workInProgress.memoizedState;\n  if (renderState === null) {\n    workInProgress.memoizedState = ({\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailExpiration: 0,\n      tailMode: tailMode,\n      lastEffect: lastEffectBeforeRendering,\n    }: SuspenseListRenderState);\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailExpiration = 0;\n    renderState.tailMode = tailMode;\n    renderState.lastEffect = lastEffectBeforeRendering;\n  }\n}\n\n// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder: SuspenseListRevealOrder = nextProps.revealOrder;\n  const tailMode: SuspenseListTailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  let shouldForceFallback = hasSuspenseContext(\n    suspenseContext,\n    (ForceSuspenseFallback: SuspenseContext),\n  );\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(\n      suspenseContext,\n      ForceSuspenseFallback,\n    );\n    workInProgress.effectTag |= DidCapture;\n  } else {\n    const didSuspendBefore =\n      current !== null && (current.effectTag & DidCapture) !== NoEffect;\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(\n        workInProgress,\n        workInProgress.child,\n        renderExpirationTime,\n      );\n    }\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & BlockingMode) === NoMode) {\n    // Outside of blocking mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards': {\n        let lastContentRow = findLastContentRow(workInProgress.child);\n        let tail;\n        if (lastContentRow === null) {\n          // The whole list is part of the tail.\n          // TODO: We could fast path by just rendering the tail now.\n          tail = workInProgress.child;\n          workInProgress.child = null;\n        } else {\n          // Disconnect the tail rows after the content row.\n          // We're going to render them separately later.\n          tail = lastContentRow.sibling;\n          lastContentRow.sibling = null;\n        }\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          tail,\n          lastContentRow,\n          tailMode,\n          workInProgress.lastEffect,\n        );\n        break;\n      }\n      case 'backwards': {\n        // We're going to find the first row that has existing content.\n        // At the same time we're going to reverse the list of everything\n        // we pass in the meantime. That's going to be our tail in reverse\n        // order.\n        let tail = null;\n        let row = workInProgress.child;\n        workInProgress.child = null;\n        while (row !== null) {\n          let currentRow = row.alternate;\n          // New rows can't be content rows.\n          if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n            // This is the beginning of the main content.\n            workInProgress.child = row;\n            break;\n          }\n          let nextRow = row.sibling;\n          row.sibling = tail;\n          tail = row;\n          row = nextRow;\n        }\n        // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n        initSuspenseListRenderState(\n          workInProgress,\n          true, // isBackwards\n          tail,\n          null, // last\n          tailMode,\n          workInProgress.lastEffect,\n        );\n        break;\n      }\n      case 'together': {\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          null, // tail\n          null, // last\n          undefined,\n          workInProgress.lastEffect,\n        );\n        break;\n      }\n      default: {\n        // The default reveal order is the same as not having\n        // a boundary.\n        workInProgress.memoizedState = null;\n      }\n    }\n  }\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  const providerType: ReactProviderType<any> = workInProgress.type;\n  const context: ReactContext<any> = providerType._context;\n\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(\n        providerPropTypes,\n        newProps,\n        'prop',\n        'Context.Provider',\n        getCurrentFiberStackInDev,\n      );\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    const oldValue = oldProps.value;\n    const changedBits = calculateChangedBits(context, newValue, oldValue);\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (\n        oldProps.children === newProps.children &&\n        !hasLegacyContextChanged()\n      ) {\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(\n        workInProgress,\n        context,\n        changedBits,\n        renderExpirationTime,\n      );\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n) {\n  let context: ReactContext<any> = workInProgress.type;\n  // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n  if (__DEV__) {\n    if ((context: any)._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error(\n            'Rendering <Context> directly is not supported and will be removed in ' +\n              'a future major release. Did you mean to render <Context.Consumer> instead?',\n          );\n        }\n      }\n    } else {\n      context = (context: any)._context;\n    }\n  }\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error(\n        'A context consumer was rendered with multiple children, or a child ' +\n          \"that isn't a function. A context consumer expects a single child \" +\n          'that is a function. If you did pass a function, make sure there ' +\n          'is no trailing or leading whitespace around it.',\n      );\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  const newValue = readContext(context, newProps.unstable_observedBits);\n  let newChildren;\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateFundamentalComponent(\n  current,\n  workInProgress,\n  renderExpirationTime,\n) {\n  const fundamentalImpl = workInProgress.type.impl;\n  if (fundamentalImpl.reconcileChildren === false) {\n    return null;\n  }\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderExpirationTime) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  reconcileChildren(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime,\n  );\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  cancelWorkTimer(workInProgress);\n\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  const updateExpirationTime = workInProgress.expirationTime;\n  if (updateExpirationTime !== NoWork) {\n    markUnprocessedUpdateTime(updateExpirationTime);\n  }\n\n  // Check if the children have any pending work.\n  const childExpirationTime = workInProgress.childExpirationTime;\n  if (childExpirationTime < renderExpirationTime) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n}\n\nfunction remountFiber(\n  current: Fiber,\n  oldWorkInProgress: Fiber,\n  newWorkInProgress: Fiber,\n): Fiber | null {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n    if (returnFiber === null) {\n      throw new Error('Cannot swap the root fiber.');\n    }\n\n    // Disconnect from the old current.\n    // It will get deleted.\n    current.alternate = null;\n    oldWorkInProgress.alternate = null;\n\n    // Connect to the new tree.\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref;\n\n    // Replace the child/sibling pointers above it.\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n      if (prevSibling === null) {\n        throw new Error('Expected parent to have a child.');\n      }\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n        if (prevSibling === null) {\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n      prevSibling.sibling = newWorkInProgress;\n    }\n\n    // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n    const last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = current;\n      returnFiber.lastEffect = current;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = current;\n    }\n    current.nextEffect = null;\n    current.effectTag = Deletion;\n\n    newWorkInProgress.effectTag |= Placement;\n\n    // Restart work from the new fiber.\n    return newWorkInProgress;\n  } else {\n    throw new Error(\n      'Did not expect this call in production. ' +\n        'This is a bug in React. Please file an issue.',\n    );\n  }\n}\n\n// 从父到子, 构建 Fiber 节点对象\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  // 1073741823\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(\n        current,\n        workInProgress,\n        createFiberFromTypeAndProps(\n          workInProgress.type,\n          workInProgress.key,\n          workInProgress.pendingProps,\n          workInProgress._debugOwner || null,\n          workInProgress.mode,\n          workInProgress.expirationTime,\n        ),\n      );\n    }\n  }\n  // 判断是否有旧的 Fiber 对象\n  // 初始渲染时 只有 rootFiber 节点存在 current\n  if (current !== null) {\n    // 获取旧的 props 对象\n    const oldProps = current.memoizedProps;\n    // 获取新的 props 对象\n    const newProps = workInProgress.pendingProps;\n    // 初始渲染时 false\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n      // 初始渲染时 false 两个值相同\n    } else if (updateExpirationTime < renderExpirationTime) {\n      // 初始渲染时 false\n      // 可以直接复用前一次更新的子Fiber, 不需要新建子Fiber\n      didReceiveUpdate = false;\n      // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n        case HostComponent:\n          pushHostContext(workInProgress);\n          if (\n            workInProgress.mode & ConcurrentMode &&\n            renderExpirationTime !== Never &&\n            shouldDeprioritizeSubtree(workInProgress.type, newProps)\n          ) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            }\n            // Schedule this fiber to re-render at offscreen priority. Then bailout.\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n          break;\n        case ClassComponent: {\n          const Component = workInProgress.type;\n          if (isLegacyContextProvider(Component)) {\n            pushLegacyContextProvider(workInProgress);\n          }\n          break;\n        }\n        case HostPortal:\n          pushHostContainer(\n            workInProgress,\n            workInProgress.stateNode.containerInfo,\n          );\n          break;\n        case ContextProvider: {\n          const newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n        case Profiler:\n          if (enableProfilerTimer) {\n            // Profiler should only call onRender when one of its descendants actually rendered.\n            const hasChildWork =\n              workInProgress.childExpirationTime >= renderExpirationTime;\n            if (hasChildWork) {\n              workInProgress.effectTag |= Update;\n            }\n          }\n          break;\n        case SuspenseComponent: {\n          const state: SuspenseState | null = workInProgress.memoizedState;\n          if (state !== null) {\n            if (enableSuspenseServerRenderer) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(\n                  workInProgress,\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n                );\n                // We know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved Suspense component.\n                // If it needs to be retried, it should have work scheduled on it.\n                workInProgress.effectTag |= DidCapture;\n                break;\n              }\n            }\n\n            // If this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. Check the priority of the primary\n            // child fragment.\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            const primaryChildExpirationTime =\n              primaryChildFragment.childExpirationTime;\n            if (\n              primaryChildExpirationTime !== NoWork &&\n              primaryChildExpirationTime >= renderExpirationTime\n            ) {\n              // The primary children have pending work. Use the normal path\n              // to attempt to render the primary children again.\n              return updateSuspenseComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            } else {\n              pushSuspenseContext(\n                workInProgress,\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n              );\n              // The primary children do not have pending work with sufficient\n              // priority. Bailout.\n              const child = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n              if (child !== null) {\n                // The fallback children have pending work. Skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n          }\n          break;\n        }\n        case SuspenseListComponent: {\n          const didSuspendBefore =\n            (current.effectTag & DidCapture) !== NoEffect;\n\n          const hasChildWork =\n            workInProgress.childExpirationTime >= renderExpirationTime;\n\n          if (didSuspendBefore) {\n            if (hasChildWork) {\n              // If something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // Something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. So we need to use the normal\n              // path to compute the correct tail.\n              return updateSuspenseListComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            }\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            workInProgress.effectTag |= DidCapture;\n          }\n\n          // If nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. Anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          let renderState = workInProgress.memoizedState;\n          if (renderState !== null) {\n            // Reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderState.rendering = null;\n            renderState.tail = null;\n          }\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n          if (hasChildWork) {\n            break;\n          } else {\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            return null;\n          }\n        }\n      }\n      // 复用 current\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // NoWork 常量 值为0 清空过期时间\n  workInProgress.expirationTime = NoWork;\n  // 根据当前 Fiber 的类型决定如何构建起子级 Fiber 对象\n  // 文件位置: shared/ReactWorkTags.js\n  switch (workInProgress.tag) {\n    // 2\n    // 函数组件在第一次被渲染时使用\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        // 旧 Fiber\n        current,\n        // 新 Fiber\n        workInProgress,\n        // 新 Fiber 的 type 值 初始渲染时是App组件函数\n        workInProgress.type,\n        // 同步 整数最大值 1073741823\n        renderExpirationTime,\n      );\n    }\n    // 16\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    // 0\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    // 1\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    // 3\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    // 5\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    // 6\n    case HostText:\n      return updateHostText(current, workInProgress);\n    // 13\n    case SuspenseComponent:\n      return updateSuspenseComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    // 4\n    case HostPortal:\n      return updatePortalComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    // 11\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    // 7\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n    // 8\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n    // 12\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n    // 10\n    case ContextProvider:\n      return updateContextProvider(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    // 9\n    case ContextConsumer:\n      return updateContextConsumer(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    // 14\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(type),\n              getCurrentFiberStackInDev,\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    // 15\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    // 17\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    // 19\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n    // 20\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        return updateFundamentalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    // 21\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    // 22\n    case Block: {\n      if (enableBlocksAPI) {\n        const block = workInProgress.type;\n        const props = workInProgress.pendingProps;\n        return updateBlock(\n          current,\n          workInProgress,\n          block,\n          props,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}\n\nexport {beginWork};\n"]},"metadata":{},"sourceType":"module"}