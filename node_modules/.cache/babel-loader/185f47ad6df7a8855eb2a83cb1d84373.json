{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { getParentInstance, traverseTwoPhase, traverseEnterLeave } from 'shared/ReactTreeTraversal';\nimport getListener from 'legacy-events/getListener';\nimport accumulateInto from './accumulateInto';\nimport forEachAccumulated from './forEachAccumulated';\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  const registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\n\n\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (__DEV__) {\n    if (!inst) {\n      console.error('Dispatching inst must not be null');\n    }\n  }\n\n  const listener = listenerAtPhase(inst, event, phase);\n\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    const targetInst = event._targetInst;\n    const parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\n\n\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    const registrationName = event.dispatchConfig.registrationName;\n    const listener = getListener(inst, registrationName);\n\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\n\n\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nexport function accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\nexport function accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\nexport function accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\nexport function accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}","map":{"version":3,"sources":["/Users/malinfeng/Desktop/mywww/react-test/src/react/packages/legacy-events/EventPropagators.js"],"names":["getParentInstance","traverseTwoPhase","traverseEnterLeave","getListener","accumulateInto","forEachAccumulated","listenerAtPhase","inst","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","phase","__DEV__","console","error","listener","_dispatchListeners","_dispatchInstances","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","targetInst","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateEnterLeaveDispatches","leave","enter","from","to","accumulateDirectDispatches"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  getParentInstance,\n  traverseTwoPhase,\n  traverseEnterLeave,\n} from 'shared/ReactTreeTraversal';\n\nimport getListener from 'legacy-events/getListener';\nimport accumulateInto from './accumulateInto';\nimport forEachAccumulated from './forEachAccumulated';\n\ntype PropagationPhases = 'bubbled' | 'captured';\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase: PropagationPhases) {\n  const registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  if (__DEV__) {\n    if (!inst) {\n      console.error('Dispatching inst must not be null');\n    }\n  }\n  const listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener,\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    const targetInst = event._targetInst;\n    const parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    const registrationName = event.dispatchConfig.registrationName;\n    const listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener,\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nexport function accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nexport function accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nexport function accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nexport function accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n"]},"metadata":{},"sourceType":"module"}